<!DOCTYPE html>
<html>
    <!-- title -->




<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Linus Lee">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Linus Lee">
    <meta name="keywords" content="Funky's NoteBook | Linus Lee">
    <meta name="description" content="It's Funky's NoteBook">
    <meta name="Cache-Control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Kubernetes Information Collection · Funky&#39;s NoteBook</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s 1;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= /css/style.css?v=201807017_1502 as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= /css/mobile.css?v=20180709 media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/gun.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
</head>

    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Funky&#39;s NoteBook</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Kubernetes Information Collection</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Funky's NoteBook</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style=








height:50vh;

>
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Kubernetes Information Collection
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "docker">docker</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count">5,515</span> / Reading time: <span class="post-count">23 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/07/17</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h3 id="kubernetes-架构"><a href="#kubernetes-架构" class="headerlink" title="kubernetes 架构"></a>kubernetes 架构</h3><h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p><img src="/images/分层架构.png" alt="分层架构"></p>
<ul>
<li><p>核心层:Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供 插件式应用执行环境 </p>
</li>
<li><p>应用层:部署(无状态应用、有状态应用、批处理任务、集群应用等)和路 由(服务发现、DNS解析等) </p>
</li>
<li><p>管理层:系统度量(如基础设施、容器和网络的度量)，自动化(如自动扩 展、动态Provision等)以及策略管理(RBAC、Quota、PSP、NetworkPolicy 等) </p>
</li>
<li><p>接口层:kubectl命令行工具、客户端SDK以及集群联邦 </p>
</li>
<li><p>生态系统:在接口层之上的庞大容器集群管理调度的生态系统，可以划分为 </p>
<p>两个范畴 :</p>
<ul>
<li>Kubernetes外部:日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用 、ChatOps等 </li>
<li>Kubernetes内部:CRI、CNI、CVI、镜像仓库、CloudProvider、集群自身的配置 和管理等 </li>
</ul>
</li>
</ul>
<h4 id="架构设计优缺点"><a href="#架构设计优缺点" class="headerlink" title="架构设计优缺点"></a>架构设计优缺点</h4><ul>
<li><p>优点</p>
<ul>
<li>容错性:保证Kubernetes系统稳定性和安全性的基础 </li>
<li>易扩展性:保证Kubernetes对变更友好，可以快速迭代增 加新功能的基础。 </li>
<li>API分版本，API可自由扩展(CRD)</li>
<li>插件化，调度器，容器运行时，存储均可扩展 </li>
<li>声明式(Declarative)的而不是命令式(Imperative): 声明式操作在分布式系统中的好处是稳定，不怕丢操作 或运行多次，例如设置副本数为3的操作运行多次也还是 一个结果，而给副本数加1的操作就不是声明式的，运行 多次结果就错了。 </li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>配置中心化:所有状态都保存在中心的etcd上，而非分布 </p>
<p>式存储，性能有一定制约 </p>
</li>
<li><p>单体调度:调度一致性好而吞吐低 </p>
<p><img src="/images/调度.png" alt="调度"></p>
</li>
</ul>
</li>
</ul>
<h3 id="k8s提供的抽象"><a href="#k8s提供的抽象" class="headerlink" title="k8s提供的抽象"></a>k8s提供的抽象</h3><p><img src="/images/架构.png" alt="架构"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>EN</th>
<th>CN</th>
</tr>
</thead>
<tbody>
<tr>
<td>Container</td>
<td>容器</td>
</tr>
<tr>
<td>Pod</td>
<td>容器组</td>
</tr>
<tr>
<td>ReplicaSet</td>
<td>副本组合</td>
</tr>
<tr>
<td>Service</td>
<td>服务</td>
</tr>
<tr>
<td>Label</td>
<td>标签</td>
</tr>
<tr>
<td>Node</td>
<td>节点</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Pod</p>
<p><img src="/images/pod.png" alt="pod"></p>
<ul>
<li>Pod是在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个 容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务 。Pod对多容器的支持是K8最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用 来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们 一块儿工作才能提供一个微服务;这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合 成一个微服务对外提供服务。 </li>
<li>Pod是Kubernetes集群中所有业务类型的基础，可以看作运行在K8集群中的小机器人，不同类型的业务就需要不 同类型的小机器人去执行。目前Kubernetes中的业务主要可以分为长期伺服型(long-running)、批处理型( batch)、节点后台支撑型(node-daemon)和有状态应用型(stateful application);分别对应的控制器为 Deployment、Job、DaemonSet和PetSet。 </li>
</ul>
</li>
<li><p>副本集 (Replica Set，RS)</p>
<p><strong>Replica Set</strong>:Kubernetes集群中保证Pod高可用的API对象。 通过监控运行中的Pod来保证集群中运行指定数目的Pod副本 。指定的数目可以是多个也可以是1个;少于指定数目，RS 就会启动运行新的Pod副本;多于指定数目，RS就会杀死多 余的Pod副本。即使在指定数目为1的情况下，通过RS运行 Pod也比直接运行Pod更明智，因为RS也可以发挥它高可用 的能力，保证永远有1个Pod在运行。RS适用于长期伺服型的 业务类型，比如提供高可用的Web服务。 </p>
</li>
<li><p>服务 (Service)</p>
<p><img src="/images/service.png" alt="service"></p>
<p>RS只是保证了支撑服务的微服务Pod的 数量，但是没有解决如何访问这些服务 的问题。一个Pod只是一个运行服务的 实例，随时可能在一个节点上停止，在 另一个节点以一个新的IP启动一个新的 Pod，因此不能以确定的IP和端口号提 供服务。要稳定地提供服务需要服务发 现和负载均衡能力。服务发现完成的工 作，是针对客户端访问的服务，找到对 应的的后端服务实例。在K8集群中， 客户端需要访问的服务就是Service对象 。每个Service会对应一个集群内部有效 的虚拟IP，集群内部通过虚拟IP访问一 个服务。</p>
<h5 id="kubernetes-中的对象"><a href="#kubernetes-中的对象" class="headerlink" title="kubernetes 中的对象"></a>kubernetes 中的对象</h5></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1beta1 kind: Deployment metadata:</span><br><span class="line">name: nginx-deployment spec:</span><br><span class="line">replicas: 3 template:</span><br><span class="line">metadata: labels:</span><br><span class="line">app: nginx spec:</span><br><span class="line">containers:</span><br><span class="line">- name: nginx</span><br><span class="line">image: nginx:1.7.9 ports:</span><br><span class="line">- containerPort: 80</span><br><span class="line">status:</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<ul>
<li>Metadata:标识API对象，每个对象都至少有3个元数 据:namespace，name和uid;除此以外还有各种各样的 标签labels用来标识和匹配不同的对象，例如用户可以 用标签env来标识区分不同的服务部署环境，分别用 env=dev、env=testing、env=production来标识开发、 测试、生产的不同服务 </li>
<li>Spec: 描述了用户期望Kubernetes集群中 的分布式系统达到的理想状态(Desired State)，例如用户可以通过复制控制器 Replication Controller设置期望的Pod副本 数为3 </li>
<li>Status:系统实际当前达到的状态(Status) ，例如系统当前实际的Pod副本数为2;那么复制 控制器当前的程序逻辑就是自动启动新的Pod， 争取达到副本数为3 </li>
</ul>
<h3 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>资源对象</td>
<td style="text-align:left">Pod、ReplicaSet、ReplicationController、Deployment 、StatefulSet、DaemonSet、Job、CronJob、 HorizontalPodAutoscaling</td>
</tr>
<tr>
<td>配置对象</td>
<td style="text-align:left">Node、Namespace、Service、Secret、ConfigMap、 Ingress、Label、ThirdPartyResource、 ServiceAccount</td>
</tr>
<tr>
<td>存储对象</td>
<td style="text-align:left">Volume、Persistent Volume</td>
</tr>
<tr>
<td>策略对象</td>
<td style="text-align:left">SecurityContext、ResourceQuota、LimitRange</td>
</tr>
</tbody>
</table>
</div>
<h3 id="业界各种安装方式对比"><a href="#业界各种安装方式对比" class="headerlink" title="业界各种安装方式对比"></a>业界各种安装方式对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>安装方式</th>
<th>安装前准备</th>
<th>特点</th>
<th>高可用</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>kubeadm</td>
<td>kubectl + kubelet</td>
<td>不对接节点，自己准备 节点环境，容易被集成 到其他工具链中</td>
<td>HA(T+)</td>
<td>高</td>
</tr>
<tr>
<td>kops</td>
<td>kubectl</td>
<td>对接AWS/GCE/Vmware 帮助你管理虚机</td>
<td>HA</td>
<td>中</td>
</tr>
<tr>
<td>minikube</td>
<td>kubectl</td>
<td>单机对接VM</td>
<td>无</td>
<td>低</td>
</tr>
<tr>
<td>rancher</td>
<td>rancher</td>
<td>墙内加速，跨云能力</td>
<td>不清楚</td>
<td>中</td>
</tr>
<tr>
<td>手工</td>
<td>11+组件</td>
<td>任意集群</td>
<td>HA</td>
<td>疯狂</td>
</tr>
</tbody>
</table>
</div>
<h3 id="当pod创建时-k8s到底干了啥"><a href="#当pod创建时-k8s到底干了啥" class="headerlink" title="当pod创建时,k8s到底干了啥"></a>当pod创建时,k8s到底干了啥</h3><p><img src="/images/pod_create.png" alt="pod_create"></p>
<ul>
<li>kubectl提交创建请求，可以通过API Server的Restful API，也可以使用kubectl命令行工具。支持的数据类型包括JSON和YAML。 </li>
<li>kube-apiserver处理用户请求，存储Pod数据到etcd。 </li>
<li>kube-scheduler通过API Server查看未绑定的Pod。尝试为Pod分配主机。 <ul>
<li>过滤主机 (调度预选):调度器用一组规则过滤掉不符合要求的主机。比如Pod指定了所需要的资源量，那么可用资源比Pod需要的资源量少的主机会被过滤掉。</li>
<li>主机打分(调度优选):对第一步筛选出的符合要求的主机进行打分，在主机打分阶段，调度器会考虑一些整体优化策略，比如把容一个Replication Controller的副本分布到不同的主机上，使用最低负载的主机等。 </li>
</ul>
</li>
<li><p>kube-scheduler选择主机:选择打分最高的主机，进行binding操作，这个操作本质是通过kube-apisever修改Pod的字段，结果存储到etcd中。 </p>
</li>
<li><p>kubelet根据调度结果执行Pod创建操作: 绑定成功后，pod.spec.nodeName有值了。运行在每个工作节点上的kubelet也会定期与etcd同步pod信息(属于自己这个node的) </p>
</li>
<li>docker接受到kubelet下发的命令，启动相应容器，至此，一个Pod启动完毕 </li>
</ul>
<blockquote>
<p>kubectl自动补全:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ <span class="built_in">source</span> &lt;(kubectl completion bash) <span class="comment">#bash下自动补全</span></span><br><span class="line">&gt; $ <span class="built_in">source</span> &lt;(kubectl completion zsh) <span class="comment"># zsh下自动补全</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>k8s免费在线lab网站: <a href="https://labs.play-with-k8s.com/" target="_blank" rel="noopener">https://labs.play-with-k8s.com/</a></p>
</blockquote>
<h3 id="kubectl-常见命令"><a href="#kubectl-常见命令" class="headerlink" title="kubectl 常见命令"></a><a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noopener">kubectl 常见命令</a></h3><p>详见:<a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noopener">Cheat Sheet</a></p>
<h4 id="kubectl上下文和配置"><a href="#kubectl上下文和配置" class="headerlink" title="kubectl上下文和配置"></a>kubectl上下文和配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl config view <span class="comment"># 显示合并后的 kubeconfig 配置</span></span><br><span class="line">$ kubectl config current-context <span class="comment"># 显示当前的上下文</span></span><br><span class="line">$ kubectl config use-context my-cluster-name <span class="comment"># 设置默认上下文为 my-cluster- name</span></span><br><span class="line"><span class="comment"># 使用指定的用户名和 namespace 设置上下文</span></span><br><span class="line">$ kubectl config <span class="built_in">set</span>-context gce --user=cluster-admin --namespace=foo \</span><br><span class="line">&amp;&amp; kubectl config use-context gce</span><br><span class="line"><span class="comment"># kubectl config current-context –h 帮助及例子</span></span><br></pre></td></tr></table></figure>
<h4 id="kubectl-创建对象"><a href="#kubectl-创建对象" class="headerlink" title="kubectl 创建对象"></a>kubectl 创建对象</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f ./my-manifest.yaml <span class="comment"># 创建资源</span></span><br><span class="line">$ kubectl create -f ./my1.yaml -f ./my2.yaml <span class="comment"># 使用多个文件创建资源</span></span><br><span class="line">$ kubectl create -f ./dir</span><br><span class="line">$ kubectl create -f https://git.io/vPieo</span><br><span class="line">$ kubectl run nginx --image=nginx</span><br><span class="line">$ kubectl explain pods <span class="comment"># 获取 pod 和 svc 的文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建包含几个 key 的 Secret</span></span><br><span class="line">$ cat &lt;&lt;EOF | kubectl create -f - apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">name: mysecret <span class="built_in">type</span>: Opaque data:</span><br><span class="line">password: $(<span class="built_in">echo</span> <span class="string">"s33msi4"</span> | base64)</span><br><span class="line">username: $(<span class="built_in">echo</span> <span class="string">"jane"</span> | base64) EOF</span><br></pre></td></tr></table></figure>
<h4 id="kubectl显示和查找资源"><a href="#kubectl显示和查找资源" class="headerlink" title="kubectl显示和查找资源"></a>kubectl显示和查找资源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get commands with basic output $ kubectl get services</span></span><br><span class="line"></span><br><span class="line">$ kubectl get pods --all-namespaces </span><br><span class="line"><span class="comment"># 列出所有 namespace 中的所有 service</span></span><br><span class="line"></span><br><span class="line">$ kubectl get pods -o wide</span><br><span class="line"><span class="comment"># 列出所有 namespace 中的所有 pod</span></span><br><span class="line"></span><br><span class="line">$ kubectl get deployment my-dep</span><br><span class="line"><span class="comment"># 列出所有 pod 并显示详细信息 # 列出指定 deployment</span></span><br><span class="line"></span><br><span class="line">$ kubectl get pods --include-uninitialized <span class="comment"># 列出该 namespace 中的所有 pod 包 括未初始化的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用详细输出来描述命令</span></span><br><span class="line">$ kubectl describe nodes my-node $ kubectl describe pods my-pod</span><br><span class="line">$ kubectl get services --sort-by=.metadata.name <span class="comment"># List Services Sorted by Name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据重启次数排序列出 pod</span></span><br><span class="line">$ kubectl get pods --sort-by=<span class="string">'.status.containerStatuses[0].restartCount'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有具有 app=cassandra 的 pod 中的 version 标签 $ kubectl get pods --selector=app=cassandra rc -o \</span></span><br><span class="line">jsonpath=<span class="string">'&#123;.items[*].metadata.labels.version&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有节点的 ExternalIP</span></span><br><span class="line">$ kubectl get nodes -o jsonpath=<span class="string">'&#123;.items[*].status.addresses[?(@.type=="ExternalIP")].address&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据重启次数排序列出 pod</span></span><br><span class="line">$ kubectl get pods --sort-by=<span class="string">'.status.containerStatuses[0].restartCount'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有具有 app=cassandra 的 pod 中的 version 标签 $ kubectl get pods --selector=app=cassandra rc -o \</span></span><br><span class="line">jsonpath=<span class="string">'&#123;.items[*].metadata.labels.version&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有节点的 ExternalIP</span></span><br><span class="line">$ kubectl get nodes -o jsonpath=<span class="string">'&#123;.items[*].status.addresses[?(@.type=="ExternalIP")].address&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出属于某个 PC 的 Pod 的名字</span></span><br><span class="line"><span class="comment"># “jq”命令用于转换复杂的 jsonpath，参考 https://stedolan.github.io/jq/</span></span><br><span class="line">$ sel=<span class="variable">$&#123;$(kubectl get rc my-rc --output=json | jq -j '.spec.selector | to_entries | .[] | "\(.key)=\(.value),"')%?&#125;</span></span><br><span class="line">$ <span class="built_in">echo</span> $(kubectl get pods --selector=<span class="variable">$sel</span> --output=jsonpath=&#123;.items..metadata.name&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看哪些节点已就绪</span></span><br><span class="line">$ JSONPATH=<span class="string">'&#123;range .items[*]&#125;&#123;@.metadata.name&#125;:&#123;range @.status.conditions[*]&#125;&#123;@.type&#125;=&#123;@.status&#125;;&#123;end&#125;&#123;end&#125;'</span> \</span><br><span class="line">&amp;&amp; kubectl get nodes -o jsonpath=<span class="string">"<span class="variable">$JSONPATH</span>"</span> | grep <span class="string">"Ready=True"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前 Pod 中使用的 Secret</span></span><br><span class="line">$ kubectl get pods -o json | jq <span class="string">'.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name'</span> | grep -v null | sort | uniq</span><br></pre></td></tr></table></figure>
<h4 id="kubectl编辑资源"><a href="#kubectl编辑资源" class="headerlink" title="kubectl编辑资源"></a>kubectl编辑资源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit svc/docker-registry <span class="comment"># 编辑名为 docker-registry 的 service</span></span><br><span class="line">$ KUBE_EDITOR=<span class="string">"nano"</span> kubectl edit svc/docker-registry <span class="comment"># 使用其它编辑器</span></span><br></pre></td></tr></table></figure>
<h4 id="kubectl-Scale-资源"><a href="#kubectl-Scale-资源" class="headerlink" title="kubectl Scale 资源"></a>kubectl Scale 资源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl scale --replicas=3 rs/foo <span class="comment"># Scale a replicaset named 'foo' to 3</span></span><br><span class="line">$ kubectl scale --replicas=3 -f foo.yaml <span class="comment"># Scale a resource specified in "foo.yaml" to 3</span></span><br><span class="line">$ kubectl scale --current-replicas=2 --replicas=3 deployment/mysql <span class="comment"># If the deployment named mysql's current size is 2, scale mysql to 3</span></span><br><span class="line">$ kubectl scale --replicas=5 rc/foo rc/bar rc/baz <span class="comment"># Scale multiple replication controllers</span></span><br></pre></td></tr></table></figure>
<h4 id="kubectl-删除资源"><a href="#kubectl-删除资源" class="headerlink" title="kubectl 删除资源"></a>kubectl 删除资源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f ./pod.json                                              <span class="comment"># Delete a pod using the type and name specified in pod.json</span></span><br><span class="line">$ kubectl delete pod,service baz foo                                        <span class="comment"># Delete pods and services with same names "baz" and "foo"</span></span><br><span class="line">$ kubectl delete pods,services -l name=myLabel                              <span class="comment"># Delete pods and services with label name=myLabel</span></span><br><span class="line">$ kubectl delete pods,services -l name=myLabel --include-uninitialized      <span class="comment"># Delete pods and services, including uninitialized ones, with label name=myLabel</span></span><br><span class="line">$ kubectl -n my-ns delete po,svc --all                                      <span class="comment"># Delete all pods and services, including uninitialized ones, in namespace my-ns,</span></span><br></pre></td></tr></table></figure>
<h4 id="kubectl与运行中的-Pod-交互"><a href="#kubectl与运行中的-Pod-交互" class="headerlink" title="kubectl与运行中的 Pod 交互"></a>kubectl与运行中的 Pod 交互</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs my-pod</span><br><span class="line">$ kubectl logs my-pod -c my-container pod 中有多个容器的情况下使用)</span><br><span class="line">$ kubectl logs -f my-pod</span><br><span class="line">$ kubectl logs -f my-pod -c my-container 中有多个容器的情况下使用)</span><br><span class="line"><span class="comment"># dump 输出 pod 的日志(stdout)</span></span><br><span class="line"><span class="comment"># dump 输出 pod 中容器的日志(stdout，</span></span><br><span class="line"><span class="comment"># 流式输出 pod 的日志(stdout)</span></span><br><span class="line"><span class="comment"># 流式输出 pod 中容器的日志(stdout，pod</span></span><br><span class="line">$ kubectl run -i --tty busybox --image=busybox -- sh <span class="comment"># 交互式 shell 的方式运行 pod</span></span><br><span class="line">$ kubectl attach my-pod -i</span><br><span class="line">$ kubectl port-forward my-pod 5000:6000 端口</span><br><span class="line">$ kubectl <span class="built_in">exec</span> my-pod -- ls / 下)</span><br><span class="line"><span class="comment"># 连接到运行中的容器</span></span><br><span class="line"><span class="comment"># 转发 pod 中的 6000 端口到本地的 5000</span></span><br><span class="line"><span class="comment"># 在已存在的容器中执行命令(只有一个容器的情况</span></span><br><span class="line">$ kubectl <span class="built_in">exec</span> my-pod -c my-container -- ls / <span class="comment"># 在已存在的容器中执行命令(pod 中有多个 容器的情况下)</span></span><br><span class="line">$ kubectl top pod POD_NAME --containers <span class="comment"># 显示指定 pod 和容器的指标度量</span></span><br></pre></td></tr></table></figure>
<h4 id="kubectl与节点和集群交互"><a href="#kubectl与节点和集群交互" class="headerlink" title="kubectl与节点和集群交互"></a>kubectl与节点和集群交互</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cordon my-node</span><br><span class="line">$ kubectl drain my-node</span><br><span class="line">$ kubectl uncordon my-node</span><br><span class="line">$ kubectl top node my-node</span><br><span class="line">$ kubectl cluster-info</span><br><span class="line">$ kubectl cluster-info dump</span><br><span class="line"><span class="comment"># 标记 my-node 不可调度 # 清空 my-node 以待维护</span></span><br><span class="line"><span class="comment"># 标记 my-node 可调度</span></span><br><span class="line"><span class="comment"># 显示 my-node 的指标度量</span></span><br><span class="line"><span class="comment"># 显示 master 和服务的地址</span></span><br><span class="line"><span class="comment"># 将当前集群状态输出到 stdout</span></span><br><span class="line">  $ kubectl cluster-info dump --output-directory=/path/to/cluster-state <span class="comment"># 将当前集群状态输出</span></span><br><span class="line">到 /path/to/cluster-state</span><br><span class="line"><span class="comment"># 如果该键和影响的污点(taint)已存在，则使用指定的值替换</span></span><br><span class="line">$ kubectl taint nodes foo dedicated=special-user:NoSchedule</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他获取帮助的途径</p>
<ul>
<li><p>使用命令 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl * -h</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 python</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; pip install kube-shell</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="k8s构建高可用集群"><a href="#k8s构建高可用集群" class="headerlink" title="k8s构建高可用集群"></a>k8s构建高可用集群</h3><p><img src="/images/k8s_ha.png" alt="k8s_ha"></p>
<p><a href="https://kubernetes.io/docs/setup/independent/high-availability/" target="_blank" rel="noopener">k8s构建高可用集群方案介绍(点我跳转)</a></p>
<ul>
<li>Establishing a redundant, reliable data storage layer<ul>
<li>Clustering etcd<ul>
<li>Validating your cluster </li>
</ul>
</li>
<li>Even more reliable storage </li>
</ul>
</li>
<li>Replicated API Servers<ul>
<li>Installing configuration files  Starting the API Server</li>
<li>Load balancing</li>
<li>Endpoint reconciler </li>
</ul>
</li>
<li>Master elected components <ul>
<li>Installing configuration files </li>
</ul>
</li>
</ul>
<h3 id="k8s应用管理"><a href="#k8s应用管理" class="headerlink" title="k8s应用管理"></a>k8s应用管理</h3><h4 id="pod详解"><a href="#pod详解" class="headerlink" title="pod详解"></a>pod详解</h4><p><img src="/images/pod.png" alt="pod"></p>
<ul>
<li>Pod就像是豌豆荚一样，它由一个或者多个容器组成 </li>
<li>Pod中的容器共享IP地址和端口号，它们之间可以通过localhost互相发现 。它们之间可以通过进程间通信，例如SystemV信号或者POSIX共享内 存。不同Pod之间的容器具有不同的IP地址，不能直接通过IPC通信。 </li>
<li>Pod中的容器也有访问共享volume的权限，这些volume会被定义成pod的 一部分并挂载到应用容器的文件系统中。 </li>
</ul>
<h4 id="pod的设计动机"><a href="#pod的设计动机" class="headerlink" title="pod的设计动机"></a>pod的设计动机</h4><ul>
<li><p>容器介于操作系统和应用之间，容器的推荐玩法是每个容器运行一个进程。 </p>
<ul>
<li>外部掌控多容器的组合和生命周期 — redhat和docker公司的控制权 之争 </li>
<li>单容器多进程玩法的案例 — 阿里的pouch项目 </li>
</ul>
</li>
<li><p>对外，Pod作为一个独立的部署单位，支持横向扩展和复制。 共生(协同调度)，命运共同体(例如被终结)，协同复制 ，资源共享，依赖管理 </p>
</li>
<li><p>对内，Pod内容器互相协作 </p>
<ul>
<li><p>pod中的应用必须协调端口占用。每个pod都有一个唯一的IP地址， 跟物理机和其他pod都处于一个扁平的网络空间中，它们之间可以 直接连通。 </p>
</li>
<li><p>Pod中应用容器的hostname被设置成Pod的名字。 </p>
</li>
<li><p>Pod中的应用容器可以共享volume。Volume能够保证pod重启时使 </p>
<p>用的数据不丢失。 </p>
</li>
</ul>
</li>
</ul>
<h4 id="pod的非持久性"><a href="#pod的非持久性" class="headerlink" title="pod的非持久性"></a>pod的非持久性</h4><p>Pod在以下几种情况下都会被终结:</p>
<ul>
<li>调度失败 </li>
<li>节点故障</li>
<li>缺少资源</li>
<li>节点维护</li>
<li>用户主动干掉Pod </li>
</ul>
<h4 id="init容器"><a href="#init容器" class="headerlink" title="init容器"></a>init容器</h4><ul>
<li><p>Init 容器是一种专用的容器，在应用程序容器启动之前运行 </p>
</li>
<li><p>init 容器总是运行到成功完成为止。 </p>
</li>
<li><p>每个 Init 容器都必须在下一个 Init 容器启动之前成功完 成。 </p>
</li>
<li><p>Init 容器能做什么?</p>
<ul>
<li><p>等待一个 Service 创建完成，通过类似如下 shell 命令: </p>
<p>for i in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; exit 1</p>
</li>
<li><p>在启动应用容器之前等一段时间，使用类似 sleep 60 的命令。 </p>
</li>
</ul>
</li>
</ul>
<h4 id="Pod中容器镜像常见设置"><a href="#Pod中容器镜像常见设置" class="headerlink" title="Pod中容器镜像常见设置"></a>Pod中容器镜像常见设置</h4><div class="table-container">
<table>
<thead>
<tr>
<th>pod.spec.containers[]. imagePullPolicy</th>
<th>镜像拉取策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>IfNotPresent(默认)</td>
<td>在没有此镜像时下载</td>
</tr>
<tr>
<td>Always</td>
<td>每次必下载</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>镜像tag设置</th>
<th>拉取策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>Image:latest</td>
<td>每次必下载</td>
</tr>
<tr>
<td>image</td>
<td>每次必下载</td>
</tr>
<tr>
<td>image:*</td>
<td>在没有此镜像时下载</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>扩展:</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/containers/images/#configuring-nodes-to-authenticate-to-a-private-repository" target="_blank" rel="noopener">私有镜像仓库配置</a></li>
<li><a href="https://kubernetes.io/docs/concepts/containers/container-environment-variables/" target="_blank" rel="noopener">容器环境变量</a></li>
<li><a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noopener">容器生命周期</a></li>
</ul>
</blockquote>
<h4 id="Pod-status-phase"><a href="#Pod-status-phase" class="headerlink" title="Pod.status.phase"></a>Pod.status.phase</h4><div class="table-container">
<table>
<thead>
<tr>
<th>容器状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>挂起(Pending)</td>
<td>Pod 已被 Kubernetes 系统接受，但有一个或者多个容器 镜像尚未创建。等待时间包括调度 Pod 的时间和通过网 络下载镜像的时间，这可能需要花点时间。</td>
</tr>
<tr>
<td>运行中(Running)</td>
<td>该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都 已被创建。至少有一个容器正在运行，或者正处于启动 或重启状态。</td>
</tr>
<tr>
<td>成功(Successed)</td>
<td>Pod 中的所有容器都被成功终止，并且不会再重启。</td>
</tr>
<tr>
<td>失败(Failed)</td>
<td>Pod 中的所有容器都已终止了，并且至少有一个容器是 因为失败终止。也就是说，容器以非0状态退出或者被 系统终止。</td>
</tr>
<tr>
<td>未知(Unkonwn)</td>
<td>因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="容器探针-注意不是Pod探针"><a href="#容器探针-注意不是Pod探针" class="headerlink" title="容器探针(注意不是Pod探针)"></a>容器探针(注意不是Pod探针)</h4><ul>
<li>探针探查方式 <ul>
<li>ExecAction:在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。 </li>
<li>TCPSocketAction:对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。</li>
<li>HTTPGetAction:对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。</li>
</ul>
</li>
<li>探针结果:成功、失败、未知 </li>
<li>探针引起外部动作 <ul>
<li>livenessProbe:指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 重启策略 的影响。如果容器 不提供存活探针，则默认状态为 Success。 </li>
<li>readinessProbe:指示容器是否准备好服务请求。如果就绪探测失败 ，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供 就绪探针，则默认状态为 Success </li>
</ul>
</li>
</ul>
<h4 id="容器重启策略"><a href="#容器重启策略" class="headerlink" title="容器重启策略"></a>容器重启策略</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Pod.spec.restart Policy字段</th>
<th>行为:适用于Pod中所有失败的容器</th>
</tr>
</thead>
<tbody>
<tr>
<td>Always(默认)</td>
<td>exitCode=任何数字，执行重启操作</td>
</tr>
<tr>
<td>OnFailure</td>
<td>exitCode!=0，执行重启操作</td>
</tr>
<tr>
<td>Never</td>
<td>exitCode=任何数字，不重启</td>
</tr>
</tbody>
</table>
</div>
<h5 id="以五分钟为上限的指数退避延迟-10秒，20秒，40秒…-重新启动，并在成功执行十分钟后重置。"><a href="#以五分钟为上限的指数退避延迟-10秒，20秒，40秒…-重新启动，并在成功执行十分钟后重置。" class="headerlink" title="以五分钟为上限的指数退避延迟(10秒，20秒，40秒… )重新启动，并在成功执行十分钟后重置。"></a>以五分钟为上限的指数退避延迟(10秒，20秒，40秒… )重新启动，并在成功执行十分钟后重置。</h5><blockquote>
<p>更多信息: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; kubectl run -h</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="pod状态与容器状态的关系"><a href="#pod状态与容器状态的关系" class="headerlink" title="pod状态与容器状态的关系"></a>pod状态与容器状态的关系</h4><div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>退出状态</th>
<th>log event</th>
<th>restartPolicy</th>
<th>行为</th>
<th>Pod.status.phase</th>
</tr>
</thead>
<tbody>
<tr>
<td>1个</td>
<td>success</td>
<td>completion</td>
<td>Always</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>1个</td>
<td>success</td>
<td>completion</td>
<td>OnFailure</td>
<td>无</td>
<td>Succeeded</td>
</tr>
<tr>
<td>1个</td>
<td>success</td>
<td>completion</td>
<td>Never</td>
<td>无</td>
<td>Succeeded</td>
</tr>
<tr>
<td>1个</td>
<td>fail</td>
<td>failure</td>
<td>Always</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>1个</td>
<td>fail</td>
<td>failure</td>
<td>OnFailure</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>1个</td>
<td>fail</td>
<td>failure</td>
<td>Never</td>
<td>无</td>
<td>Failed</td>
</tr>
<tr>
<td>2个</td>
<td>一个fail一个正常运行</td>
<td>failure</td>
<td>Always</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>2个</td>
<td>一个fail一个正常运行</td>
<td>failure</td>
<td>OnFailure</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>2个</td>
<td>一个fail一个正常运行</td>
<td>failure</td>
<td>Never</td>
<td>无</td>
<td>Running</td>
</tr>
<tr>
<td>2个</td>
<td>一个not running一个exit</td>
<td>failure</td>
<td>Always</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>2个</td>
<td>一个not running一个exit</td>
<td>failure</td>
<td>OnFailure</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>2个</td>
<td>一个not running一个exit</td>
<td>failure</td>
<td>Never</td>
<td>无</td>
<td>Failed</td>
</tr>
<tr>
<td>1个</td>
<td>out of memeory</td>
<td>OOM</td>
<td>Always</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>1个</td>
<td>out of memeory</td>
<td>OOM</td>
<td>OnFailure</td>
<td>重启容器</td>
<td>Running</td>
</tr>
<tr>
<td>1个</td>
<td>out of memeory</td>
<td>OOM</td>
<td>Nerver</td>
<td>无</td>
<td>Failed</td>
</tr>
<tr>
<td>n个</td>
<td>磁盘崩溃</td>
<td>failure</td>
<td>A/O/N</td>
<td>杀死所有容器 如果pod被管 控，异地重建</td>
<td>Failed</td>
</tr>
<tr>
<td>n个</td>
<td>node被分区</td>
<td>failure</td>
<td>A/O/N</td>
<td>等待node超时 如果pod被管 控，异地重建</td>
<td>Failed</td>
</tr>
</tbody>
</table>
</div>
<h4 id="ReplicaSet-副本集"><a href="#ReplicaSet-副本集" class="headerlink" title="ReplicaSet: 副本集"></a>ReplicaSet: 副本集</h4><p>ReplicaSet是下一代复制控制器。现在<em>ReplicaSet</em>和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener"><em>Replication Controller</em></a>之间的唯一区别是选择器支持。ReplicaSet支持<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签用户指南中</a>描述的新的基于集合的选择器要求，而Replication Controller仅支持基于等同的选择器要求。</p>
<p>大多数<a href="https://kubernetes.io/docs/user-guide/kubectl/" target="_blank" rel="noopener"><code>kubectl</code></a>支持复制控制器的命令也支持ReplicaSet。<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener"><code>rolling-update</code></a>命令是一个例外 。如果您想要滚动更新功能，请考虑使用Deployment。此外， <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener"><code>rolling-update</code></a>命令是必需的，而Deployments是声明性的，因此我们建议通过<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout" target="_blank" rel="noopener"><code>rollout</code></a>命令使用Deployments 。</p>
<p>虽然ReplicaSet可以独立使用，但今天它主要被 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments</a>用作协调pod创建，删除和更新的机制。使用“Deloyment”时，不必担心管理它们创建的副本集。部署拥有并管理其ReplicaSet。</p>
<p>ReplicaSet确保在任何给定时间运行指定数量的pod副本。但是，Deployment是一个更高级别的概念，它管理ReplicaSet并为pod提供声明性更新以及许多其他有用的功能。因此，除非您需要自定义更新编排或根本不需要更新，否则我们建议您使用部署而不是直接使用ReplicaSet。</p>
<p>这实际上意味着您可能永远不需要操作ReplicaSet对象：改为使用Deployment，并在spec部分中定义您的应用程序。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">frontend</span> <span class="comment">#自动插入pod template里面的label</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">replicas:</span> <span class="number">3</span> <span class="comment">#维持3副本，可被修改</span></span><br><span class="line">	<span class="attr">selector:</span> <span class="comment">#选择器，也是自动从pod template里面获取</span></span><br><span class="line">		<span class="attr">matchLabels:</span> </span><br><span class="line">			<span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">		<span class="attr">matchExpressions:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">&#123;key:</span> <span class="string">tier,</span> <span class="attr">operator:</span> <span class="string">In,</span> <span class="attr">values:</span> <span class="string">[frontend]&#125;</span></span><br><span class="line">	<span class="attr">template:</span> <span class="comment">#pod template，作为后续创建所 有Pod的模板</span></span><br><span class="line">		<span class="attr">metadata:</span></span><br><span class="line">			<span class="attr">labels:</span></span><br><span class="line">				<span class="attr">app:</span> <span class="string">guestbook</span> <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">		<span class="attr">spec:</span></span><br><span class="line">			<span class="attr">containers:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">php-redis</span></span><br><span class="line">			  <span class="attr">image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v3</span> </span><br><span class="line">			  <span class="attr">resources:</span></span><br><span class="line">			    <span class="attr">requests:</span></span><br><span class="line">				  <span class="attr">cpu:</span> <span class="number">100</span><span class="string">m</span> <span class="comment">#资源限制</span></span><br><span class="line">				  <span class="attr">memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line">			  <span class="attr">env:</span></span><br><span class="line">        	  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GET_HOSTS_FROM</span></span><br><span class="line">          		<span class="attr">value:</span> <span class="string">dns</span></span><br><span class="line">          		<span class="comment"># If your cluster config does not include a dns service, then to</span></span><br><span class="line">          		<span class="comment"># instead access environment variables to find service host</span></span><br><span class="line">          		<span class="comment"># info, comment out the 'value: dns' line above, and uncomment the</span></span><br><span class="line">          		<span class="comment"># line below.</span></span><br><span class="line">          		<span class="comment"># value: env</span></span><br><span class="line">			  <span class="attr">ports:</span></span><br><span class="line">				<span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多信息参考:<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/</a></p>
<p>K8s容器资源限制可以参考这篇:<a href="https://my.oschina.net/HardySimpson/blog/1359276" target="_blank" rel="noopener">https://my.oschina.net/HardySimpson/blog/1359276</a></p>
</blockquote>
<h4 id="Deployment的行为和定义"><a href="#Deployment的行为和定义" class="headerlink" title="Deployment的行为和定义"></a>Deployment的行为和定义</h4><p>Deployment为Pod和Replica Set（下一代Replication Controller）提供声明式更新。</p>
<p>您只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会帮您将 Pod 和ReplicaSet 的实际状态改变到您的目标状态。您可以定义一个全新的 Deployment 来创建 ReplicaSet 或者删除已有的 Deployment 并创建一个新的来替换。</p>
<blockquote>
<p><strong>注意</strong>：您不该手动管理由 Deployment 创建的 ReplicaSet，否则您就篡越了 Deployment controller 的职责！下文罗列了 Deployment 对象中已经覆盖了所有的用例。如果未有覆盖您所有需要的用例，请直接在 Kubernetes 的代码库中提 issue。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#controllers/nginx-deployment.yaml  </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多信息:</p>
<p>Deployment 文档:<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></p>
<p>Deployment 简述:<a href="https://jimmysong.io/kubernetes-handbook/concepts/deployment.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/concepts/deployment.html</a></p>
</blockquote>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者: <a href="http://note.geekfan.top">Linus Lee</a>
            <p>原文链接: <a href="http://note.geekfan.top/2018/07/17/K8S-InfoCollection/">http://note.geekfan.top/2018/07/17/K8S-InfoCollection/</a>
            <p>发表日期: <a href="http://note.geekfan.top/2018/07/17/K8S-InfoCollection/">July 17th 2018, 12:11:44 pm</a>
            <p>版权声明: 本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2018/07/01/Scraping-Primer/" title= Scraping-Primer >
                    <div class="prevTitle">Scraping-Primer</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zMjU0Ni85MTA3>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!--PC和WAP自适应版-->

    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:708863861@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/mr-linus" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#kubernetes-架构"><span class="toc-number">1.</span> <span class="toc-text">kubernetes 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分层架构"><span class="toc-number">1.1.</span> <span class="toc-text">分层架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#架构设计优缺点"><span class="toc-number">1.2.</span> <span class="toc-text">架构设计优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s提供的抽象"><span class="toc-number">2.</span> <span class="toc-text">k8s提供的抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#kubernetes-中的对象"><span class="toc-number">2.0.1.</span> <span class="toc-text">kubernetes 中的对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象分类"><span class="toc-number">3.</span> <span class="toc-text">对象分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#业界各种安装方式对比"><span class="toc-number">4.</span> <span class="toc-text">业界各种安装方式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当pod创建时-k8s到底干了啥"><span class="toc-number">5.</span> <span class="toc-text">当pod创建时,k8s到底干了啥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubectl-常见命令"><span class="toc-number">6.</span> <span class="toc-text">kubectl 常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl上下文和配置"><span class="toc-number">6.1.</span> <span class="toc-text">kubectl上下文和配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl-创建对象"><span class="toc-number">6.2.</span> <span class="toc-text">kubectl 创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl显示和查找资源"><span class="toc-number">6.3.</span> <span class="toc-text">kubectl显示和查找资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl编辑资源"><span class="toc-number">6.4.</span> <span class="toc-text">kubectl编辑资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl-Scale-资源"><span class="toc-number">6.5.</span> <span class="toc-text">kubectl Scale 资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl-删除资源"><span class="toc-number">6.6.</span> <span class="toc-text">kubectl 删除资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl与运行中的-Pod-交互"><span class="toc-number">6.7.</span> <span class="toc-text">kubectl与运行中的 Pod 交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl与节点和集群交互"><span class="toc-number">6.8.</span> <span class="toc-text">kubectl与节点和集群交互</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s构建高可用集群"><span class="toc-number">7.</span> <span class="toc-text">k8s构建高可用集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s应用管理"><span class="toc-number">8.</span> <span class="toc-text">k8s应用管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pod详解"><span class="toc-number">8.1.</span> <span class="toc-text">pod详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pod的设计动机"><span class="toc-number">8.2.</span> <span class="toc-text">pod的设计动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pod的非持久性"><span class="toc-number">8.3.</span> <span class="toc-text">pod的非持久性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init容器"><span class="toc-number">8.4.</span> <span class="toc-text">init容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pod中容器镜像常见设置"><span class="toc-number">8.5.</span> <span class="toc-text">Pod中容器镜像常见设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pod-status-phase"><span class="toc-number">8.6.</span> <span class="toc-text">Pod.status.phase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器探针-注意不是Pod探针"><span class="toc-number">8.7.</span> <span class="toc-text">容器探针(注意不是Pod探针)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器重启策略"><span class="toc-number">8.8.</span> <span class="toc-text">容器重启策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#以五分钟为上限的指数退避延迟-10秒，20秒，40秒…-重新启动，并在成功执行十分钟后重置。"><span class="toc-number">8.8.1.</span> <span class="toc-text">以五分钟为上限的指数退避延迟(10秒，20秒，40秒… )重新启动，并在成功执行十分钟后重置。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pod状态与容器状态的关系"><span class="toc-number">8.9.</span> <span class="toc-text">pod状态与容器状态的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReplicaSet-副本集"><span class="toc-number">8.10.</span> <span class="toc-text">ReplicaSet: 副本集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deployment的行为和定义"><span class="toc-number">8.11.</span> <span class="toc-text">Deployment的行为和定义</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 10
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span><a class="archive-post-title" href= "/2018/07/17/K8S-InfoCollection/" >Kubernetes Information Collection</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2018/07/01/Scraping-Primer/" >Scraping-Primer</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span><a class="archive-post-title" href= "/2018/06/21/Linux-Primer/" >Linux-Primer</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2018/06/15/Docker-faq/" >Docker-FAQ</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span><a class="archive-post-title" href= "/2017/12/12/Binary-tree/" >Binary tree  of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span><a class="archive-post-title" href= "/2017/12/12/Graph-traversal/" >Graph traversal  of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2017/10/28/search/" >Search of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2017/10/24/struct/" >Concept of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/23</span><a class="archive-post-title" href= "/2017/10/23/sort/" >Sort of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/20</span><a class="archive-post-title" href= "/2017/10/20/Docker-Primer/" >Docker-Primer</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Data Structure"><span class="iconfont-archer">&#xe606;</span>Data Structure</span>
    
        <span class="sidebar-tag-name" data-tags="scraping"><span class="iconfont-archer">&#xe606;</span>scraping</span>
    
        <span class="sidebar-tag-name" data-tags="docker"><span class="iconfont-archer">&#xe606;</span>docker</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Linus Lee"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>
</html>


