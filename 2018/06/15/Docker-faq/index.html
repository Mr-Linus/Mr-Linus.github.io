<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->




<!-- keywords -->




<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Linus Lee">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Linus Lee">
    
    <meta name="keywords" content="Funky's NoteBook,Linus Lee">
    
    <meta name="description" content="It's Funky's NoteBook">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Docker-FAQ · Funky&#39;s NoteBook</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/gun.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
</head>

    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Funky&#39;s NoteBook</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Docker-FAQ</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Funky's NoteBook</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Docker-FAQ
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "docker">docker</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">39,975</span>阅读时长: <span class="post-count reading-time">158 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/06/15</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本FAQ基于<a href="https://github.com/twang2218" target="_blank" rel="noopener">twang2218</a>大佬Blog的100问制作，用于解决学习Docker出现的常见问题。</p>
</blockquote>
<h1 id="Docker-引擎相关问题-67"><a href="#Docker-引擎相关问题-67" class="headerlink" title="Docker 引擎相关问题 (67)"></a>Docker 引擎相关问题 <code>(67)</code></h1><h2 id="概念问题-5"><a href="#概念问题-5" class="headerlink" title="概念问题 (5)"></a>概念问题 <code>(5)</code></h2><h3 id="宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么-Docker-和虚拟机还有什么差别？"><a href="#宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么-Docker-和虚拟机还有什么差别？" class="headerlink" title="宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么 Docker 和虚拟机还有什么差别？"></a>宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么 Docker 和虚拟机还有什么差别？</h3><p>要把 Windows 和 Linux 分清楚，更要把内核(<code>kernel</code>)和用户空间(<code>userland</code>)分清楚。</p>
<p>容器内的进程是直接运行于<code>宿主内核</code>的，这点和宿主进程一致，只是容器的 <code>userland</code> 不同，容器的 <code>userland</code> 由容器镜像提供，也就是说镜像提供了 <code>rootfs</code>。</p>
<p>假设宿主是 <code>Ubuntu</code>，容器是 <code>CentOS</code>。<code>CentOS</code> 容器中的进程会直接向 <code>Ubuntu</code> 宿主内核发送 <code>syscall</code>，而不会直接或间接的使用任何 <code>Ubuntu</code> 的 <code>userland</code> 的库。</p>
<p>这点和虚拟机有本质的不同，虚拟机是虚拟环境，在现有系统上虚拟一套物理设备，然后在虚拟环境内运行一个虚拟环境的操作系统内核，在内核之上再跑完整系统，并在里面调用进程。</p>
<p>还以上面的例子去考虑，虚拟机中，<code>CentOS</code> 的进程发送 <code>syscall</code> 内核调用，该请求会被虚拟机内的 <code>CentOS</code> 的内核接到，然后 <code>CentOS</code> 内核访问虚拟硬件时，由虚拟机的服务软件截获，并使用宿主系统，也就是 <code>Ubuntu</code> 的内核及 <code>userland</code> 的库去执行。</p>
<p>而且，Linux 和 Windows 在这点上非常不同。Linux 的进程是直接发 <code>syscall</code> 的，而 Windows 则把 <code>syscall</code> 隐藏于一层层的 <code>DLL</code> 服务之后，因此 Windows 的任何一个进程如果要执行，不仅仅需要 Windows 内核，还需要一群服务来支撑，所以如果 Windows 要实现类似的机制，容器内将不会像 Linux 这样轻量级，而是非常臃肿。看一下微软移植的 Docker 就非常清楚了。</p>
<p>所以不要把 Docker 和虚拟机弄混，Docker 容器只是一个进程而已，只不过利用镜像提供的 <code>rootfs</code> 提供了调用所需的 <code>userland</code> 库支持，使得进程可以在受控环境下运行而已，它并没有虚拟出一个机器出来。</p>
<p>参考：</p>
<ul>
<li>(英文): <a href="https://www.docker.com/what-docker" target="_blank" rel="noopener">https://www.docker.com/what-docker</a></li>
<li>(中文): <a href="https://www.docker-cn.com/what-docker" target="_blank" rel="noopener">https://www.docker-cn.com/what-docker</a></li>
</ul>
<h3 id="Docker-资料好少啊？网上的命令怎么不能用？"><a href="#Docker-资料好少啊？网上的命令怎么不能用？" class="headerlink" title="Docker 资料好少啊？网上的命令怎么不能用？"></a>Docker 资料好少啊？网上的命令怎么不能用？</h3><p>首先，做技术工作，请珍惜生命，远离百度；<br>其次，不翻墙、不用Google、不看英文资料，那请转行，没法混。</p>
<p>然后是回答问题，Docker的资料其实很丰富，特别是官方文档讲解非常详细。</p>
<ul>
<li>(英文): <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li>
<li>(中文): <a href="https://docs.docker-cn.com" target="_blank" rel="noopener">https://docs.docker-cn.com</a> (文档有坑，不少代码格式有错)</li>
<li>(老麦的翻译): <a href="https://www.gitbook.com/read/book/octowhale/docker-doc-cn" target="_blank" rel="noopener">https://www.gitbook.com/read/book/octowhale/docker-doc-cn</a></li>
</ul>
<p>另外，Docker有丰富的镜像库，Docker Hub，特别是官方(Official)的镜像可以直接在生产环境中使用，制作比较精良。</p>
<p><a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">https://hub.docker.com/explore/</a></p>
<p>所有的官方镜像都有 <code>Dockerfile</code>，以及在github上有全部生成镜像的配套文件，遵循了<code>Dockerfile</code>的最佳实践，这些也是很好地学习资料。</p>
<p>另外，在 YouTube 的 Docker 官方频道下有几百个视频讲座，从初级到高级用户都能从里面学到很多东西。</p>
<p><a href="https://www.youtube.com/user/dockerrun" target="_blank" rel="noopener">https://www.youtube.com/user/dockerrun</a></p>
<h3 id="如何选择-Docker-书籍？"><a href="#如何选择-Docker-书籍？" class="headerlink" title="如何选择 Docker 书籍？"></a>如何选择 Docker 书籍？</h3><p>Docker 属于敏捷开发的产品，并且处于高速创新阶段，每年都会有很多版本发布。由于这种快速开发的特性，Docker 一般只保留几个版本内的向后兼容性，再之后就会废弃。因此选择图书的时候，<strong>不应该选择比当前版本低超过2-3个版本的书籍</strong>。换句话说，市面上大部分书籍，特别是中文书籍、网文，很可能都过时了。</p>
<p>Docker 版本号在 2017 年以前，使用 <code>&lt;大版本号&gt;.&lt;小版本号&gt;.&lt;补丁版本号&gt;</code> 的结构，那时 Docker 基本会保持 <strong>3 个小版本号</strong> 之内的兼容性（如果一个特性宣布废弃，一般会在 3 个版本后才彻底移除）。</p>
<p>而从 2017 年春以后，Docker 使用了新版本号结构：<code>&lt;年&gt;.&lt;月&gt;.&lt;补丁版本号&gt;</code>，并且将每月发布一个<strong>前沿(Edge)版本</strong>，每季度发布一个<strong>稳定(Stable)版本</strong>。因此选择书籍也应该以介绍 <strong>2-3个季度以内版本</strong> 的书籍为准。那些介绍一年以前发布的 Docker 版本的书籍不应该再看了。</p>
<p>因此在购买 Docker 图书的时候，应该遵循这样的原则：<strong>观察一下当前的 Docker 版本号，选择不要晚于 3 个版本的 Docker 书籍。</strong> 比如写这段文字时为 <code>17.06</code>，那么就不要购买介绍 Docker <code>1.12</code> 及其以前版本的书籍了，否则看到的很多东西可能将会因过时而无法使用，或者已经不必如此繁琐有更简单的方式去实现了。</p>
<p>所以，对于 Docker 学习而言，<strong>最好的书籍是官网文档</strong>，官网的文档很丰富。</p>
<ul>
<li>新手教程：<ul>
<li>（英文）：<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">https://docs.docker.com/get-started/</a></li>
<li>（中文）：<a href="https://docs.docker-cn.com/get-started/" target="_blank" rel="noopener">https://docs.docker-cn.com/get-started/</a></li>
<li>（老麦的翻译）：<a href="https://docs-cn.docker.octowhale.com/get_started/001.Orientation.html" target="_blank" rel="noopener">https://docs-cn.docker.octowhale.com/get_started/001.Orientation.html</a></li>
</ul>
</li>
<li>Docker 课程：<a href="http://training.play-with-docker.com/" target="_blank" rel="noopener">http://training.play-with-docker.com/</a><ul>
<li>运维人员课程：<a href="http://training.play-with-docker.com/ops-landing/" target="_blank" rel="noopener">http://training.play-with-docker.com/ops-landing/</a></li>
<li>开发人员课程：<a href="http://training.play-with-docker.com/dev-landing/" target="_blank" rel="noopener">http://training.play-with-docker.com/dev-landing/</a></li>
</ul>
</li>
<li>大量的例子：<ul>
<li>（英文）：<a href="https://docs.docker.com/samples/" target="_blank" rel="noopener">https://docs.docker.com/samples/</a></li>
<li>（中文）：<a href="https://docs.docker-cn.com/samples/" target="_blank" rel="noopener">https://docs.docker-cn.com/samples/</a></li>
</ul>
</li>
<li>用户文档：<ul>
<li>（英文）：<a href="https://docs.docker.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/</a></li>
<li>（中文）：<a href="https://docs.docker-cn.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker-cn.com/engine/userguide/</a></li>
<li>镜像：<ul>
<li>(英文）：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></li>
<li>(老麦的翻译)：<a href="https://docs-cn.docker.octowhale.com/engine/userguide/eng-image/dockerfile_best-practices.html" target="_blank" rel="noopener">https://docs-cn.docker.octowhale.com/engine/userguide/eng-image/dockerfile_best-practices.html</a></li>
</ul>
</li>
<li>存储：<a href="https://docs.docker.com/engine/userguide/storagedriver/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/storagedriver/</a></li>
<li>网络：<a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/</a></li>
</ul>
</li>
<li>管理文档：<a href="https://docs.docker.com/engine/admin/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/</a><ul>
<li>存储：<a href="https://docs.docker.com/engine/admin/volumes/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/volumes/</a></li>
</ul>
</li>
<li>安全：<a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/security/</a></li>
<li>集群：<a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/</a></li>
</ul>
<blockquote>
<p>部分文档有对应官方的中文翻译，可以从 <a href="https://docs.docker-cn.com" target="_blank" rel="noopener">https://docs.docker-cn.com</a> 查看。但是一定要<strong>注意代码格式</strong>，中文文档中<strong>许多格式是错误的</strong>，应该对比英文文档中的代码来看。</p>
</blockquote>
<p>对于新手而言，应该先从新手教程开始，内容还是很简单易懂的，很容易上手。然后，可以把用户文档好好看一遍，里面把很多 Docker 的基础概念讲的很清楚。概念清晰后，可以去把官网给出的例子好好的学习一下，这些例子都是具体怎么应用 Docker 的，有文字说明以及具体的考虑，很适合学习。</p>
<h3 id="总说看官方文档，可是-Docker-官网文档经常被墙，看不了怎么办？"><a href="#总说看官方文档，可是-Docker-官网文档经常被墙，看不了怎么办？" class="headerlink" title="总说看官方文档，可是 Docker 官网文档经常被墙，看不了怎么办？"></a>总说看官方文档，可是 Docker 官网文档经常被墙，看不了怎么办？</h3><p>首先<em>感谢</em>伟大的墙及其先祖。</p>
<p>然后，我们可以本地运行 Docker 官方文档的网站，以 docker 的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:4000 docs/docker.github.io</span><br></pre></td></tr></table></figure>
<p>这样访问 Docker 宿主的 <code>80</code> 端口，如 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a>，就会看到官网文档了。</p>
<p>对于那些访问不了我的问答录的童鞋，同样可以用这样的方式来本地运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 twang2218/blog.lab99.org</span><br></pre></td></tr></table></figure>
<p>然后就可以访问本地 <code>80</code> 端口看到最新的问答录了。</p>
<h3 id="Docker-1-8-以后版本都有什么改进么？"><a href="#Docker-1-8-以后版本都有什么改进么？" class="headerlink" title="Docker 1.8 以后版本都有什么改进么？"></a>Docker 1.8 以后版本都有什么改进么？</h3><p>每个版本发布时，官方博客 <a href="https://blog.docker.com" target="_blank" rel="noopener">https://blog.docker.com</a> 都会有专门文章描述这个版本最主要的改进。</p>
<ul>
<li><code>1.9</code>: <a href="https://blog.docker.com/2015/11/docker-1-9-production-ready-swarm-multi-host-networking/" target="_blank" rel="noopener">https://blog.docker.com/2015/11/docker-1-9-production-ready-swarm-multi-host-networking/</a></li>
<li><code>1.10</code>: <a href="https://blog.docker.com/2016/02/docker-1-10/" target="_blank" rel="noopener">https://blog.docker.com/2016/02/docker-1-10/</a></li>
<li><code>1.11</code>: <a href="https://blog.docker.com/2016/04/docker-engine-1-11-runc/" target="_blank" rel="noopener">https://blog.docker.com/2016/04/docker-engine-1-11-runc/</a></li>
<li><code>1.12</code>: <a href="https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/" target="_blank" rel="noopener">https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/</a></li>
</ul>
<p>另外，可以看一下孙宏亮维护的<a href="https://github.com/allencloud/docker-changelog-chinese" target="_blank" rel="noopener">《Docker 中文 Changelog》</a>：</p>
<ul>
<li><code>1.10</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.10.0-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.10.0-changelog.md</a></li>
<li><code>1.11</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.0-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.0-changelog.md</a></li>
<li><code>1.11.1</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.1-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.11.1-changelog.md</a></li>
<li><code>1.12</code>: <a href="https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.12.0-changelog.md" target="_blank" rel="noopener">https://github.com/allencloud/docker-changelog-chinese/blob/master/docker-1.12.0-changelog.md</a></li>
</ul>
<p>关于 <code>Docker 1.13</code> 可以看一下我写的<a href="/post/docker-2016-11-14-what-is-new-in-docker-1-13.html">《Docker 1.13 新增功能》</a>。</p>
<h2 id="安装、配置问题-8"><a href="#安装、配置问题-8" class="headerlink" title="安装、配置问题 (8)"></a>安装、配置问题 <code>(8)</code></h2><h3 id="Docker-怎么这么多软件，我该装哪个？"><a href="#Docker-怎么这么多软件，我该装哪个？" class="headerlink" title="Docker 怎么这么多软件，我该装哪个？"></a>Docker 怎么这么多软件，我该装哪个？</h3><p>好吧，我决定要装 Docker 了，于是来打开 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker 安装文档</a> (<a href="https://docs.docker-cn.com/engine/installation/" target="_blank" rel="noopener">中文</a> 看看怎么装吧……呃，然后就傻了，怎么这么多种选择啊？！</p>
<p>首先，Docker 有好几个<em>版本</em>，社区版（Community Edition）、企业基础版（Enterprise Edition Basic）、企业标准版（Enterprise Edition Standard）、企业高级版（Enterprise Edition Advanced）。对于我们一般学习使用而言，<em>使用社区版就已足够</em>，所以记住<strong>CE</strong>就可以了。</p>
<p>其次，我们会看到一堆<em>平台</em>特定的版本，Docker for Mac、Docker for Windows、Docker Toolbox、Docker for Azure、Docker for AWS 等等，还有一堆不同 Linux 的发行版。那我们应该用哪个？其实不难选择，这都是平台特定的东西嘛，选择自己平台就完了😂：</p>
<ul>
<li>macOS 就选择 <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker for Mac</a>；<ul>
<li>阿里云（未及时更新）：<a href="https://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/</a></li>
</ul>
</li>
<li>Linux 就选择自己平台的 Docker 源：<ul>
<li>Ubuntu: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/</a></li>
<li>Debian: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/debian/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/debian/</a></li>
<li>CentOS: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/centos/</a></li>
<li>Fedora: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/fedora/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/docker-ce/fedora/</a></li>
</ul>
</li>
<li>Windows 要麻烦些：<ul>
<li>如果是 <em>Windows 10</em> <em>专业版、企业版、教育版</em>，并且版本在 <code>10586</code> 以后，并且<em>不打算</em>在 Docker 运行<em>同时</em>再运行其它虚拟机的情况下，可以装 <a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener">Docker for Windows</a>。<ul>
<li>阿里云（未及时更新）：<a href="https://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/stable/" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/stable/</a></li>
</ul>
</li>
<li><strong>其它情况</strong>都装 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a><ul>
<li>阿里云：<a href="https://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></li>
</ul>
</li>
</ul>
</li>
<li>如果是特定云服务平台，可以考虑特定服务平台的版本（当然，这不是必须）：<ul>
<li>AWS：<a href="https://docs.docker.com/docker-for-aws/" target="_blank" rel="noopener">Docker for AWS</a></li>
<li>Azure：<a href="https://docs.docker.com/docker-for-azure/" target="_blank" rel="noopener">Docker for Azure</a></li>
</ul>
</li>
</ul>
<p>最后是<em>发布通道</em>，从今年初开始，也就是从 <code>1.13</code> 以后，Docker 使用了新的版本号规则，将采用类似 Ubuntu 那种 <code>&lt;年&gt;.&lt;月&gt;</code> 的形式，比如 <code>17.03</code>, <code>17.06</code> 等。并且，将发布通道分为<strong>前沿版本(Edge)</strong>和<strong>稳定版本(Stable)</strong>。前沿通道将基本每个月发布一个版本，而稳定通道将基本每3个月发布一个版本。这样 Docker 的发布将有规律可寻。对于喜欢尝鲜的可以选择前沿版本，对于需要稳定的，可以选择稳定版本。</p>
<blockquote>
<p>这里面需要注意的是，在参考<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方安装文档</a> (<a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">中文</a>)配置 Linux 源的时候，如果是国内服务器，要将其中的 <code>https://download.docker.com/linux/</code> 替换为 <code>https://mirrors.aliyun.com/docker-ce/linux/</code>。</p>
</blockquote>
<p>比如，文档如果要求执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure>
<p>那么就<strong>替换</strong>为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure>
<p>这样安装 Docker 就会使用阿里云的软件源，而不需要翻墙了。（<em>注：这不是加速器，不要搞错了，加速器依旧需要配！</em>）</p>
<h3 id="是直接用-yum-apt-get-安装-Docker-吗？"><a href="#是直接用-yum-apt-get-安装-Docker-吗？" class="headerlink" title="是直接用 yum / apt-get 安装 Docker 吗？"></a>是直接用 <code>yum</code> / <code>apt-get</code> 安装 Docker 吗？</h3><p>很多人问到 <code>docker</code>, <code>docker.io</code>, <code>docker-engine</code> 甚至 <code>lxc-docker</code> 都有什么区别？</p>
<p>其中，RHEL/CentOS 软件源中的 Docker 包名为 <code>docker</code>；Ubuntu 软件源中的 Docker 包名为 <code>docker.io</code>；而很古老的 Docker 源中 Docker 也曾叫做 <code>lxc-docker</code>。这些都是<code>非常老旧</code>的 Docker 版本，并且基本不会更新到最新的版本，而对于使用 Docker 而言，使用最新版本非常重要。另外，17.04 以后，包名从 <code>docker-engine</code> 改为 <code>docker-ce</code>，因此从现在开始安装，应该都使用 <code>docker-ce</code> 这个包。</p>
<blockquote>
<p>不要使用操作系统提供的软件源中的 Docker 包，去使用 Docker 官方源的包。</p>
</blockquote>
<p>正确的安装方法有两种：</p>
<ul>
<li>一种是参考官方安装文档去配置 <a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">apt</a> 或者 <a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">yum</a> 的源；</li>
<li>另一种则是使用官方提供的安装脚本快速安装。</li>
</ul>
<p>官方文档对配置源的方法已经有很详细的讲解，这里就不赘述，需要的直接去看<a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方文档</a>。这里只介绍使用官方的脚本快速安装：</p>
<h4 id="17-04-及以后的版本"><a href="#17-04-及以后的版本" class="headerlink" title="17.04 及以后的版本"></a>17.04 及以后的版本</h4><p>从 <code>17.04</code> 以后，可以用下面的命令安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CHANNEL=stable</span><br><span class="line">curl -fsSL https://get.docker.com/ | sh -s -- --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>这里使用的是官方脚本安装，通过环境变量指定安装通道为 <code>stable</code>，（如果喜欢尝鲜可以改为 <code>edge</code>, <code>test</code>），并且指定使用阿里云的源(apt/yum)来安装 Docker CE 版本。</p>
<h4 id="17-03-及以前的版本"><a href="#17-03-及以前的版本" class="headerlink" title="17.03 及以前的版本"></a>17.03 及以前的版本</h4><p>早期的版本可以使用阿里云或者 DaoCloud 老的脚本安装：</p>
<p>使用<code>阿里云</code>的安装脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure>
<p>使用<code>DaoCloud</code>的Docker安装脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>
<h3 id="不是都已经发布-Docker-17-07-了么？我怎么升级到最新还是-17-05-呀？"><a href="#不是都已经发布-Docker-17-07-了么？我怎么升级到最新还是-17-05-呀？" class="headerlink" title="不是都已经发布 Docker 17.07 了么？我怎么升级到最新还是 17.05 呀？"></a>不是都已经发布 Docker 17.07 了么？我怎么升级到最新还是 17.05 呀？</h3><p>从 <strong>17.04</strong> 以后，Docker 的源的结构以及包名都进行了调整，因此如果你你还使用的是旧的源，那么需要参照<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方文档</a>，更新源的地址为新的源。前面的问答中已经给出了链接和替代用的阿里云源镜像地址，参照修改（apt/yum）源。</p>
<p>修改好后，卸载旧的 <code>docker-engine</code>，安装新的 <code>docker-ce</code> 即可。</p>
<h3 id="docker-pull-好慢啊怎么办？"><a href="#docker-pull-好慢啊怎么办？" class="headerlink" title="docker pull 好慢啊怎么办？"></a><code>docker pull</code> 好慢啊怎么办？</h3><p>首先，要“感谢”伟大的墙及其亲属。</p>
<p>然后，我们可以使用 Docker 镜像加速器来解决这个问题，加速器就是镜像、代理的概念。国内有不少机构提供了免费的加速器以方便大家使用，这里列出一些常用的加速器服务：</p>
<ul>
<li><a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">Docker 官方的中国镜像加速器</a>：从2017年6月9日起，<strong>Docker 官方提供了在中国的加速器</strong>，以解决墙的问题。不用注册，直接使用加速器地址：<code>https://registry.docker-cn.com</code> 即可。</li>
<li><a href="http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker" target="_blank" rel="noopener">中国科技大学的镜像加速器</a>：中科大的加速器不用注册，直接使用地址 <code>https://docker.mirrors.ustc.edu.cn/</code> 配置加速器即可。进一步的信息可以访问：<a href="http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker</a></li>
<li><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>：注册阿里云开发账户(<em>免费的</em>)后，访问这个链接就可以看到加速器地址： <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/accelerator</a></li>
<li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a>：<a href="http://account.daocloud.io/signup" target="_blank" rel="noopener">注册 <code>DaoCloud</code> 账户</a>(<em>支持微信登录</em>)，然后访问： <a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></li>
</ul>
<blockquote>
<p>注意：<strong>不要使用</strong>加速器网站所给的配置脚本，容易导致错误。我们只需获取其提供的<strong>加速器地址</strong>即可。</p>
</blockquote>
<h4 id="Ubuntu-14-04-配置加速器（或其它使用-Upstart-的系统）"><a href="#Ubuntu-14-04-配置加速器（或其它使用-Upstart-的系统）" class="headerlink" title="Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）"></a>Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）</h4><p><code>Ubuntu 14.04</code> 是使用 <code>upstart</code> 进行系统初始化的，对于这类系统，可以用通过编辑配置文件的方法来配置加速器。</p>
<p>如果是 <code>Ubuntu 14.04</code>，那么编辑 <code>/etc/default/docker</code>，在里面寻找 <code>DOCKER_OPTS</code> 环境变量设置的这一行，在其后添加 <code>-–registry-mirror=&lt;加速器地址&gt;</code>。如果发现该行已被注释，或者不存在该行，那么新添一行即可。</p>
<p>比如，在使用官方源安装了 <code>docker-engine</code> 后，会建立一个默认的 <code>/etc/default/docker</code>，其中相关 <code>DOCKER_OPTS</code> 的行是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use DOCKER_OPTS to modify the daemon startup options.</span></span><br><span class="line"><span class="comment">#DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"</span></span><br></pre></td></tr></table></figure>
<p>假设我们的加速器地址为 <code>https://registry.docker-cn.com</code>，我们添加一行配置，将其改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use DOCKER_OPTS to modify the daemon startup options.</span></span><br><span class="line"><span class="comment">#DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"</span></span><br><span class="line">DOCKER_OPTS=<span class="string">"--registry-mirror=https://registry.docker-cn.com"</span></span><br></pre></td></tr></table></figure>
<p>保存文件后，重启 Docker 引擎：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br><span class="line">docker stop/waiting</span><br><span class="line">docker start/running, process 3620</span><br></pre></td></tr></table></figure>
<p>重启成功后，确认一下配置是否已经生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ps -ef | grep dockerd</span><br><span class="line">root      3620     1  0 04:26 ?        00:00:00 /usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com --raw-logs</span><br></pre></td></tr></table></figure>
<p>如果配置成功，生效后这里就会看到自己所配置的加速器的内容。</p>
<h4 id="Ubuntu-16-04-或-CentOS-7-配置加速器（或其它使用-Systemd-的系统）"><a href="#Ubuntu-16-04-或-CentOS-7-配置加速器（或其它使用-Systemd-的系统）" class="headerlink" title="Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）"></a>Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）</h4><p><code>Ubuntu 16.04</code> 和 <code>CentOS 7</code> 这类系统都已经开始使用 <code>systemd</code> 进行系统初始化管理了，对于使用 <code>systemd</code> 的系统，应该通过编辑服务配置文件 <code>docker.service</code> 来进行加速器的配置。</p>
<p>在启用服务后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p>可以直接编辑 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code> 文件来进行配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/systemd/system/multi-user.target.wants/docker.service</span><br></pre></td></tr></table></figure>
<p>在文件中找到 <code>ExecStart=</code> 这一行，并且在其行尾添加上所需的配置。假设我们的加速器地址为 <code>https://registry.docker-cn.com</code>，那么可以这样配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ExecStart</span>=/usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注: Docker 1.12 之前的版本，<code>dockerd</code> 应该换为 <code>docker daemon</code>，更早的版本则是 <code>docker -d</code>。不过还在用那些版本的童鞋，升级吧……😓</p>
</blockquote>
<p>保存退出后，重新加载配置并启动服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>确认一下配置是否已经生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ps -ef | grep dockerd</span><br></pre></td></tr></table></figure>
<p>如果配置成功，生效后就会在这里看到自己所配置的加速器。</p>
<p>在 <code>1.13</code> 版本以后，可以直接 <code>docker info</code> 查看，如果配置成功，加速器 <code>Registry Mirror</code> 会在最下面列出来。</p>
<p>如果重启后发现无法启动 <code>docker</code> 服务，检查一下服务日志，看看是不是之前执行过那些加速器网站的脚本，如果有做过类似的事情，检查一下是不是被建立了 <code>/etc/docker/daemon.json</code> 以配置加速器，如果是的话，删掉这个文件，然后在重启服务。</p>
<p>使用配置文件是件好事，比如修改配置不必重启服务，只需发送 <code>SIGHUP</code> 信号即可。但需要注意，目前在 <code>dockerd</code> 中使用配置文件时，无法输出当前生效配置，并且当 <code>dockerd</code> 的参数和 <code>daemon.json</code> 文件中的配置有所重复时，并不是一个优先级覆盖另一个，而是会直接导致引擎启动失败。很多人发现配了加速器后 Docker 启动不起来了就是这个原因。解决办法很简单，去掉重复项。不过在这些问题解决前，建议使用修改 <code>docker.service</code> 这类做法来实现配置，而不是使用配置文件 <code>daemon.json</code>。方便 <code>ps -ef | grep dockerd</code> 一眼看到实际配置情况。</p>
<h3 id="怎么修改了-docker-服务配置后不起作用？"><a href="#怎么修改了-docker-服务配置后不起作用？" class="headerlink" title="怎么修改了 docker 服务配置后不起作用？"></a>怎么修改了 docker 服务配置后不起作用？</h3><p>改动真的生效了么？在宿主上运行一下 <code>ps -ef | grep dockerd</code> 看看，自己做的那些配置有么？没有的话就说明没有生效，那么就要检查原因了。</p>
<p>首先，改完配置重启服务了么？虽然这个问题看着很小白，但是确实很多人犯了这个小白的错误。</p>
<ul>
<li><code>Ubuntu 14.04</code>: <code>sudo service docker restart</code></li>
<li><code>Ubuntu 16.04</code>, <code>CentOS 7</code>: <code>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</code></li>
</ul>
<p>另外，你改对了配置文件了么？</p>
<p>不少人懒得看英文文档，<em>百度</em>个文章就照着配，既不管百度得到的文章所讲的系统，也没注意版本，而且中文文章往往自身表达描述不清楚，很多想当然的东西，结果无数坑。这么百度的人，很有可能压根就改错了文件。</p>
<blockquote>
<p>珍爱生命，远离百度。</p>
</blockquote>
<p>最近两年处于 <code>upstart</code> 到 <code>systemd</code> 的过渡期，所以配置服务的方式<strong>对于不同的系统版本是不一样的</strong>，要看看自己使用的是什么操作系统，以及什么版本。</p>
<p>对于 <code>upstart</code> 的系统（<code>Ubuntu 14.10</code>或以前的版本，<code>Debian 7</code>或以前的版本），配置文件可能在 <code>/etc/default/docker</code>，其配置方式基本是配置 <code>DOCKER_*</code> 的环境变量。</p>
<p>而对于 <code>systemd</code> 的系统(<code>Ubuntu 15.04</code>及以后的版本，<code>Debian 8</code>及以后的版本，<code>CentOS 7</code>/<code>RHEL 7</code>及以后的版本)，配置文件则在 <code>systemd</code> 的配置目录下。</p>
<p>首先应该 <code>enable</code> 该服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p>然后修改配置文件 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code> （只要服务 <code>enable</code> 了，那么不管什么系统，应该都会在这个位置看到配置文件）</p>
<blockquote>
<p>要注意 <code>upstart</code> 的服务配置文件和 <code>systemd</code> 的配置文件的格式是<strong>不同的</strong>，不要拿着 <code>upstart</code> 的配置行直接复制粘贴到 <code>systemd</code> 的配置文件里，两码事儿，请先学习基础知识。</p>
</blockquote>
<p>参考官网文档：<br><a href="https://docs.docker.com/engine/admin/configuring/#ubuntu" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/configuring/#ubuntu</a><br><a href="https://docs.docker.com/engine/admin/systemd/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/systemd/</a></p>
<h3 id="如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？"><a href="#如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？" class="headerlink" title="如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？"></a>如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？</h3><p>在 <code>1.12</code> 以前的版本确实如此，但是从 <code>1.12</code> 开始，Docker 引擎加入了 <code>--live-restore</code> 参数，使用该参数可以避免引擎升级、重启导致容器停止服务的情况。</p>
<p>默认情况该功能不会被启动，如需启动，需要配置 <code>docker</code> 服务配置文件。比如 <code>Ubuntu 16.04</code> 这类 <code>systemd</code> 的系统，可以修改 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code> 文件，在 <code>ExecStart=</code> 后面配置上 <code>--live-restore</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd \</span><br><span class="line">    --registry-mirror=https://registry.docker-cn.com \</span><br><span class="line">    --live-restore</span><br></pre></td></tr></table></figure>
<p>上面的格式中使用了行尾 <code>\</code> 的换行形式，这点和 <code>bash</code> 脚本一样，<code>systemd</code> 支持这种换行形式，如对此不了解可以先去学习 <code>bash</code> 程序设计。</p>
<p>需要注意的是，<code>--live-restore</code> 和 <code>Swarm Mode</code> 不兼容，所以在集群环境中不要使用。实际上集群环境也不用担心某个服务器重启的问题，因为其上的服务都会被调度到别的节点上，因此服务并不会被中断。</p>
<p>参考文档：</p>
<ul>
<li><a href="https://docs.docker.com/engine/admin/live-restore/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/live-restore/</a></li>
</ul>
<h3 id="为什么执行-docker-命令会报-permission-denied-没权限的错误啊？"><a href="#为什么执行-docker-命令会报-permission-denied-没权限的错误啊？" class="headerlink" title="为什么执行 docker 命令会报 permission denied 没权限的错误啊？"></a>为什么执行 docker 命令会报 <code>permission denied</code> 没权限的错误啊？</h3><p>在 Linux 环境下，一些新装了 docker 的用户，特别是使用了 <code>sudo</code> 命令安装好了 Docker 后，发现当前用户一执行 <code>docker</code> 命令，就会报没权限的错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dial unix /var/run/docker.sock: permission denied</span><br></pre></td></tr></table></figure>
<p>一些来自于 Windows 世界的人，就会蹦出来说，用 <code>root</code> 呀……😓。而另一些有基本常识、知道不应该使用 <code>root</code> 人可能会说，那就用 <code>sudo docker</code> 吧。这两者都是不对的，或者说不合适的。</p>
<p>说使用 <code>root</code> 的人，应该回去好好学习一下 Linux 权限常识。一般 <strong>不应该直接使用 <code>root</code> 用户</strong>，直接使用 <code>root</code> 用户不仅仅是严重的违反了安全规范，而且也极容易造成操作事故。这不是 Windows 世界，Linux/Unix 世界是有严格的权限要求的，只应该<strong>使用最小的权限做事情</strong>。如果还不熟悉 Linux 权限机制，那就去学习一下，不要把 Windows 的坏毛病带过来。</p>
<p>说使用 <code>sudo docker</code> 的人，思路是对的，因为理解了平时操作应该使用普通用户，只有在需要的时候，才 <code>sudo</code> 提升权限进行操作。但是问题就在这个<strong>需要</strong>二字上，事实上，<strong>不需要 <code>root</code> 权限就可以执行 <code>docker</code> 命令</strong>。</p>
<p>其实如果看过<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">官方安装文档</a>的话都会知道，只需要将操作 <code>docker</code> 的用户，加入 <code>docker</code> 组，那么该用户既拥有了操作 <code>docker</code> 的权限。</p>
<p>因此，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<p>就可以把当前用户加入 <code>docker</code> 组，<strong>退出、重新登录系统后</strong>，执行 <code>docker info</code> 看一下，就会发现可以不用 <code>sudo</code> 直接执行 <code>docker</code> 命令了。</p>
<p>如果需要添加别的用户，将其中的 <code>$USER</code> 换成对应的用户名即可。</p>
<p>将用户添加到 <code>docker</code> 组，可以避免 <code>root</code> 权限误操作的问题，但是由于 <code>dockerd</code> 引擎是运行在 <code>root</code> 用户下的，而 <code>docker</code> 组成员有权限指挥 <code>dockerd</code> 引擎来做很多事情，因此，该用户实际上是拥有了 <code>root</code> 的权限的。因此不要误解了将当前用户加入 <code>docker</code> 组的初衷，这和赋予用户 <code>sudo</code> 权力是一样的，可不是说这个用户就没有 <code>root</code> 权限了。这样做，只是不再需要使用 <code>sudo</code> 了，也降低了使用 <code>sudo</code> 时误操作的可能。</p>
<p>此外，这里说的权限问题，全是指使用 <code>docker</code> 命令操作<strong>本机</strong> <code>dockerd</code> 引擎，也就是通过 <code>/var/run/docker.sock</code> 来操作 <code>dockerd</code> 引擎的事情，只有这种有之前说的权限类的问题。</p>
<p>而 <code>docker</code> 命令还可以操作<strong>远程</strong> <code>dockerd</code> 的引擎，也就是 <code>-H</code> 参数，或者 <code>DOCKER_HOST</code> 环境变量所指定的 Docker 主机。这种情况通讯走的是网络、HTTP，不会有权限问题。所以，如果不打算操作本机的 <code>dockerd</code> 引擎，则不需要将用户加入 <code>docker</code> 组，也是可以操作远程服务器的。</p>
<h3 id="服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？"><a href="#服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？" class="headerlink" title="服务器上线后，怎么发现总有个 xmrig 的容器在跑，删了还出来，这是什么鬼？"></a>服务器上线后，怎么发现总有个 <code>xmrig</code> 的容器在跑，删了还出来，这是什么鬼？</h3><blockquote>
<p><strong>警告！！</strong>你的服务器已经<strong>被入侵了</strong>！！</p>
</blockquote>
<p>有些人服务器上线后，发现突然多了一些莫名奇妙的容器在跑。比如下面这个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">IMAGE           COMMAND                  CREATED      STATUS                      PORTS    NAMES</span><br><span class="line">linuxrun/cpu2   <span class="string">"./xmrig --algo=cr...."</span>  4 hours ago  Exited (137) 7 minutes ago           linuxrun-cpu2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这就是有人在你的 Docker 宿主上跑了一个 <code>xmrig</code> 挖矿的蠕虫，因为你的系统<strong>被入侵了</strong>……😓。</p>
<p>在你大叫 Docker 不安全之前，<em>先检讨一下自己</em>是不是做错了。检查一下 <code>dockerd</code> 引擎是否配置错误：<code>ps -ef | grep dockerd</code>，如果你看到的是这样子的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep dockerd</span><br><span class="line">123  root   12:34   /usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure>
<p>如果在其中没有 <code>--tlsverify</code> 类的 TLS 配置参数，那就说明你将你的系统大门彻底敞开了。这是配置上<strong>严重的安全事故</strong>。</p>
<p><code>-H tcp://0.0.0.0:2375</code> 是说你希望通过 <code>2375/tcp</code> 来操控你的 Docker 引擎，但是如果你没有加 <code>--tlsverify</code> 类的配置，就表明你的意图是<strong>允许任何人</strong>来操控你的 Docker 引擎，而 Docker 引擎是以 <code>root</code> 权限允许的，因此，你等于给了<strong>地球上所有人</strong>你服务器的 <code>root</code> 权限，而且<strong>还没密码</strong>。</p>
<p>如果细心一些，去查看 <code>dockerd</code> 的服务日志，<code>journalctl -u docker</code>，日志中有明确的警告，警告你这么配置是极端危险的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -u docker</span><br><span class="line">...</span><br><span class="line">level=warning msg=<span class="string">"[!] DON'T BIND ON ANY IP ADDRESS WITHOUT setting --tlsverify IF YOU DON'T KNOW WHAT YOU'RE DOING [!]"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果这些你都忽略了，那么被别人入侵就太正常了，是你自己<em>邀请</em>别人来的。所以，Docker 服务绑定端口，<em>必须</em>通过 TLS 保护起来，以后见到 <code>-H tcp://....</code> 就要检查，是否同时配置了 <code>--tlsverify</code>，如果没看到，那就是严重错误了。</p>
<p>这也是为什么推荐使用 <code>docker-machine</code> 进行 Docker 宿主管理的原因，因为 <code>docker-machine</code> 会帮你创建证书、配置 TLS，确保服务器的安全。</p>
<p>进一步如何配置 TLS 的信息，可以查看官网文档：<a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/https/</a><br>关于 <code>docker-machine</code> 的介绍，可以看官网文档：<a href="https://docs.docker.com/machine/overview/" target="_blank" rel="noopener">https://docs.docker.com/machine/overview/</a></p>
<h2 id="网络问题-13"><a href="#网络问题-13" class="headerlink" title="网络问题 (13)"></a>网络问题 <code>(13)</code></h2><h3 id="怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？"><a href="#怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？" class="headerlink" title="怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？"></a>怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？</h3><p>一般情况是不需要指定容器 IP 地址的。这不是虚拟主机，而是容器。其地址是供容器间通讯的，容器间则不用 IP 直接通讯，而使用<code>容器名</code>、<code>服务名</code>、<code>网络别名</code>。</p>
<p>为了保持向后兼容，<code>docker run</code> 在不指定 <code>--network</code> 时，所在的网络是 <code>default bridge</code>，在这个网络下，需要使用 <code>--link</code> 参数才可以让两个容器找到对方。</p>
<p>这是有局限性的，因为这个时候使用的是 <code>/etc/hosts</code> 静态文件来进行的解析，比如一个主机挂了后，重新启动IP可能会改变。虽然说这种改变Docker是可能更新<code>/etc/hosts</code>文件，但是这有诸多问题，可能会因为竞争冒险导致 <code>/etc/hosts</code> 文件损毁，也可能还在运行的容器在取得 <code>/etc/hosts</code> 的解析结果后，不再去监视该文件是否变动。种种原因都可能会导致旧的主机无法通过容器名访问到新的主机。</p>
<p>参考官网文档：<a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/</a></p>
<p>如果可能不要使用这种过时的方式，而是用下面说的自定义网络的方式。</p>
<p>而对于新的环境（Docker 1.10以上），应该给容器建立自定义网络，同一个自定义网络中，可以使用对方容器的容器名、服务名、网络别名来找到对方。这个时候帮助进行服务发现的是Docker 内置的DNS。所以，无论容器是否重启、更换IP，内置的DNS都能正确指定到对方的位置。</p>
<p>参考官网文档：<a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/#linking-containers-in-user-defined-networks" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/work-with-networks/#linking-containers-in-user-defined-networks</a></p>
<p>建议参考一下我写的 LNMP 的例子：<br><a href="https://coding.net/u/twang2218/p/docker-lnmp/git" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git</a></p>
<h3 id="如何修改容器的-etc-hosts-文件？"><a href="#如何修改容器的-etc-hosts-文件？" class="headerlink" title="如何修改容器的 /etc/hosts 文件？"></a>如何修改容器的 <code>/etc/hosts</code> 文件？</h3><p>容器内的 <code>/etc/hosts</code> 文件不应该被随意修改，如果必须添加主机名和 IP 地址映射关系，应该在 <code>docker run</code> 时使用 <code>--add-host</code> 参数，或者在 <code>docker-compose.yml</code> 中添加 <code>extra_hosts</code> 项。</p>
<p>不过在用之前，应该再考虑一下真的需要修改 <code>/etc/hosts</code> 么？如果只是为了容器间互相访问，应该建立自定义网络，并使用 Docker 内置的 DNS 服务。</p>
<p>可以参考一下我写的这个 LNMP 多容器互连的例子：<a href="https://coding.net/u/twang2218/p/docker-lnmp/git" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git</a></p>
<h3 id="怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？"><a href="#怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？" class="headerlink" title="怎么映射宿主端口？Dockerfile 中的EXPOSE和 docker run -p 有啥区别？"></a>怎么映射宿主端口？<code>Dockerfile</code> 中的<code>EXPOSE</code>和 <code>docker run -p</code> 有啥区别？</h3><p>Docker中有两个概念，一个叫做 <code>EXPOSE</code> ，一个叫做 <code>PUBLISH</code> 。</p>
<ul>
<li><code>EXPOSE</code> 是镜像/容器声明要暴露该端口，可以供其他容器使用。这种声明，在没有设定 <code>--icc=false</code>的时候，实际上只是一种标注，并不强制。也就是说，没有声明 <code>EXPOSE</code> 的端口，其它容器也可以访问。但是当强制 <code>--icc=false</code> 的时候，那么只有 <code>EXPOSE</code> 的端口，其它容器才可以访问。</li>
<li><code>PUBLISH</code> 则是通过映射宿主端口，将容器的端口公开于外界，也就是说宿主之外的机器，可以通过访问宿主IP及对应的该映射端口，访问到容器对应端口，从而使用容器服务。</li>
</ul>
<p><code>EXPOSE</code> 的端口可以不 <code>PUBLISH</code>，这样只有容器间可以访问，宿主之外无法访问。而 <code>PUBLISH</code> 的端口，可以不事先 <code>EXPOSE</code>，换句话说 <code>PUBLISH</code> 等于同时隐式定义了该端口要 <code>EXPOSE</code>。</p>
<p><code>docker run</code> 命令中的 <code>-p</code>, <code>-P</code> 参数，以及 <code>docker-compose.yml</code> 中的  <code>ports</code> 部分，实际上均是指 <code>PUBLISH</code>。</p>
<p>小写 <code>-p</code> 是端口映射，格式为 <code>[宿主IP:]&lt;宿主端口&gt;:&lt;容器端口&gt;</code>，其中宿主端口和容器端口，既可以是一个数字，也可以是一个范围，比如：<code>1000-2000:1000-2000</code>。对于多宿主的机器，可以指定宿主IP，不指定宿主IP时，守护所有接口。</p>
<p>大写 <code>-P</code> 则是自动映射，将所有定义 <code>EXPOSE</code> 的端口，随机映射到宿主的某个端口。</p>
<h3 id="我要映射好几百个端口，难道要一个个-p-么？"><a href="#我要映射好几百个端口，难道要一个个-p-么？" class="headerlink" title="我要映射好几百个端口，难道要一个个 -p 么？"></a>我要映射好几百个端口，难道要一个个 <code>-p</code> 么？</h3><p><code>-p</code> 是可以用范围的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 8001-8010:8001-8010</span><br></pre></td></tr></table></figure>
<h3 id="为什么-p-后还是无法通过映射端口访问容器里面的服务？"><a href="#为什么-p-后还是无法通过映射端口访问容器里面的服务？" class="headerlink" title="为什么 -p 后还是无法通过映射端口访问容器里面的服务？"></a>为什么 <code>-p</code> 后还是无法通过映射端口访问容器里面的服务？</h3><p>首先，当然是检查这个 docker 的容器是否启动正常： <code>docker ps</code>、<code>docker top &lt;容器ID&gt;</code>、<code>docker logs &lt;容器ID&gt;</code>、<code>docker exec -it &lt;容器ID&gt; bash</code>等，这是比较常用的排障的命令；如果是 <code>docker-compose</code> 也有其对应的这一组命令，所以排障很容易。</p>
<p>如果确保服务一切正常，甚至在容器里，可以访问到这些服务，<code>docker ps</code> 也显示出了端口映射成功，那么就需要<strong>检查防火墙</strong>了。</p>
<h4 id="本机防火墙"><a href="#本机防火墙" class="headerlink" title="本机防火墙"></a>本机防火墙</h4><p>在 Docker 运行的系统上<strong>不应该运行任何防火墙</strong>……没错，说你呢，CentOS 的 <strong>firewalld</strong> 和 Ubuntu 的 <strong>ufw</strong> 同学。由于 Docker 使用 <code>iptables</code> 规则来进行网络数据流的控制，而那些防火墙总以为只有自己撰写 <code>iptables</code>，从而经常会导致 Docker 设置了一些规则，然后转眼就被 <code>firewalld</code> 或 <code>ufw</code> 给清了，特别是起、停防火墙服务的时候。从而导致 Docker 的网络从外界无法访问。</p>
<blockquote>
<p>为了避免 <code>iptables</code> 的规则干扰，不要在运行 Docker 的服务器上，运行<strong>任何防火墙</strong>或配置自定义的 <code>iptables</code> 规则，<em>除非</em>你非常清楚你在做什么，并且知道会产生什么后果。<br>另外，<strong>关闭防火墙后，记得重启系统</strong>，至少是重启 Docker 服务。否则防火墙的起、停、刷新这类行为会导致清空 Docker 设置的网络规则，而导致容器内的网络无法和外部互联。</p>
</blockquote>
<h4 id="边界防火墙"><a href="#边界防火墙" class="headerlink" title="边界防火墙"></a>边界防火墙</h4><p>如果你使用的是云服务器，那么除了本机防火墙外，云服务的服务商一般会提供边界防火墙服务，比如安全组、安全策略类的东西。有些服务器为了安全起见，默认只开通必需的 <code>22</code> 端口给 SSH 使用，而其它端口屏蔽。这也是可能导致远程访问服务器 <code>-p</code> 端口失败的原因之一。如果你发现你在服务器本地访问服务，比如 <code>curl localhost</code> 没有阻碍，但是远程访问该服务就连接失败的话，那么应该去检查云服务商的安全设置，是否忘记了开启所需的端口。</p>
<h3 id="vethxxxx-这种虚拟网卡和容器的对应关系从哪里看？"><a href="#vethxxxx-这种虚拟网卡和容器的对应关系从哪里看？" class="headerlink" title="vethxxxx 这种虚拟网卡和容器的对应关系从哪里看？"></a><code>vethxxxx</code> 这种虚拟网卡和容器的对应关系从哪里看？</h3><p><code>北京-ZZ-虾米</code>提供了一个好办法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                       DRIVER</span><br><span class="line">56f04389b8f0        dockerlnmp_backend         bridge</span><br><span class="line">094fcb269385        dockerlnmp_frontend        bridge</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>NETWORK ID</code>，然后运行 <code>ip a | grep veth</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ip a | grep veth</span><br><span class="line">12: veth22996d2@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-56f04389b8f0 state UP group default</span><br><span class="line">14: veth34ace9a@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-56f04389b8f0 state UP group default</span><br><span class="line">16: veth0bb3771@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-56f04389b8f0 state UP group default</span><br><span class="line">22: veth399b874@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-094fcb269385 state UP group default</span><br><span class="line">24: vethf24a0a9@if23: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-094fcb269385 state UP group default</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>br-56f04389b8f0</code> 以及 <code>br-094fcb269385</code>，<code>br-</code> 后面的是上面的<code>网络id</code>，由此可以看出 <code>veth</code> 和 Docker 网络的对应关系，而容器都是连接到了某个Docker网络上的，从而就有了容器和 <code>veth</code> 的对应关系。</p>
<p>对于某个网络出现了多个 <code>veth</code> 的情况，可以观察 <code>veth22996d2@if11</code> 后面的 <code>if11</code> 这部分，和容器内的 <code>ip addr</code> 的结果，一般 <code>奇-偶</code>是一对。</p>
<h3 id="如何让一个容器连接两个网络？"><a href="#如何让一个容器连接两个网络？" class="headerlink" title="如何让一个容器连接两个网络？"></a>如何让一个容器连接两个网络？</h3><p>如果是使用 <code>docker run</code>，那很不幸，一次只可以连接一个网络，因为 <code>docker run</code> 的 <code>--network</code> 参数只可以出现一次（如果出现多次，最后的会覆盖之前的）。不过容器运行后，可以用命令 <code>docker network connect</code> 连接多个网络。</p>
<p>假设我们创建了两个网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create mynet1</span><br><span class="line">$ docker network create mynet2</span><br></pre></td></tr></table></figure>
<p>然后，我们运行容器，并连接这两个网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name web --network mynet1 nginx</span><br><span class="line">$ docker network connect mynet2 web</span><br></pre></td></tr></table></figure>
<p>但是如果使用 <code>docker-compose</code> 那就没这个问题了。因为实际上，<a href="https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/create-a-container" target="_blank" rel="noopener"><code>Docker Remote API</code></a> 是支持一次性指定多个网络的，但是估计是命令行上不方便，所以 <code>docker run</code> 限定为只可以一次连一个。<code>docker-compose</code> 直接就可以将服务的容器连入多个网络，没有问题。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mynet1</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">mynet2</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">    mynet1:</span></span><br><span class="line"><span class="attr">    mynet2:</span></span><br></pre></td></tr></table></figure>
<h3 id="Docker-多宿主网络怎么配置？"><a href="#Docker-多宿主网络怎么配置？" class="headerlink" title="Docker 多宿主网络怎么配置？"></a>Docker 多宿主网络怎么配置？</h3><p>Docker 跨节点容器网络互联，最通用的是使用 <code>overlay</code> 网络。</p>
<p>一代 Swarm 已经不再使用，它要求使用 <code>overlay</code> 网络前先准备好分布式键值库，比如 <code>etcd</code>, <code>consul</code> 或 <code>zookeeper</code>。然后在每个节点的 Docker 引擎中，配置 <code>--cluster-store</code> 和 <code>--cluster-advertise</code> 参数。这样才可以互连。可以参考我写的 LNMP 容器互联例子中的 <a href="https://coding.net/u/twang2218/p/docker-lnmp/git/blob/master/run1.sh" target="_blank" rel="noopener"><strong>run1.sh</strong></a> 这个脚本，这个脚本是利用 <code>docker-machine</code>自动建立 Swarm 并且配置好 <code>overlay</code> 的脚本，可以分析其流程。</p>
<p>现在都在使用二代 Swarm，也就是 <code>Docker Swarm Mode</code>，非常简单，只要 <code>docker swarm init</code> 建立集群，其它节点 <code>docker swarm join</code> 加入集群后，集群内的服务就自动建立了 <code>overlay</code> 网络互联能力。</p>
<p>需要注意的是，如果是<strong>多网卡环境</strong>，无论是 <code>docker swarm init</code> 还是 <code>docker swarm join</code>，都不要忘记使用参数 <code>--advertise-addr</code> 指定宣告地址，否则自动选择的地址很可能不是你期望的，从而导致集群互联失败。格式为 <code>--advertise-addr &lt;地址&gt;:&lt;端口&gt;</code>，地址可以是 IP 地址，也可以是网卡接口，比如 <code>eth0</code>。端口默认为 <code>2377</code>，如果不改动可以忽略。</p>
<p>此外，这是供<strong>服务</strong>使用的 <code>overlay</code>，因此所有 <code>docker service create</code> 的服务容器可以使用该网络，而 <code>docker run</code> 不可以使用该网络，除非明确该网络为 <code>--attachable</code>。</p>
<p>关于 <code>overlay</code> 网络的进一步信息，可以参考官网文档：<a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/get-started-overlay/</a></p>
<p>虽然默认使用的是 <code>overlay</code> 网络，但这并不是唯一的多宿主互联方案。Docker 内置了一些其它的互联方案，比如效率比较高的 <code>macvlan</code>。如果在局域网络环境下，对 <code>overlay</code> 的额外开销不满意，那么可以考虑 <code>macvlan</code> 以及 <code>ipvlan</code>，这是比较好的方案。<br><a href="https://docs.docker.com/engine/userguide/networking/get-started-macvlan/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/get-started-macvlan/</a></p>
<p>此外，还有很多第三方的网络可以用来进行跨宿主互联，可以访问官网对应文档进一步查看：<a href="https://docs.docker.com/engine/extend/legacy_plugins/#/network-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/legacy_plugins/#/network-plugins</a></p>
<h3 id="明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在啊？"><a href="#明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在啊？" class="headerlink" title="明明 docker network ls 中看到了建立的 overlay 网络，怎么 docker run 还说网络不存在啊？"></a>明明 <code>docker network ls</code> 中看到了建立的 <code>overlay</code> 网络，怎么 <code>docker run</code> 还说网络不存在啊？</h3><p>如果在 <code>docker network ls</code> 中看到了如下的 <code>overlay</code> 网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">...</span><br><span class="line">24pz359114y0        mynet               overlay             swarm</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么这个名为 <code>mynet</code> 的网络是不可以连接到 <code>docker run</code> 的容器。如果试图连接则会出现报错。</p>
<p>如果是 1.12 的系统，会看到这样报错信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --network mynet busybox</span><br><span class="line">docker: Error response from daemon: network mynet not found.</span><br><span class="line">See <span class="string">'docker run --help'</span>.</span><br></pre></td></tr></table></figure>
<p>报错说 <code>mynet</code> 网络找不到。其实如果仔细观察，会看到这个名为 <code>mynet</code> 的网络，驱动是 <code>overlay</code> 没有错，但它的 <code>Scope</code> 是 <code>swarm</code>。这个意思是说这个网络是在二代 <code>Swarm</code> 环境中建立的 <code>overlay</code> 网络，因此只可以由 <code>Swarm</code> 环境下的服务容器才可以使用。而 <code>docker run</code> 所运行的只是零散的容器，并非 <code>Service</code>，因此自然在零散容器所能使用的网络中，不存在叫 <code>mynet</code> 网络。</p>
<p><code>docker run</code> 可以使用的 <code>overlay</code> 网络是 <code>Scope</code> 为 <code>global</code> 的 <code>overlay</code> 网络，也就是使用外置键值库所建立的 <code>overlay</code> 网络，比如一代 <code>Swarm</code> 的 <code>overlay</code> 网络。</p>
<p>这点在 1.13 后稍有变化。如果是 1.13 以后的系统，会看到这样的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --network mynet busybox</span><br><span class="line">docker: Error response from daemon: Could not attach to network mynet: rpc error: code = 7</span><br><span class="line"> desc = network mynet not manually attachable.</span><br></pre></td></tr></table></figure>
<p>报错信息不再说网络找不到，而是说这个 <code>mynet</code> 网络无法连接。这是由于从 1.13 开始，允许在建立网络的时候声明这个网络是否可以被零散的容器所连接。如果 <code>docker network create</code> 加了 <code>--attachable</code> 的参数，那么在后期，这个网络是可以被普通容器所连接的。</p>
<p>但是这是在安全模型上开了一个口子，因此，默认不允许普通容器链接，并且不建议使用。</p>
<h3 id="使用-Swarm-Mode-的时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？"><a href="#使用-Swarm-Mode-的时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？" class="headerlink" title="使用 Swarm Mode 的时，看到有个叫 ingress 的 overlay 网络，它和自己创建的网络有什么区别？"></a>使用 <code>Swarm Mode</code> 的时，看到有个叫 <code>ingress</code> 的 <code>overlay</code> 网络，它和自己创建的网络有什么区别？</h3><p>在启用了二代 Swarm 后，可能会在网络列表时看到一个名为 <code>ingress</code> 的 overlay 网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">6beb824623a4        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">f3f636574c7a        docker_gwbridge     bridge              <span class="built_in">local</span></span><br><span class="line">cfeb2513a4a3        host                host                <span class="built_in">local</span></span><br><span class="line">88smbt683r5p        ingress             overlay             swarm</span><br><span class="line">24pz359114y0        mynet               overlay             swarm</span><br><span class="line">d35d69ece740        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到两个 <code>overlay</code> 网络，其中一个是我们创建的 <code>mynet</code>，另一个则是 Docker 引擎自己创建的 <code>ingress</code>，从驱动和 <code>Scope</code> 可以看出两个网络都是给 Swarm Mode 使用的 <code>overlay</code> 网络。</p>
<p><code>ingress</code> 是 <code>overlay</code> 网络，但并不是普通的 <code>overlay network</code>，它是为边界进入流量特殊准备的网络。这个网络存在于集群中每一个Docker宿主上，不需要额外建立。</p>
<p>当我们使用 <code>docker service create -p 80:80</code> 这种形式创建一个服务的时候，我们要求映射集群端口 <code>80</code> 到服务容器的 <code>80</code> 端口上。其效果是访问任一节点的 <code>80</code> 端口，即使这个节点没有运行我们所需的容器，依旧可以连接到容器服务，并且取得结果。实现这样效果的一个原因就是因为 <code>ingress</code> 网络的存在。</p>
<p>Swarm 中的每个节点，都会有一个<strong>隐藏的沙箱容器</strong>监听宿主的服务端口，用于接收来自集群外界的访问。</p>
<p>我们可以通过 <code>docker network inspect ingress</code> 来看到这个沙箱容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect ingress</span><br><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="string">"Name"</span>: <span class="string">"ingress"</span>,</span><br><span class="line">       <span class="string">"Id"</span>: <span class="string">"88smbt683r5p7c0l7sd0dpniw"</span>,</span><br><span class="line">       <span class="string">"Scope"</span>: <span class="string">"swarm"</span>,</span><br><span class="line">       <span class="string">"Driver"</span>: <span class="string">"overlay"</span>,</span><br><span class="line">       <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">       <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">           <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">           <span class="string">"Options"</span>: null,</span><br><span class="line">           <span class="string">"Config"</span>: [</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="string">"Subnet"</span>: <span class="string">"10.255.0.0/16"</span>,</span><br><span class="line">                   <span class="string">"Gateway"</span>: <span class="string">"10.255.0.1"</span></span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">       <span class="string">"Containers"</span>: &#123;</span><br><span class="line">           <span class="string">"faff08692b5f916fcb15aa7ac6bc8633a0fa714a52a1fb75e57525c94581c45a"</span>: &#123;</span><br><span class="line">               <span class="string">"Name"</span>: <span class="string">"web.1.1jyunyva6picwsztzrj6t2cio"</span>,</span><br><span class="line">               <span class="string">"EndpointID"</span>: <span class="string">"58240770eb25565b472384731b1b90e36141a633ce184a5163829cf96e9d1195"</span>,</span><br><span class="line">               <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:ff:00:05"</span>,</span><br><span class="line">               <span class="string">"IPv4Address"</span>: <span class="string">"10.255.0.5/16"</span>,</span><br><span class="line">               <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="string">"ingress-sbox"</span>: &#123;</span><br><span class="line">               <span class="string">"Name"</span>: <span class="string">"ingress-endpoint"</span>,</span><br><span class="line">               <span class="string">"EndpointID"</span>: <span class="string">"fe8f89d4f99d7bacb14c5cb723682c180278d62e9edd10b523cdd81a45695c5d"</span>,</span><br><span class="line">               <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:ff:00:03"</span>,</span><br><span class="line">               <span class="string">"IPv4Address"</span>: <span class="string">"10.255.0.3/16"</span>,</span><br><span class="line">               <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"Options"</span>: &#123;</span><br><span class="line">           <span class="string">"com.docker.network.driver.overlay.vxlanid_list"</span>: <span class="string">"256"</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在上面的命令返回信息中，我们可以看到一个名为 <code>ingress-endpoint</code> 的容器，这就是边界沙箱容器。</p>
<p>当我们创建服务时，使用了 <code>-p</code> 参数后，服务容器就会被自动的加入到 <code>ingress</code> 网络中，同时会在沙箱中注册映射信息，告知哪个服务要求守护哪个端口，具体对应容器是哪些。</p>
<p>因此当沙箱收到外部连接后，通过访问端口就可以知道具体服务在守护，然后会通过这个 <code>ingress</code> 网络去将连接请求转发给对应服务容器。而由于 <code>ingress</code> 的本质是 <code>overlay network</code>，因此，无论服务容器运行于哪个节点上，沙箱都可以成功的将连接转发给正确的服务容器。</p>
<p>所以，<code>ingress</code> 是特殊用途的网络，只要服务有 <code>-p</code> 选项，那么服务容器就会自动被加入该网络。因此把 <code>ingress</code> 网络当做普通的 <code>overlay</code> 网络使用的话，除了会干扰 Swarm 正常的边界负载均衡的能力，也会破坏服务隔离的安全机制。所以不要把这个网络当做普通的 <code>overlay</code> 网络来使用，需要控制服务互联和隔离时，请用自行创建的 <code>overlay</code> 网络。</p>
<h3 id="听说-link-过时不再用了？那容器互联、服务发现怎么办？"><a href="#听说-link-过时不再用了？那容器互联、服务发现怎么办？" class="headerlink" title="听说 --link 过时不再用了？那容器互联、服务发现怎么办？"></a>听说 <code>--link</code> 过时不再用了？那容器互联、服务发现怎么办？</h3><p>在 1-2 年前，Docker 所有容器都连接于默认的桥接网络上，也就是很多老文章鼓捣的 <code>docker0</code> 桥接网卡。因此实际上默认情况下所有容器都是可以互联的，没有隔离，当然这样安全性不好。而服务发现，是在这种环境下发展出来的，通过修改容器内的 <code>/etc/hosts</code> 文件来完成的。凡是 <code>--link</code> 的主机的别名就会出现于 <code>/etc/hosts</code> 中，其地址由 Docker 引擎维护。因此容器间才可以通过<strong>别名</strong>互访。</p>
<p>但是这种办法并不是好的解决方案，Docker 早在一年多以前就已经使用自定义网络了。在同一个网络中的容器，可以互联，并且，Docker 内置了 DNS，容器内的应用可以使用服务名、容器名、别名来进行服务发现，名称会经由内置的 DNS 进行解析，其结果是动态的；而不在同一网络中的容器，不可以互联。</p>
<p>因此，现在早就不用 <code>--link</code> 了，而且非常不建议使用。</p>
<blockquote>
<p>PS：貌似智障zabbix的镜像的引导上还写着—link </p>
</blockquote>
<p>首先是因为使用 <code>--link</code> 就很可能还在用默认桥接网络，这很不安全，所有容器都没有适度隔离，用自定义网络才比较方便互联隔离。</p>
<p>其次，修改 <code>/etc/hosts</code> 文件有很多弊病。比如，高频繁的容器启停环境时，容易产生竞争冒险，导致 <code>/etc/hosts</code> 文件损坏，出现访问故障；或者有些应用发现是来自于 <code>/etc/hosts</code> 文件后，就假定其为静态文件，而缓存结果不再查询，从而导致容器启停 IP 变更后，使用旧的条目而无法连接到正确的容器等等。</p>
<p>另外，在一代 Swarm 环境中，在 <code>docker-compose.yml</code> 中使用了 <code>links</code> 就意味着服务间的强依赖关系，因此调度时不会将服务运行于不同节点，而是全部运行于一个节点，使得横向扩展失败。</p>
<p>所以不要再使用 <code>--link</code> 以及 <code>docker-compose.yml</code> 中的 <code>links</code> 了。应该使用 <code>docker network</code>，建立网络，而 <code>docker run --network</code> 来连接特定网络。或者使用 <code>version: &#39;3&#39;</code> 的 <code>docker-compose.yml</code> 直接定义自定义网络并使用。</p>
<p>建议去看一下我写的 <code>docker-copmpose</code> 多容器互联的例子：<a href="https://github.com/Mr-Linus/docker-compose" target="_blank" rel="noopener">https://github.com/Mr-Linus/docker-compose</a>，如果你是第一次接触，请查看<a href="https://docs.docker-cn.com/get-started/part3/" target="_blank" rel="noopener">https://docs.docker-cn.com/get-started/part3/</a></p>
<h3 id="使用-HBase-Hadoop-的时候，反向解析总是不对，怎么办？"><a href="#使用-HBase-Hadoop-的时候，反向解析总是不对，怎么办？" class="headerlink" title="使用 HBase/Hadoop 的时候，反向解析总是不对，怎么办？"></a>使用 HBase/Hadoop 的时候，反向解析总是不对，怎么办？</h3><p>Hadoop/HBase 这类东西总喜欢根据设定的名称正向的解析一遍，然后在某个时候会反向的解析一遍检查是否一致。这种默认假定很多时候会出问题，特别是对于使用 <code>/etc/hosts</code> 的时候。正向解析会从 <code>/etc/hosts</code> 中取得，而反向解析则更可能走 DNS，于是出现了不一致。</p>
<p>对于 Docker 而言，使用自定义网络后，一个容器有很多个名字，内置 DNS 可以根据<strong>服务名</strong>、<strong>容器名</strong>、<strong>网络别名</strong>、<strong>&lt;容器名&gt;.&lt;网络名&gt;</strong> 等来进行解析。因此正向解析设置任何一个，其结果都会指向容器的 IP。</p>
<p>而反向解析则不会返回所有结果，而只返回<code>&lt;容器名&gt;.&lt;网络名&gt;</code>。</p>
<p>所以当有人这样运行容器的时候：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    --name wombat.example.com \</span><br><span class="line">    --hostname wombat.example.com \</span><br><span class="line">    --network net1 \</span><br><span class="line">    m3adow/nettools</span><br></pre></td></tr></table></figure>
<p>会发现反向解析结果并非自己所期望的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">50: eth0@if51: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:13:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:acff:fe13:2/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">/ <span class="comment"># dig +short wombat.example.com</span></span><br><span class="line">172.19.0.2</span><br><span class="line">/ <span class="comment"># host 172.19.0.2</span></span><br><span class="line">2.0.19.172.in-addr.arpa domain name pointer wombat.example.com.net1.</span><br></pre></td></tr></table></figure>
<p>从上面的解析结果可以看出来，由 <code>wombat.example.com</code> 正向解析的话，其结果是 <code>172.19.0.2</code>，确实是我们的 IP 地址；但是由  <code>172.19.0.2</code> 反向解析的话，所得到的域名确实 <code>wombat.example.com.net1</code>。多了一个 <code>.net1</code> 的尾巴。从而导致 HBase/Hadoop 这类软件出现故障。</p>
<p>解决办法很简单，我们现在知道反向域名解析的格式为 <code>&lt;容器名&gt;.&lt;网络名&gt;</code>。那么我们只需要将网络名设为域名就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create example.com</span><br><span class="line">$ docker run -it --rm \</span><br><span class="line">    --name wombat \</span><br><span class="line">    --hostname wombat.example.com \</span><br><span class="line">    --network example.com \</span><br><span class="line">    m3adow/nettools</span><br><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">52: eth0@if53: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:15:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.21.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:acff:fe15:2/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">/ <span class="comment"># dig +short wombat.example.com</span></span><br><span class="line">172.21.0.2</span><br><span class="line">/ <span class="comment"># host 172.21.0.2</span></span><br><span class="line">2.0.21.172.in-addr.arpa domain name pointer wombat.example.com.</span><br></pre></td></tr></table></figure>
<p>这里看到，正向解析没问题，反向解析也得到了 <code>wombat.example.com</code> 这个所期望的结果。</p>
<blockquote>
<p>需要注意的是，服务名、主机名、容器名这类可用于服务发现的名称，应该尽量使用 <strong>非 FQDN</strong>，也就是不包含 <code>.</code> 的单一名字，否则在某些情况下会出错。</p>
</blockquote>
<h3 id="容器怎么取宿主机-IP-啊？"><a href="#容器怎么取宿主机-IP-啊？" class="headerlink" title="容器怎么取宿主机 IP 啊？"></a>容器怎么取宿主机 IP 啊？</h3><h4 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h4><p>如果是单机环境，很简单，不必琢磨怎么突破命名空间限制，直接用环境变量送进去即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e HOST_IP=&lt;宿主的IP地址&gt; nginx</span><br></pre></td></tr></table></figure>
<p>然后容器内直接读取 <code>HOST_IP</code> 环境变量即可。</p>
<h4 id="集群环境"><a href="#集群环境" class="headerlink" title="集群环境"></a>集群环境</h4><p>集群环境相对比较复杂，<code>docker service create</code> 中的 <code>-e</code> 以及 <code>--env-file</code>是在服务创建时指定、读取环境变量内容，而不是运行时，因此对于每个节点都是一样的。而且目前不存在 <code>dockerd -e</code> 选项，所以直接使用这些选项达不到我们想要的效果。</p>
<p>不过有变通的办法，可以在宿主上建立一个 <code>/etc/variables</code> 文件（名字随意，这里用这个文件举例）。其内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_IP=1.2.3.4</span><br></pre></td></tr></table></figure>
<p>其中 <code>1.2.3.4</code> 是这个节点的宿主 IP，因此每个节点的 <code>/etc/variables</code> 的内容不同。</p>
<p>而在启动服务时，指定挂载这个服务端本地文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker service create --name app \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/etc/variables,target=/etc/variables:ro \</span><br><span class="line">    myapp</span><br></pre></td></tr></table></figure>
<p>由于 <code>--mount</code> 是发生于容器运行时，因此所加载的是所运行的服务器的 <code>/etc/variables</code>，里面所包含的也是该服务器的 IP 地址。</p>
<p>在 <code>myapp</code> 这个镜像的入口脚本加入加载该环境变量文件的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/variables</span><br></pre></td></tr></table></figure>
<p>这样 <code>app</code> 这个服务容器就会拥有 <code>HOST_IP</code> 环境变量，其值为所运行的宿主 IP。</p>
<h2 id="存储问题-11"><a href="#存储问题-11" class="headerlink" title="存储问题 (11)"></a>存储问题 <code>(11)</code></h2><h3 id="容器磁盘可以限制配额么？"><a href="#容器磁盘可以限制配额么？" class="headerlink" title="容器磁盘可以限制配额么？"></a>容器磁盘可以限制配额么？</h3><p>对于 <code>devicemapper</code>, <code>btrfs</code>, <code>zfs</code> 来说，可以通过 <code>--storage-opt size=100G</code> 这种形式限制 <code>rootfs</code> 的大小。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create -it --storage-opt size=120G fedora /bin/bash</span><br></pre></td></tr></table></figure>
<p>参考官网文档：<a href="https://docs.docker.com/engine/reference/commandline/run/#/set-storage-driver-options-per-container" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/#/set-storage-driver-options-per-container</a></p>
<h3 id="容器内的数据该保存在镜像里还是物理机里？"><a href="#容器内的数据该保存在镜像里还是物理机里？" class="headerlink" title="容器内的数据该保存在镜像里还是物理机里？"></a>容器内的数据该保存在镜像里还是物理机里？</h3><p>如果所谓数据是指运行时动态的数据，那么这部分数据文件不应该保存于镜像内。在运行时要保持容器基础文件不可变的特性，而变化部分使用挂载宿主目录，或者数据卷来解决。</p>
<p>建议看一下官网 <code>docker volume</code> 的文档：<a href="https://docs.docker.com/engine/tutorials/dockervolumes/" target="_blank" rel="noopener">https://docs.docker.com/engine/tutorials/dockervolumes/</a></p>
<h3 id="看到总说要保持容器无状态，那什么是无状态？"><a href="#看到总说要保持容器无状态，那什么是无状态？" class="headerlink" title="看到总说要保持容器无状态，那什么是无状态？"></a>看到总说要保持容器无状态，那什么是无状态？</h3><p>这里说到的有两个层面的无状态：</p>
<h4 id="容器存储层的无状态"><a href="#容器存储层的无状态" class="headerlink" title="容器存储层的无状态"></a>容器存储层的无状态</h4><p>这里提到的存储层是指用于存储镜像、容器各个层的存储，一般是 <code>Union FS</code>，如 <code>AUFS</code>，或者是使用块设备的一些机制（如 <code>snapshot</code> ）进行模拟，如 <code>devicemapper</code>。</p>
<p><code>Union FS</code> 这类存储系统，相当于是在现有存储上，再加一层或多层存储，这类存储的读写性能并不好。并且对于 <code>CentOS</code> 这类只能使用 <code>devicemapper</code> 的系统而言，存储层的读写还经常出 bug。因此，<strong>在 Docker 使用过程中，要避免存储层的读写</strong>。频繁读写的部分，应该使用<code>卷</code>。需要持久化的部分，可以使用<strong>命名卷</strong>进行持久化。由于命名卷的生存周期和容器不同，容器消亡重建，卷不会跟随消亡。所以容器可以随便删了重新<code>run</code>，而其挂载的<code>卷</code>则会保持之前的数据。</p>
<h4 id="服务层面的无状态"><a href="#服务层面的无状态" class="headerlink" title="服务层面的无状态"></a>服务层面的无状态</h4><p>使用卷持久化容器状态，虽然从存储层的角度看，是无状态的，但是从服务层面看，这个服务是有状态的。</p>
<p>从服务层面上说，也存在无状态服务。就是说服务本身不需要写入任何文件。比如前端 <code>nginx</code>，它不需要写入任何文件（日志走Docker日志驱动），中间的 <code>php</code>, <code>node.js</code> 等服务，可能也不需要本地存储，它们所需的数据都在 <code>redis</code>, <code>mysql</code>, <code>mongodb</code> 中了。这类服务，由于不需要卷，也不发生本地写操作，删除、重启、不保存自身状态，并不影响服务运行，它们都是<code>无状态服务</code>。这类服务由于不需要状态迁移，不需要分布式存储，因此它们的集群调度更方便。</p>
<p>之前没有 <code>docker volume</code> 的时候，有些人说 Docker 只可以支持无状态服务，原因就是只看到了存储层需求无状态，而没有 <code>docker volume</code> 的持久化解决方案。</p>
<p>现在这个说法已经不成立，服务可以有状态，状态持久化用 <code>docker volume</code>。</p>
<p>当服务可以有状态后，如果使用默认的 <code>local</code> 卷驱动，并且使用<code>本地存储</code>进行状态持久化的情况，单机服务、容器的再调度运行没有问题。但是顾名思义，使用<code>本地存储</code>的卷，只可以为当前主机提供持久化的存储，而无法跨主机。</p>
<p>但这只是使用默认的 <code>local</code> 驱动，并且使用 <code>本地存储</code> 而已。使用分布式/共享存储就可以解决跨主机的问题。<code>docker volume</code> 自然支持很多分布式存储的驱动，比如 <code>flocker</code>、<code>glusterfs</code>、<code>ceph</code>、<code>ipfs</code> 等等。常用的插件列表可以参考官方文档：<a href="https://docs.docker.com/engine/extend/legacy_plugins/#/volume-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/legacy_plugins/#/volume-plugins</a></p>
<h3 id="数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？"><a href="#数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？" class="headerlink" title="数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？"></a>数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？</h3><p>首先，挂载分为<code>挂载本地宿主目录</code> 和 <code>挂载数据卷(Volume)</code>。而<code>数据卷</code>又分为<code>匿名数据卷</code>和<code>命名数据卷</code>。</p>
<p><strong>绑定宿主目录</strong>的概念很容易理解，就是将宿主目录绑定到容器中的某个目录位置。这样容器可以直接访问宿主目录的文件。其形式是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /var/www:/app nginx</span><br></pre></td></tr></table></figure>
<p>这里注意到 <code>-v</code> 的参数中，前半部分是绝对路径。在 <code>docker run</code> 中必须是绝对路径，而在 <code>docker-compose</code> 中，可以是相对路径，因为 <code>docker-compose</code> 会帮你补全路径。</p>
<p>另一种形式是使用 <code>Docker Volume</code>，也就是<strong>数据卷</strong>。这是很多看<em>古董书</em>的人不了解的概念，<strong>不要跟数据容器（Data Container）弄混</strong>。数据卷是 Docker 引擎维护的存储方式，使用 <code>docker volume create</code> 命令创建，可以利用卷驱动支持多种存储方案。其默认的驱动为 <code>local</code>，也就是本地卷驱动。本地驱动支持<strong>命名卷</strong>和<strong>匿名卷</strong>。</p>
<p>顾名思义，命名卷就是有名字的卷，使用 <code>docker volume create --name xxx</code> 形式创建并命名的卷；而匿名卷就是没名字的卷，一般是 <code>docker run -v /data</code> 这种不指定卷名的时候所产生，或者 <code>Dockerfile</code> 里面的定义直接使用的。</p>
<p>有名字的卷，在用过一次后，以后挂载容器的时候还可以使用，因为有名字可以指定。所以一般需要保存的数据使用命名卷保存。</p>
<p>而匿名卷则是随着容器建立而建立，随着容器消亡而淹没于卷列表中（对于 <code>docker run</code> 匿名卷不会被自动删除）。<strong>对于二代 Swarm 服务而言，匿名卷会随着服务删除而自动删除。</strong> 因此匿名卷只存放无关紧要的临时数据，随着容器消亡，这些数据将失去存在的意义。</p>
<p>此外，还有一个叫数据容器 (Data Container) 的概念，也就是使用 <code>--volumes-from</code> 的东西。这早就不用了，如果看了书还在说这种方式，那说明书已经过时了。按照今天的理解，这类数据容器，无非就是挂了个匿名卷的容器罢了。</p>
<p>在 <code>Dockerfile</code> 中定义的挂载，是指 <code>匿名数据卷</code>。<code>Dockerfile</code> 中指定 <code>VOLUME</code> 的目的，只是为了将某个路径确定为卷。</p>
<p>我们知道，按照最佳实践的要求，<strong>不应该在容器存储层内进行数据写入操作</strong>，所有写入应该使用卷。如果定制镜像的时候，就可以确定某些目录会发生频繁大量的读写操作，那么<strong>为了避免</strong>在运行时由于用户疏忽而忘记指定卷，导致容器发生存储层写入的问题，就可以在 <code>Dockerfile</code> 中使用 <code>VOLUME</code> 来指定某些目录为匿名卷。这样即使用户忘记了指定卷，也不会产生不良的后果。</p>
<p>这个设置可以在运行时覆盖。通过 <code>docker run</code> 的 <code>-v</code> 参数或者 <code>docker-compose.yml</code> 的 <code>volumes</code> 指定。使用<code>命名卷</code>的好处是可以复用，其它容器可以通过这个<code>命名数据卷</code>的名字来指定挂载，共享其内容（不过<strong>要注意并发访问的竞争问题</strong>）。</p>
<p>比如，<code>Dockerfile</code> 中说 <code>VOLUME /data</code>，那么如果直接 <code>docker run</code>，其 <code>/data</code> 就会被挂载为匿名卷，向 <code>/data</code> 写入的操作不会写入到容器存储层，而是写入到了匿名卷中。但是如果运行时 <code>docker run -v mydata:/data</code>，这就覆盖了 <code>/data</code> 的挂载设置，要求将 <code>/data</code> 挂载到名为 <code>mydata</code> 的命名卷中。所以说 <code>Dockerfile</code> 中的 <code>VOLUME</code> 实际上是一层保险，确保镜像运行可以更好的遵循最佳实践，不向容器存储层内进行写入操作。</p>
<p>数据卷默认可能会保存于 <code>/var/lib/docker/volumes</code>，不过一般不需要、也<strong>不应该访问这个位置</strong>。</p>
<h3 id="卷和挂载目录有什么区别？"><a href="#卷和挂载目录有什么区别？" class="headerlink" title="卷和挂载目录有什么区别？"></a>卷和挂载目录有什么区别？</h3><p>卷 (Docker Volume) 是受控存储，是由 Docker 引擎进行管理维护的。因此使用卷，你可以不必处理 <code>uid</code>、<code>SELinux</code> 等各种权限问题，Docker 引擎在建立卷时会自动添加安全规则，以及根据挂载点调整权限。并且可以统一列表、添加、删除。另外，除了本地卷外，还支持网络卷、分布式卷。</p>
<p>而挂载目录那就没人管了，属于用户自行维护。你就必须手动处理所有权限问题。特别是在 <code>CentOS</code> 上，很多人碰到 <code>Permission Denied</code>，就是因为没有使用卷，而是挂载目录，而且还对 SELinux 安全权限一无所知导致。</p>
<h3 id="为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？"><a href="#为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？" class="headerlink" title="为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？"></a>为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？</h3><p>在绑定宿主内容的形式中，有一种特殊的形式，就是<strong>绑定宿主文件</strong>，既：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v <span class="variable">$PWD</span>/myapp.ini:/app/app.ini myapp</span><br></pre></td></tr></table></figure>
<p>在 <code>myapp.ini</code> 文件<strong>不发生改变</strong>的情况下，这样的绑定是和绑定宿主目录性质一样，同样是将宿主文件绑定到容器内部，容器内可以看到这个文件。但是，一旦文件发生改变，情况则有不同。</p>
<p>简单的文件修改，比如 <code>echo &quot;name = jessie&quot; &gt;&gt; myapp.ini</code>，这类修改依旧还是原来的文件，宿主（或容器）对文件进行的改动，另一方是可以看到的。</p>
<p>而复杂的文件操作，比如使用 <code>vim</code>，或者其它编辑器编辑文件，则很有可能会导致一方的修改，另一方看不到。</p>
<p>其原因是这类编辑器在保存文件的时候，经常会采用一种避免写入过程中发生故障而导致文件丢失的策略，既先把内容写到一个新的文件中去，写好了后，再删除旧的文件，然后把新文件改名为旧的文件名，从而完成保存的操作。从这个操作流程可以看出，虽然修改后的文件的名字和过去一样，但对于文件系统而言是一个新的文件了。换句话说，虽然是同名文件，但是旧的文件的 <code>inode</code> 和修改后的文件的 <code>inode</code> 不同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -i</span><br><span class="line">268541 hello.txt</span><br><span class="line">$ vi hello.txt</span><br><span class="line">$ ls -i</span><br><span class="line">268716 hello.txt</span><br></pre></td></tr></table></figure>
<p>如上面的例子可以看到，经过 <code>vim</code> 编辑文件后，<code>inode</code> 从 <code>268541</code> 变为了 <code>268716</code>，这就是刚才说的，名字还是那个名字，文件已不是原来的文件了。</p>
<p>而 Docker 的 <strong>绑定</strong>宿主文件，实际上在文件系统眼里，针对的是 <code>inode</code>，而不是文件名。因此容器内所看到的，依旧是之前旧的 <code>inode</code> 对应的那个文件，也就是旧的内容。</p>
<p>这就出现了之前的那个问题，在宿主内修改绑定文件的内容，结果发现容器内看不到改变，其原因就在于<strong>宿主的那个文件已不是原来的文件了</strong>😂。</p>
<p>这类问题解决办法很简单，如果文件可能改变，那么就<strong>不要绑定宿主文件，而是绑定一个宿主目录</strong>，这样只要目录不跑，里面文件爱咋改就咋改😁。</p>
<h3 id="多个-Docker-容器之间共享数据怎么办？NFS-？"><a href="#多个-Docker-容器之间共享数据怎么办？NFS-？" class="headerlink" title="多个 Docker 容器之间共享数据怎么办？NFS ？"></a>多个 Docker 容器之间共享数据怎么办？NFS ？</h3><p>如果是同一个宿主，那么可以绑定同一个数据卷，当然，程序上要处理好并发问题。</p>
<p>如果是不同宿主，则可以使用分布式数据卷驱动，让分布在不同宿主的容器都可以访问到的分布式存储的位置。如S3之类：</p>
<p><a href="https://docs.docker.com/engine/extend/plugins/#volume-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/plugins/#volume-plugins</a></p>
<h3 id="既然一个容器一个应用，那么我想在该容器中用计划任务-cron-怎么办？"><a href="#既然一个容器一个应用，那么我想在该容器中用计划任务-cron-怎么办？" class="headerlink" title="既然一个容器一个应用，那么我想在该容器中用计划任务 cron 怎么办？"></a>既然一个容器一个应用，那么我想在该容器中用计划任务 <code>cron</code> 怎么办？</h3><p><code>cron</code> 其实是另一个服务了，所以应该另起一个容器来进行，如需访问该应用的数据文件，那么可以共享该应用的数据卷即可。而 <code>cron</code> 的容器中，<code>cron</code> 以前台运行即可。</p>
<p>比如，我们希望有个 <code>python</code> 脚本可以定时执行。那么可以这样构建这个容器。</p>
<p>首先基于 <code>python</code> 的镜像定制：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.5</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y cron \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get autoremove -y</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY ./cronpy /etc/cron.d/cronpy</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"cron"</span>, <span class="string">"-f"</span>]</span></span><br></pre></td></tr></table></figure>
<p>其中所提及的 <code>cronpy</code> 就是我们需要计划执行的 <code>cron</code> 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * root /app/task.py &gt;&gt; /var/<span class="built_in">log</span>/task.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>在这个计划中，我们希望定时执行 <code>/app/task.py</code> 文件，日志记录在 <code>/var/log/task.log</code> 中。这个 <code>task.py</code> 是一个非常简单的文件，其内容只是输出个时间而已。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">print(<span class="string">"Cron job has run at &#123;0&#125; with environment variable "</span>.format(str(datetime.now())))</span><br></pre></td></tr></table></figure>
<p>这 <code>task.py</code> 可以在构建镜像时放进去，也可以挂载宿主目录。在这里，我以挂载宿主目录举例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">docker build -t cronjob:latest .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run \</span><br><span class="line">    --name cronjob \</span><br><span class="line">    -d \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>)/task.py:/app/task.py \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>)/<span class="built_in">log</span>/:/var/<span class="built_in">log</span>/ \</span><br><span class="line">    cronjob:latest</span><br></pre></td></tr></table></figure>
<p>需要注意的是，应该在构建主机上赋予 <code>task.py</code> 文件可执行权限。</p>
<h3 id="如何初始化卷？"><a href="#如何初始化卷？" class="headerlink" title="如何初始化卷？"></a>如何初始化卷？</h3><p>卷（<code>Volume</code>），是用于动态数据持久化的。因此其内存储的都是动态数据，运行时会变化。如果这里面需要初始化里面的数据，需要在运行时进行。或者在镜像里加入初始化的脚本，比如 <code>mysql</code> 镜像中的初始化目录中的脚本；或者自己单独制作纯粹用于初始化卷用的镜像，单独一次性运行以将初始化数据灌入卷中。</p>
<p>举个例子来说，假设你需要个卷 <code>mydata</code>，然后里面需要有个 <code>hello.txt</code> 文件是必须存在的，否则容器运行就要出大事儿了……（这需求很傻我知道……😅好吧，假设如此）。</p>
<p>当然，我们得先有这个卷。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --name mydata</span><br></pre></td></tr></table></figure>
<p>那怎么把这个超重要的 <code>hello.txt</code> 文件放入卷中呢？有几种办法。</p>
<h4 id="正常挂载该-mydata-卷，然后-docker-cp-进去"><a href="#正常挂载该-mydata-卷，然后-docker-cp-进去" class="headerlink" title="正常挂载该 mydata 卷，然后 docker cp 进去"></a>正常挂载该 <code>mydata</code> 卷，然后 <code>docker cp</code> 进去</h4><p>这是个很傻的办法，不过如果容器运行并不依赖于 <code>hello.txt</code> 的话，这样做是可以的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name web -v mydata:/data nginx</span><br><span class="line">$ docker cp ./hello.txt web:/data/</span><br></pre></td></tr></table></figure>
<p>这样是先让容器启动，启动后，再把所需数据导入卷里面去。以后容器就可以使用 <code>/data/hello.txt</code> 文件了。</p>
<p>但是，如果容器是严重依赖于这个 <code>hello.txt</code> 文件的话，这样做就会出问题。容器会因为 <code>hello.txt</code> 文件不存在，而报错退出，导致根本没有 <code>docker cp</code> 的机会。</p>
<p>这种情况，我们可以变通一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm \</span><br><span class="line">    -v <span class="variable">$PWD</span>:/<span class="built_in">source</span> \</span><br><span class="line">    -v mydata:/data \</span><br><span class="line">    busybox \</span><br><span class="line">    cp /<span class="built_in">source</span>/hello.txt /data/</span><br><span class="line">$ docker run -d --name web -v mydata:/data nginx</span><br></pre></td></tr></table></figure>
<p>这里我们先启动了一个 <code>busybox</code> 容器，分别挂载要复制的源以及目标的 <code>mydata</code> 卷，然后用 <code>cp</code> 命令将 <code>hello.txt</code> 复制到 <code>mydata</code> 中去。数据导入结束后，我们再正式挂载 <code>mydata</code> 卷到正式的容器上并启动。这个时候严重依赖 <code>/data/hello.txt</code> 的这个容器就可以顺利运行了。</p>
<h4 id="专门制作初始化镜像"><a href="#专门制作初始化镜像" class="headerlink" title="专门制作初始化镜像"></a>专门制作初始化镜像</h4><p>手动的去执行 <code>docker cp</code>，或者 <code>docker run ... cp ...</code> 并不是很正规。可以写个脚本让一切都标准化，但是，除了流程外，还需要确保当前环境中的初始化数据的版本必须是所期望的，否则初始化了错误的数据，也会让运行时状态达不到预期的效果。</p>
<p>因此，另一种办法是专门制作一个初始化卷的镜像，这样的做法也比较方便在 CI/CD 流程中对初始化数据的过程进行测试确认。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello.txt /<span class="built_in">source</span>/</span></span><br><span class="line"><span class="bash">VOLUME /data</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"cp"</span>, <span class="string">"/source/hello.txt"</span>, <span class="string">"/data/"</span>]</span></span><br></pre></td></tr></table></figure>
<p>这样的镜像只有一个生存目的，就是挂载 <code>mydata</code> 卷，并且把数据导入进去。假设构建好的镜像名为 <code>volume-prepare</code>，只需要执行下面的命令就可以完成导入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v mydata:/data volume-prepare</span><br></pre></td></tr></table></figure>
<h4 id="在镜像的-Dockerfile-制作中，加入初始化部分"><a href="#在镜像的-Dockerfile-制作中，加入初始化部分" class="headerlink" title="在镜像的 Dockerfile 制作中，加入初始化部分"></a>在镜像的 <code>Dockerfile</code> 制作中，加入初始化部分</h4><p>在之前的问答中我们已经了解到，官方镜像 <code>mysql</code> 中可以使用 <code>Dockerfile</code> 来添加初始化脚本，并且会在运行时判断是否为第一次运行，如果确实需要初始化，则执行定制的初始化脚本。</p>
<p>我们也可以使用这种方法将 <code>hello.txt</code> 在初始化的时候加入到 <code>mydata</code> 卷中去。</p>
<p>首先我们需要写一个进入点的脚本，用以确保在容器执行的时候都会运行，而这个脚本将判断是否需要数据初始化，并且进行初始化操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">"/data/hello.txt"</span> ]; <span class="keyword">then</span></span><br><span class="line">    cp /<span class="built_in">source</span>/hello.txt /data/</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<p>名为 <code>entrypoint.sh</code> 的这个脚本很简单，判断一下 <code>/data/hello.txt</code> 是否存在，如果不存在就需要初始化。初始化行为也很简单，将实现准备好的 <code>/source/hello.txt</code> 复制到 <code>/data/</code> 目录中去，以完成初始化。程序的最后，将执行送入的命令。</p>
<p>我们可以这样写 <code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello.txt /<span class="built_in">source</span>/</span></span><br><span class="line"><span class="bash">COPY entrypoint.sh /</span></span><br><span class="line"><span class="bash">VOLUME /data</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/entrypoint.sh"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></table></figure>
<p>当我们构建镜像、启动容器后，就会发现 <code>/data</code> 目录下已经存在了 <code>hello.txt</code> 文件了，初始化成功了。</p>
<h3 id="为什么说数据库不适合放在-Docker-容器里运行？"><a href="#为什么说数据库不适合放在-Docker-容器里运行？" class="headerlink" title="为什么说数据库不适合放在 Docker 容器里运行？"></a>为什么说数据库不适合放在 Docker 容器里运行？</h3><p>不为什么，<strong>因为这个说法不对</strong>，大部分认为数据库必须放到容器外运行的人根本不知道 <code>Docker Volume</code> 为何物。</p>
<p>在早年 Docker 没有 <code>Docker Volume</code> 的时候，其数据持久化是一个问题，但是这已经很多年过去了。现在有 <code>Docker Volume</code> 解决持久化问题，从本地目录绑定、受控存储空间、块设备、网络存储到分布式存储，<code>Docker Volume</code> 都支持，不存在数据读写类的服务不适于运行于容器内的说法。</p>
<p>Docker 不是虚拟机，使用数据卷是直接向宿主写入文件，不存在性能损耗。而且卷的生存周期独立于容器，容器消亡卷不消亡，重新运行容器可以挂载指定命名卷，数据依然存在，也不存在无法持久化的问题。</p>
<p>建议去阅读一下官方文档：</p>
<ul>
<li><a href="https://docs.docker.com/engine/tutorials/dockervolumes/" target="_blank" rel="noopener">https://docs.docker.com/engine/tutorials/dockervolumes/</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/volume_create/</a></li>
<li><a href="https://docs.docker.com/engine/extend/legacy_plugins/#/volume-plugins" target="_blank" rel="noopener">https://docs.docker.com/engine/extend/legacy_plugins/#/volume-plugins</a></li>
</ul>
<h3 id="如何列出容器和所使用的卷的关系？"><a href="#如何列出容器和所使用的卷的关系？" class="headerlink" title="如何列出容器和所使用的卷的关系？"></a>如何列出容器和所使用的卷的关系？</h3><p>要感谢强大的 <code>Go Template</code>，可以使用下面的命令来显示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125; =&gt; &#123;&#123;with .Mounts&#125;&#125;&#123;&#123;range .&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125;,&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;'</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>
<p><em>注意这里的换行和空格是有意如此的</em>，这样就可以再返回结果控制缩进格式。其结果将是如下形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125; =&gt; &#123;&#123;with .Mounts&#125;&#125;&#123;&#123;range .&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;.Name&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;'</span> $(docker ps -aq)</span><br><span class="line">/device_api_1 =&gt;</span><br><span class="line">/device_dashboard-debug_1 =&gt;</span><br><span class="line">/device_redis_1 =&gt;</span><br><span class="line">    device_redis-data</span><br><span class="line">/device_mongo_1 =&gt;</span><br><span class="line">    device_mongo-data</span><br><span class="line">    61453e46c3409f42e938324d7feffc6aeb6b7ce16d2080566e3b128c910c9570</span><br><span class="line">/prometheus_prometheus_1 =&gt;</span><br><span class="line">    fc0185ed3fc637295de810efaff7333e8ff2f6050d7f9368a22e19fb2c1e3c3f</span><br></pre></td></tr></table></figure>
<h2 id="镜像问题-17"><a href="#镜像问题-17" class="headerlink" title="镜像问题 (17)"></a>镜像问题 <code>(17)</code></h2><h3 id="docker-pull-下来的镜像文件都在哪？"><a href="#docker-pull-下来的镜像文件都在哪？" class="headerlink" title="docker pull 下来的镜像文件都在哪？"></a><code>docker pull</code> 下来的镜像文件都在哪？</h3><blockquote>
<p>初学 Docker 要反复告诫自己，<strong>Docker 不是虚拟机</strong>。</p>
</blockquote>
<p>Docker不是虚拟机，Docker 镜像也不是虚拟机的 ISO 文件。Docker 的镜像是分层存储，每一个镜像都是由很多层，很多个文件组成。而不同的镜像是共享相同的层的，所以这是一个树形结构，不存在具体哪个文件是 <code>pull</code> 下来的镜像的问题。</p>
<p>具体镜像保存位置取决于系统，一般<code>Linux</code>系统下，在 <code>/var/lib/docker</code> 里。对于使用 <code>Union FS</code> 的系统(<code>Ubuntu</code>)，如 <code>aufs</code>, <code>overlay2</code> 等，可以直接在 <code>/var/lib/docker/{aufs,overlay2}</code> 下看到找到各个镜像的层、容器的层，以及其中的内容。</p>
<p>但是，对于<code>CentOS</code>这类没有<code>Union FS</code>的系统，会使用如<code>devicemapper</code>这类东西的一些特殊功能(如<code>snapshot</code>)模拟，镜像会存储于块设备里，因此无法看到具体每层信息以及每层里面的内容。</p>
<p>需要注意的是，默认情况下，<code>CentOS/RHEL</code> 使用 <code>lvm-loop</code>，也就是本地稀疏文件模拟块设备，这个文件会位于 <code>/var/lib/docker/devicemapper/devicemapper/data</code> 的位置。这是非常不推荐的，如果发现这个文件很大，那就说明你在用 <code>devicemapper + loop</code> 的方式，不要这么做，去参照官方文档，换 <code>direct-lvm</code>，也就是分配真正的块设备给 <code>devicemapper</code> 去用。</p>
<h3 id="docker-images-命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？"><a href="#docker-images-命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？" class="headerlink" title="docker images 命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？"></a><code>docker images</code> 命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？</h3><p>这个显示的大小是计算后的大小，要知道 docker image 是分层存储的，在<code>1.10</code>之前，不同镜像无法共享同一层，所以基本上确实是下载大小。但是从<code>1.10</code>之后，已有的层（通过<code>SHA256</code>来判断），不需要再下载。只需要下载变化的层。所以实际下载大小比这个数值要小。而且本地硬盘空间占用，也比<code>docker images</code>列出来的东西加起来小很多，很多重复的部分共享了。</p>
<h3 id="docker-images-a-后显示了好多-lt-none-gt-的镜像？都是什么呀？能删么？"><a href="#docker-images-a-后显示了好多-lt-none-gt-的镜像？都是什么呀？能删么？" class="headerlink" title="docker images -a 后显示了好多 &lt;none&gt; 的镜像？都是什么呀？能删么？"></a><code>docker images -a</code> 后显示了好多 <code>&lt;none&gt;</code> 的镜像？都是什么呀？能删么？</h3><p>简单来说，<code>&lt;none&gt;</code> 就是说该镜像没有打标签。而没有打标签镜像一般分为两类，一类是<strong>依赖镜像</strong>，一类是<strong>丢了标签的镜像</strong>。</p>
<h4 id="依赖镜像"><a href="#依赖镜像" class="headerlink" title="依赖镜像"></a>依赖镜像</h4><p>Docker的镜像、容器的存储层是Union FS，分层存储结构。所以任何镜像除了最上面一层打上标签(tag)外，其它下面依赖的一层层存储也是存在的。这些镜像没有打上任何标签，所以在 <code>docker images -a</code> 的时候会以 <code>&lt;none&gt;</code> 的形式显示。注意观察一下 <code>docker pull</code> 的每一层的<code>sha256</code>的校验值，然后对比一下 <code>&lt;none&gt;</code> 中的相同校验值的镜像，它们就是依赖镜像。这些镜像<strong>不应当被删除</strong>，因为有标签镜像在依赖它们。</p>
<h4 id="丢了标签的镜像"><a href="#丢了标签的镜像" class="headerlink" title="丢了标签的镜像"></a>丢了标签的镜像</h4><p>这类镜像可能本来有标签，后来丢了。原因可能很多，比如：</p>
<ul>
<li><code>docker pull</code> 了一个同样标签但是新版本的镜像，于是该标签从旧版本的镜像转移到了新版本镜像上，那么旧版本的镜像上的标签就丢了；</li>
<li><code>docker build</code> 时指定的标签都是一样的，那么新构建的镜像拥有该标签，而之前构建的镜像就丢失了标签。</li>
</ul>
<p>这类镜像被称为 <code>dangling</code> - 虚悬镜像。这些镜像可以删除，手动删除 dangling 镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<p>对于 1.13 以前的老版本，使用 <code>dangling=true</code> 过滤条件即可。可以使用命令：<code>docker rmi $(docker images -aq -f &quot;dangling=true&quot;)</code></p>
<p>对于频繁构建的机器，比如 Jenkins 之类的环境。手动清理显然不是好的办法，应该定期执行固定脚本来清理这些无用的镜像。很幸运，Spotify 也面临了同样的问题，他们已经写了一个开源工具来做这件事情：<a href="https://github.com/spotify/docker-gc" target="_blank" rel="noopener">https://github.com/spotify/docker-gc</a></p>
<h3 id="为什么-Docker-Hub-的镜像尺寸和-docker-images-不一致？"><a href="#为什么-Docker-Hub-的镜像尺寸和-docker-images-不一致？" class="headerlink" title="为什么 Docker Hub 的镜像尺寸和 docker images 不一致？"></a>为什么 Docker Hub 的镜像尺寸和 <code>docker images</code> 不一致？</h3><p>Docker Hub上显示的是经过 <code>gzip</code> 压缩后的镜像大小，这个大小也是你将下载的镜像大小，一般来说也是 Docker Hub 用户最关心的大小。</p>
<p>而 <code>docker images</code> 显示的是<code>pull</code>下来并解压缩后的大小，因为使用<code>docker images</code>的时候更关心的是本地磁盘空间占用的大小，所以这里显示的是未压缩镜像的大小。</p>
<h3 id="docker-commit-怎么用啊？"><a href="#docker-commit-怎么用啊？" class="headerlink" title="docker commit 怎么用啊？"></a><code>docker commit</code> 怎么用啊？</h3><p>简单的回答就是，不要用 <code>commit</code>，去写 <code>Dockerfile</code>。</p>
<blockquote>
<p>Docker 不是虚拟机。这句话要在学习 Docker 的过程中反复提醒自己。所以不要把虚拟机中的一些概念带过来。</p>
</blockquote>
<p>Docker 提供了很好的 <code>Dockerfile</code> 的机制来帮助定制镜像，可以直接使用 Shell 命令，非常方便。而且，这样制作的镜像更加透明，也容易维护，在基础镜像升级后，可以简单地重新构建一下，就可以继承基础镜像的安全维护操作。</p>
<p>使用 <code>docker commit</code> 制作的镜像被称为<code>黑箱镜像</code>，换句话说，就是里面进行的是黑箱操作，除本人外无人知晓。即使这个制作镜像的人，过一段时间后也不会完整的记起里面的操作。那么当有些东西需要改变时，或者因基础镜像更新而需要重新制作镜像时，会让一切变得异常困难，就如同重新安装调试配置服务器一样，失去了 Docker 的优势了。</p>
<p>另外，Docker 不是虚拟机，其文件系统是 Union FS，分层式存储，每一次 <code>commit</code> 都会建立一层，上一层的文件并不会因为 <code>rm</code> 而删除，只是在当前层标记为删除而看不到了而已，每次 <code>docker pull</code> 的时候，那些不必要的文件都会如影随形，所得到的镜像也必然臃肿不堪。而且，随着文件层数的增加，不仅仅镜像更臃肿，其运行时性能也必然会受到影响。这一切都违背了 Docker 的最佳实践。</p>
<p>使用 <code>commit</code> 的场合是一些特殊环境，比如入侵后保存现场等等，这个命令不应该成为定制镜像的标准做法。所以，请用 <code>Dockerfile</code> 定制镜像。</p>
<h3 id="为什么说不要使用-import-export-save-load-commit-来构建镜像？"><a href="#为什么说不要使用-import-export-save-load-commit-来构建镜像？" class="headerlink" title="为什么说不要使用 import, export, save, load, commit 来构建镜像？"></a>为什么说不要使用 <code>import</code>, <code>export</code>, <code>save</code>, <code>load</code>, <code>commit</code> 来构建镜像？</h3><p><code>commit</code> 命令在前一个问答已经说过，这是制作<strong>黑箱镜像</strong>，无法维护，不应该被使用。</p>
<p><code>import</code> 和 <code>export</code> 的做法，实际上是将一个<em>容器</em>来保存为 <code>tar</code> 文件，然后在导入为<em>镜像</em>。这样制作的镜像同样是<strong>黑箱镜像</strong>，不应该使用。而且这类导入导出会导致原有分层丢失，合并为一层，而且会丢失很多相关镜像元数据或者配置，比如 <code>CMD</code> 命令就可能丢失，导致镜像无法直接启动。</p>
<p><code>save</code> 和 <code>load</code> 确实是镜像保存和加载，但是这是在没有 <code>registry</code> 的情况下，手动把镜像考来考去，这是回到了十多年的 U 盘时代😭。这同样是不推荐的，镜像的发布、更新维护应该使用 <code>registry</code>。无论是自己架设私有 <code>registry</code> 服务，还是使用公有 <code>registry</code> 服务，如 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>。</p>
<h3 id="Dockerfile-怎么写？"><a href="#Dockerfile-怎么写？" class="headerlink" title="Dockerfile 怎么写？"></a><code>Dockerfile</code> 怎么写？</h3><p>最直接也是最简单的办法是看官方文档。</p>
<p>这篇文章讲述具体 <code>Dockerfile</code> 的命令语法：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
<p>然后，学习一下官方的 <code>Dockerfile</code> 最佳实践：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></p>
<p>最后，去 Docker Hub 学习那些<strong><a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">官方(Official)镜像</a></strong> <code>Dockerfile</code> 咋写的。</p>
<h3 id="Dockerfile-就是-shell-脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。"><a href="#Dockerfile-就是-shell-脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。" class="headerlink" title="Dockerfile 就是 shell 脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。"></a><code>Dockerfile</code> 就是 <code>shell</code> 脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。</h3><p>不是这样的。</p>
<blockquote>
<p><code>Dockerfile</code> 不等于 <code>.sh</code> 脚本</p>
</blockquote>
<p><code>Dockerfile</code> 确实是描述如何构建镜像的，其中也提供了 <code>RUN</code> 这样的命令，可以运行 shell 命令。但是和普通 shell 脚本还有很大的不同。</p>
<p><code>Dockerfile</code> 描述的实际上是镜像的每一层要如何构建，所以每一个<code>RUN</code>是一个独立的一层。所以一定要理解“分层存储”的概念。上一层的东西不会被物理删除，而是会保留给下一层，下一层中可以指定删除这部分内容，但实际上只是这一层做的某个标记，说这个路径的东西删了。但实际上并不会去修改上一层的东西。每一层都是静态的，这也是容器本身的 <code>immutable</code> 特性，要保持自身的静态特性。</p>
<p>所以很多新手会常犯下面这样的错误，把 <code>Dockerfile</code> 当做 shell 脚本来写了：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误案例</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum update</span></span><br><span class="line"><span class="bash">RUN yum -y install gcc</span></span><br><span class="line"><span class="bash">RUN yum -y install python </span></span><br><span class="line"><span class="bash">ADD jdk-xxxx.tar.gz /tmp</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">cd</span> xxxx &amp;&amp; install</span></span><br><span class="line"><span class="bash">RUN xxx &amp;&amp; configure &amp;&amp; make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<p>这是相当错误的。除了无畏的增加了很多层，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<p>正确的写法应该是把<strong>同一个任务的命令</strong>放到一个 <code>RUN</code> 下，多条命令应该用 <code>&amp;&amp;</code> 连接，并且在最后要打扫干净所使用的环境，因为每执行一次<code>RUN</code>j就多加了一层镜像。比如下面这段摘自官方 <code>redis</code> 镜像 <code>Dockerfile</code> 的部分：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">set</span> -x \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> --no-install-recommends \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">"<span class="variable">$REDIS_DOWNLOAD_URL</span>"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"<span class="variable">$REDIS_DOWNLOAD_SHA1</span> *redis.tar.gz"</span> | sha1sum -c - \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure>
<h3 id="那我把所有命令都合并到一个-RUN-就对了吧？"><a href="#那我把所有命令都合并到一个-RUN-就对了吧？" class="headerlink" title="那我把所有命令都合并到一个 RUN 就对了吧？"></a>那我把所有命令都合并到一个 <code>RUN</code> 就对了吧？</h3><p>不是把所有命令都合为一个 <code>RUN</code>，要合理分层，以加快构建和部署。</p>
<blockquote>
<p>合理分层就是将具有<strong>不同变更频繁程度</strong>的层，进行拆分，让稳定的部分在基础，更容易变更的部分在表层，使得资源可以重复利用，以增加构建和部署的速度。</p>
</blockquote>
<p>以 <a href="https://coding.net/u/twang2218/p/docker-example/git/blob/master/node/Dockerfile" target="_blank" rel="noopener"><code>node.js</code> 的应用示例镜像</a>为例，其中的复制应用和安装依赖的部分，如果都合并一起，会写成这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> . /usr/src/app</span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br></pre></td></tr></table></figure>
<p>但是，在 <code>node.js</code> 应用镜像示例中，则是这么写的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash">COPY . /usr/src/app</span></span><br></pre></td></tr></table></figure>
<p>从层数上看，确实多了一层。但实际上，这三行分开是故意这样做的，其目的就是合理分层，充分利用 Docker 分层存储的概念，以增加构建、部署的效率。</p>
<p>在 <code>docker build</code> 的构建过程中，如果某层之前构建过，而且该层未发生改变的情况下，那么 <code>docker</code> 就会<strong>直接使用缓存</strong>，不会重复构建。因此，合理分层，充分利用缓存，会显著加速构建速度。</p>
<p>第一行的目的是将 <code>package.json</code> 复制到应用目录，而不是整个应用代码目录。这样只有 <code>pakcage.json</code> 发生改变后，才会触发第二行 <code>RUN npm install</code>。而只要 <code>package.json</code> 没有变化，那么应用的代码改变就不会引发 <code>npm install</code>，只会引发第三行的 <code>COPY . /usr/src/app</code>，从而加快构建速度。</p>
<p>而如果按照前面所提到的，合并为两层，那么任何代码改变，都会触发 <code>RUN npm install</code>，从而浪费大量的带宽和时间。</p>
<p>合理分层除了可以加快构建外，还可以加快部署，要知道，<code>docker pull</code> 的时候，是分层下载的，并且已存在的层就<strong>不会重复下载</strong>。</p>
<p>比如，这里的 <code>RUN npm install</code> 这一层，往往会几百 MB 甚至上 GB。而在 <code>package.json</code> 未发生变更的情况下，那么只有 <code>COPY . /usr/src/app</code> 这一层会被重新构建，并且也只有这一层会在各个节点 <code>docker pull</code> 的过程中重新下载，往往这一层的代码量只有几十 MB，甚至更小。这对于大规模的并行部署中，所节约的东西向流量是非常显著的。特别是敏捷开发环境中，代码变更的频繁度要比依赖变更的频繁度高很多，每次重复下载依赖，会导致不必要的流量和时间上的浪费。</p>
<h3 id="context-到底是一个什么概念？"><a href="#context-到底是一个什么概念？" class="headerlink" title="context 到底是一个什么概念？"></a><code>context</code> 到底是一个什么概念？</h3><p><code>context</code>，<strong>上下文</strong>，是 <code>docker build</code> 中很重要的一个概念。构建镜像必须指定 <code>context</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xxx &lt;context路径&gt;</span><br></pre></td></tr></table></figure>
<p>或者 <code>docker-compose.yml</code> 中的</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">        context:</span> <span class="string">&lt;context路径&gt;</span></span><br><span class="line"><span class="attr">        dockerfile:</span> <span class="string">dockerfile</span></span><br></pre></td></tr></table></figure>
<p>这里都需要指定 <code>context</code>。</p>
<p><code>context</code> 是工作目录，但不要和构建镜像的<code>Dockerfile</code> 中的 <code>WORKDIR</code> 弄混，<code>context</code> 是 <code>docker build</code> 命令的工作目录。</p>
<p><code>docker build</code> 命令实际上是客户端，真正构建镜像并非由该命令直接完成。<code>docker build</code> 命令将 <code>context</code> 的目录上传给 <code>Docker</code> 引擎，由它负责制作镜像。</p>
<p>在 Dockerfile 中如果写 <code>COPY ./package.json /app/</code> 这种命令，实际的意思并不是指执行 <code>docker build</code> 所在的目录下的 <code>package.json</code>，也不是指 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是指 <code>context</code> 目录下的 <code>package.json</code>。</p>
<p>这就是为什么有人发现 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为它们都在 <code>context</code> 之外，如果真正需要，应该将它们复制到 <code>context</code> 目录下再操作。</p>
<p>话说，有一些网文甚至搞笑的说要把 <code>Dockerfile</code> 放到磁盘根目录，才能构建如何如何。这都是对 <code>context</code> 完全不了解的表现。想象一下把整个磁盘<strong>几十个 GB</strong>当做上下文发送给 <code>dockerd</code> 引擎的情况，😱……</p>
<p><code>docker build -t xxx .</code> 中的这个<code>.</code>，实际上就是在指定 <code>Context</code> 的目录，而并非是指定 <code>Dockerfile</code> 所在目录。</p>
<p>默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将 <code>Context</code> 下的名为 <code>Dockerfile</code> 的文件作为 <code>Dockerfile</code>。所以很多人会混淆，认为这个 <code>.</code> 是在说 <code>Dockerfile</code> 的位置，其实不然。</p>
<p>一般项目中，<code>Dockerfile</code> 可能被放置于两个位置。</p>
<ul>
<li>一个可能是放置于项目顶级目录，这样的好处是在顶级目录构建时，项目所有内容都在上下文内，方便构建；</li>
<li>另一个做法是，将所有 Docker 相关的内容集中于某个目录，比如 <code>docker</code> 目录，里面包含所有不同分支的 <code>Dockerfile</code>，以及 <code>docker-compose.yml</code> 类的文件、entrypoint 的脚本等等。这种情况的上下文所在目录不再是 <code>Dockerfile</code> 所在目录了，因此需要注意指定上下文的位置。</li>
</ul>
<p>此外，项目中可能会包含一些构建不需要的文件，这些文件不应该被发送给 <code>dockerd</code> 引擎，但是它们处于上下文目录下，这种情况，我们需要使用 <code>.dockerignore</code> 文件来过滤不必要的内容。<code>.dockerignore</code> 文件应该放置于上下文顶级目录下，内容格式和 <code>.gitignore</code> 一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp</span><br><span class="line">db</span><br></pre></td></tr></table></figure>
<p>这样就过滤了 <code>tmp</code> 和 <code>db</code> 目录，它们不会被作为上下文的一部分发给 <code>dockerd</code> 引擎。</p>
<blockquote>
<p>如果你发现你的 <code>docker build</code> 需要发送庞大的 Context 的时候，就需要来检查是不是 <code>.dockerignore</code> 忘了撰写，或者忘了过滤某些东西了。</p>
</blockquote>
<h3 id="ENTRYPOINT-和-CMD-到底有什么不同？"><a href="#ENTRYPOINT-和-CMD-到底有什么不同？" class="headerlink" title="ENTRYPOINT 和 CMD 到底有什么不同？"></a><code>ENTRYPOINT</code> 和 <code>CMD</code> 到底有什么不同？</h3><p><code>Dockerfile</code> 的目的是制作镜像，换句话说，实际上是准备的是主进程运行环境。那么准备好后，需要执行一个程序才可以启动主进程，而启动的办法就是调用 <code>ENTRYPOINT</code>，并且把 <code>CMD</code> 作为参数传进去运行。也就是下面的概念：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT <span class="string">"CMD"</span></span><br></pre></td></tr></table></figure>
<p>假设有个 <code>myubuntu</code> 镜像 <code>ENTRYPOINT</code> 是 <code>sh -c</code>，而我们 <code>docker run -it myubuntu uname -a</code>。那么 <code>uname -a</code> 就是运行时指定的 <code>CMD</code>，那么 Docker 实际运行的就是结合起来的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"uname -a"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有指定 <code>ENTRYPOINT</code>，那么就只执行 <code>CMD</code>；</li>
<li>如果指定了 <code>ENTRYPOINT</code> 而没有指定 <code>CMD</code>，自然执行 <code>ENTRYPOINT</code>;</li>
<li>如果 <code>ENTRYPOINT</code> 和 <code>CMD</code> 都指定了，那么就如同上面所述，执行 <code>ENTRYPOINT &quot;CMD&quot;</code>；</li>
<li>如果没有指定 <code>ENTRYPOINT</code>，而 <code>CMD</code> 用的是上述那种 shell 命令的形式，则自动使用 <code>sh -c</code> 作为 <code>ENTRYPOINT</code>。</li>
</ul>
<p>注意最后一点的区别，这个区别导致了同样的命令放到 <code>CMD</code> 和 <code>ENTRYPOINT</code> 下效果不同，因此有可能放在 <code>ENTRYPOINT</code> 下的同样的命令，由于需要 <code>tty</code> 而运行时忘记了给（比如忘记了<code>docker-compose.yml</code> 的 <code>tty:true</code>）导致运行失败。</p>
<p>这种用法可以很灵活，比如我们做个 <code>git</code> 镜像，可以把 <code>git</code> 命令指定为 <code>ENTRYPOINT</code>，这样我们在 <code>docker run</code> 的时候，直接跟子命令即可。比如 <code>docker run git log</code> 就是显示日志。</p>
<h3 id="拿到一个镜像，如何获得镜像的-Dockerfile-？"><a href="#拿到一个镜像，如何获得镜像的-Dockerfile-？" class="headerlink" title="拿到一个镜像，如何获得镜像的 Dockerfile ？"></a>拿到一个镜像，如何获得镜像的 <code>Dockerfile</code> ？</h3><ul>
<li>直接去 Docker Hub 上看：大多数 Docker Hub 上的镜像都会有 <code>Dockerfile</code>，直接在 Docker Hub 的镜像页面就可以看到 <code>Dockerfile</code> 的链接；</li>
<li>如果是自己公司做的，最简单的办法就是打个电话、发个消息问一下。别看这个说法看起来很傻，不少人都宁可自己琢磨也不去问；</li>
<li>如果没有 <code>Dockerfile</code>，一般这类镜像就不应该考虑使用了，这类黑箱似的镜像很容有有问题。如果是什么特殊原因，那继续往下看；</li>
<li><code>docker history</code> 可以看到镜像每一层的信息，包括命令，当然黑箱镜像的 <code>commit</code> 看不见操作；</li>
<li><code>docker inspect</code> 可以分析镜像很多细节。</li>
<li>直接运行镜像，进入<code>shell</code>，然后根据上面的分析结果去进一步分析日志、文件内容及变化。</li>
<li>经过分析后，自己写 <code>Dockerfile</code> 还原操作。</li>
</ul>
<h3 id="在你的-LNMP-的例子中，PHP-的-Dockerfile-里面的-“构建依赖”-和-“运行依赖”-都是什么意思？"><a href="#在你的-LNMP-的例子中，PHP-的-Dockerfile-里面的-“构建依赖”-和-“运行依赖”-都是什么意思？" class="headerlink" title="在你的 LNMP 的例子中，PHP 的 Dockerfile 里面的 “构建依赖” 和 “运行依赖” 都是什么意思？"></a>在你的 LNMP 的例子中，PHP 的 <code>Dockerfile</code> 里面的 “构建依赖” 和 “运行依赖” 都是什么意思？</h3><p>这里所提到的是我的那个 LNMP 例子的 <code>php</code> 服务的 <code>Dockerfile</code>：<a href="https://coding.net/u/twang2218/p/docker-lnmp/git/blob/master/php/Dockerfile" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git/blob/master/php/Dockerfile</a></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> php:<span class="number">7</span>-fpm</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -xe \</span></span><br><span class="line"><span class="bash"><span class="comment"># "构建依赖"</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; buildDeps=<span class="string">" \</span></span></span><br><span class="line"><span class="bash">        build-essential \</span></span><br><span class="line"><span class="bash">        php5-dev \</span></span><br><span class="line"><span class="bash">        libfreetype6-dev \</span></span><br><span class="line"><span class="bash">        libjpeg62-turbo-dev \</span></span><br><span class="line"><span class="bash">        libmcrypt-dev \</span></span><br><span class="line"><span class="bash">        libpng12-dev \</span></span><br><span class="line"><span class="bash">    <span class="string">" \</span></span></span><br><span class="line"><span class="bash"><span class="comment"># "运行依赖"</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; runtimeDeps=<span class="string">" \</span></span></span><br><span class="line"><span class="bash">        libfreetype6 \</span></span><br><span class="line"><span class="bash">        libjpeg62-turbo \</span></span><br><span class="line"><span class="bash">        libmcrypt4 \</span></span><br><span class="line"><span class="bash">        libpng12-0 \</span></span><br><span class="line"><span class="bash">    <span class="string">" \</span></span></span><br><span class="line"><span class="bash"><span class="comment"># "安装 php 以及编译构建组件所需包"</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$&#123;runtimeDeps&#125;</span> <span class="variable">$&#123;buildDeps&#125;</span> --no-install-recommends \</span></span><br><span class="line"><span class="bash"><span class="comment"># "编译安装 php 组件"</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; docker-php-ext-install iconv mcrypt mysqli pdo pdo_mysql zip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; docker-php-ext-configure gd \</span></span><br><span class="line"><span class="bash">        --with-freetype-dir=/usr/include/ \</span></span><br><span class="line"><span class="bash">        --with-jpeg-dir=/usr/include/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; docker-php-ext-install gd \</span></span><br><span class="line"><span class="bash"><span class="comment"># "清理"</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove \</span></span><br><span class="line"><span class="bash">        -o APT::AutoRemove::RecommendsImportant=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">        -o APT::AutoRemove::SuggestsImportant=<span class="literal">false</span> \</span></span><br><span class="line"><span class="bash">        <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/cache/apt/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>
<p>这里是针对 <code>php</code> 镜像进行定制，默认情况下 <code>php:7-fpm</code> 中没有安装所需的 <code>mysqli</code>, <code>pdo_mysql</code>, <code>gd</code> 等组件，所以这里需要安装，而且，部分组件还需要编译。</p>
<p>因此，这里涉及了两类依赖库/工具，一类是安装、编译阶段所需要的依赖；另一类是运行时所需的依赖。要记住 <code>Dockerfile</code> 的最佳实践中要求最终镜像只应该保留最小的所需依赖，因此安装构建的依赖应该在安装结束后清除，这一层只保留真正需要的运行时依赖。</p>
<p>因此，遵循最佳实践的要求，这里区分了 <code>buildDeps</code> 和 <code>runtimeDeps</code> 后，可以在安装结束后，卸载、清理 <code>buildDeps</code> 的依赖。这样确保没有无关的东西还在该层中。</p>
<h3 id="应用代码是应该挂载宿主目录还是放入镜像内？"><a href="#应用代码是应该挂载宿主目录还是放入镜像内？" class="headerlink" title="应用代码是应该挂载宿主目录还是放入镜像内？"></a>应用代码是应该挂载宿主目录还是放入镜像内？</h3><p>两种方法都可以。</p>
<p>如果代码变动非常频繁，比如开发阶段，代码几乎每几分钟就需要变动调试，这种情况可以使用 <code>--volume</code> 挂载宿主目录的办法。这样不用每次构建新镜像，直接再次运行就可以加载最新代码，甚至有些工具可以观察文件变化从而动态加载，这样可以提高开发效率。</p>
<p>如果代码没有那么频繁变动，比如发布阶段，这种情况，应该将构建好的应用放入镜像。一般来说是使用 CI/CD 工具，如 <code>Jenkins</code>, <code>Drone.io</code>, <code>Gitlab CI</code> 等，进行构建、测试、制作镜像、发布镜像、以及分步发布上线。</p>
<p>对于配置文件也是同样的道理，如果是频繁变更的配置，可以挂载宿主，或者动态配置文件可以使用卷。但是对于并非频繁变更的配置文件，应该将其纳入版本控制中，走 CI/CD 流程进行部署。</p>
<p>需要注意的一点是，绑定宿主目录虽然方便，但是不利于集群部署，因为集群部署前还需要确保集群各个节点同步存在所挂载的目录及其内容。因此集群部署更倾向于将应用打入镜像，方便部署。</p>
<h3 id="为什么在-Dockerfile-中执行（导入-sql、service-xxx-start）不管用？"><a href="#为什么在-Dockerfile-中执行（导入-sql、service-xxx-start）不管用？" class="headerlink" title="为什么在 Dockerfile 中执行（导入 .sql、service xxx start）不管用？"></a>为什么在 <code>Dockerfile</code> 中执行（导入 <code>.sql</code>、<code>service xxx start</code>）不管用？</h3><p>这是典型的对 <code>Dockerfile</code> 以及镜像、容器的基本概念不了解。</p>
<blockquote>
<p><code>Dockerfile</code> 不是 <code>shell</code> 脚本，而是定制 <code>rootfs</code> 的脚本。它并不是在运行时运行的，而是在构建时运行的。</p>
</blockquote>
<p>导入 <code>.sql</code> 文件到数据库，实际上修改的是数据库数据文件，而数据库的数据文件存储于卷，默认为匿名卷，因此当导入行为结束后，构建该层的容器停止运行，匿名卷被抛弃，所有导入行为都会丢失，因此所谓的导入 <code>.sql</code> 的行为在 <code>Dockerfile</code> 里实际上完全没有意义。</p>
<p>而 <code>service xxxx start</code> 也完全没有意义，这是启动后台服务在传统虚拟机使用的命令，而Docker镜像为了达到精简在后台做了很多删减，且不说 Docker 中不用后台服务，这种启动行为对文件系统根本没影响，这仅仅是让后台在构建所用的容器中运行一下，完全没有意义。最后运行容器的时候，是另一个进程了，该没启动的东西还是不会启动。</p>
<p>但是不要因此就盲目的得出 <code>Dockerfile</code> 无法初始化数据库的结论。所有官方镜像都考虑到了定制的问题，去看特定官方镜像的文档，基本都会看到定制、初始化的方法。</p>
<p>比如官方 <code>mysql</code> 镜像中，可以把初始化的 <code>.sql</code> 脚本文件在 <code>Dockerfile</code> 中 <code>COPY</code> 至 <code>/docker-entrypoint-initdb.d/</code> 目录中，在容器第一次运行的时候，如果所挂载的卷是空的，那么就会依次<a href="https://github.com/docker-library/mysql/blob/4dd33136c4739667a223d39b6f829beb27b235cf/5.7/docker-entrypoint.sh#L151" target="_blank" rel="noopener">执行该目录中的文件</a>，从而完成数据库初始化、导入等功能。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> mysql-data-backup.sql /docker-entrypoint-initdb.d/</span></span><br></pre></td></tr></table></figure>
<h3 id="为什么基于-Alpine-的镜像那么小？我可以都换成基于-Alpine-的镜像么？"><a href="#为什么基于-Alpine-的镜像那么小？我可以都换成基于-Alpine-的镜像么？" class="headerlink" title="为什么基于 Alpine 的镜像那么小？我可以都换成基于 Alpine 的镜像么？"></a>为什么基于 Alpine 的镜像那么小？我可以都换成基于 Alpine 的镜像么？</h3><p><code>Alpine Linux</code> 体积小是因为它所使用的基础命令来自精简的 <code>busybox</code>，并且它使用的是简化实现的 <code>musl</code> 作为库支持，而并非完整的 <code>glibc</code>。<code>musl</code> 体积小，但是有可能有不兼容的情况，因此一般不用 <code>Alpine</code> 的镜像，除非空间受限，体积大小很关键时才会使用。</p>
<p>过去出现过兼容问题，但是随着 <code>Docker</code> 的使用，对 <code>Alpine</code> 的需求会越来越多，更多的兼容问题会被发现、修复，所以相信在未来这应该是个不错的选择。但是如果现在就要使用，一定要进行重复的测试，确保没有会影响到自己的 <code>bug</code>。</p>
<h3 id="可以看到镜像各层的依赖关系么？"><a href="#可以看到镜像各层的依赖关系么？" class="headerlink" title="可以看到镜像各层的依赖关系么？"></a>可以看到镜像各层的依赖关系么？</h3><p>镜像是分层存储的，镜像之间也可以依赖，因此利用 Docker 镜像很容易实现重复的部分复用。那么我们有没有办法可以可视化的看到镜像的依赖关系呢？</p>
<p>很早以前，Docker 有个 <code>docker images --tree</code> 的命令的，后来随着镜像分层平面化后，这个命令就取消了。幸运的是，Nate Jones 写了一个工具，用于可视化镜像分层依赖，叫做 <strong>dockviz</strong>：<a href="https://github.com/justone/dockviz" target="_blank" rel="noopener">https://github.com/justone/dockviz</a></p>
<p>对于 Mac 平台的用户，可以很方便的使用 <code>brew</code> 来进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install dockviz</span><br></pre></td></tr></table></figure>
<p>对于其它平台的用户，可以直接去<a href="https://github.com/justone/dockviz/releases" target="_blank" rel="noopener">发布页面</a>下载。</p>
<p>安装好后，直接执行 <code>dockviz images --tree</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ dockviz images --tree</span><br><span class="line">├─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│ └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│   └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│     └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│       └─&lt;missing&gt; Virtual Size: 55.3 MB</span><br><span class="line">│         └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│           └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│             └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│               └─&lt;missing&gt; Virtual Size: 108.3 MB</span><br><span class="line">│                 └─0b5dec81616c Virtual Size: 108.3 MB Tags: nginx:latest</span><br><span class="line">└─&lt;missing&gt; Virtual Size: 100.1 MB</span><br><span class="line">  └─&lt;missing&gt; Virtual Size: 100.1 MB</span><br><span class="line">    └─&lt;missing&gt; Virtual Size: 123.9 MB</span><br><span class="line">      └─&lt;missing&gt; Virtual Size: 131.2 MB</span><br><span class="line">        ├─&lt;missing&gt; Virtual Size: 272.8 MB</span><br><span class="line">        │ └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │   └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │     └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │       └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │         └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │           └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │             └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │               └─&lt;missing&gt; Virtual Size: 274.2 MB</span><br><span class="line">        │                 └─&lt;missing&gt; Virtual Size: 737.9 MB</span><br><span class="line">        │                   └─4551430cfe80 Virtual Size: 738.3 MB Tags: openjdk:latest</span><br><span class="line">        └─&lt;missing&gt; Virtual Size: 132.4 MB</span><br><span class="line">          └─&lt;missing&gt; Virtual Size: 132.4 MB</span><br><span class="line">            └─&lt;missing&gt; Virtual Size: 132.4 MB</span><br><span class="line">...</span><br><span class="line">                            └─&lt;missing&gt; Virtual Size: 276.0 MB</span><br><span class="line">                                └─&lt;missing&gt; Virtual Size: 292.4 MB</span><br><span class="line">                                └─&lt;missing&gt; Virtual Size: 292.4 MB</span><br><span class="line">                                    └─&lt;missing&gt; Virtual Size: 292.4 MB</span><br><span class="line">                                    └─72d2be374029 Virtual Size: 292.4 MB Tags: tomcat:latest</span><br></pre></td></tr></table></figure>
<p>如果觉得文本格式太繁杂，也可以生成 <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language" target="_blank" rel="noopener">DOT 图</a>)，使用命令 <code>dockviz images -d | dot -Tpng -o image_tree.png</code> 就可以将你的镜像依赖关系绘制成图（<a href="https://imagebin.ca/v/3ZhFvSPeqAi0" target="_blank" rel="noopener">https://imagebin.ca/v/3ZhFvSPeqAi0</a>）。</p>
<h2 id="日志问题-2"><a href="#日志问题-2" class="headerlink" title="日志问题 (2)"></a>日志问题 <code>(2)</code></h2><h3 id="Docker-日志都在哪里？怎么收集？"><a href="#Docker-日志都在哪里？怎么收集？" class="headerlink" title="Docker 日志都在哪里？怎么收集？"></a>Docker 日志都在哪里？怎么收集？</h3><p>日志分两类，一类是 <code>Docker 引擎日志</code>；另一类是 <code>容器日志</code>。</p>
<h4 id="Docker-引擎日志"><a href="#Docker-引擎日志" class="headerlink" title="Docker 引擎日志"></a>Docker 引擎日志</h4><p><code>Docker 引擎日志</code> 一般是交给了 <code>Upstart</code>(Ubuntu 14.04) 或者 <code>systemd</code> (CentOS 7, Ubuntu 16.04)。前者一般位于 <code>/var/log/upstart/docker.log</code> 下，后者一般通过 <code>jounarlctl -u docker</code> 来读取。不同系统的位置都不一样，SO上有人总结了一份列表，我修正了一下，可以参考：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统</th>
<th>日志位置</th>
</tr>
</thead>
<tbody>
<tr>
<td> Ubuntu(14.04)</td>
<td><code>/var/log/upstart/docker.log</code></td>
</tr>
<tr>
<td> Ubuntu(16.04)</td>
<td><code>journalctl -u docker.service</code></td>
</tr>
<tr>
<td> CentOS 7/RHEL 7/Fedora</td>
<td><code>journalctl -u docker.service</code></td>
</tr>
<tr>
<td> CoreOS</td>
<td><code>journalctl -u docker.service</code></td>
</tr>
<tr>
<td> OpenSuSE</td>
<td><code>journalctl -u docker.service</code></td>
</tr>
<tr>
<td> OSX</td>
<td><code>~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/log/d‌​ocker.log</code></td>
</tr>
<tr>
<td> Debian GNU/Linux 7</td>
<td><code>/var/log/daemon.log</code></td>
</tr>
<tr>
<td> Debian GNU/Linux 8</td>
<td><code>journalctl -u docker.service</code></td>
</tr>
<tr>
<td> Boot2Docker</td>
<td><code>/var/log/docker.log</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h4><p><code>容器的日志</code> 则可以通过 <code>docker logs</code> 命令来访问，而且可以像 <code>tail -f</code> 一样，使用 <code>docker logs -f</code> 来实时查看。如果使用 Docker Compose，则可以通过 <code>docker-compose logs &lt;服务名&gt;</code> 来查看。</p>
<p>如果深究其日志位置，每个容器的日志默认都会以 <code>json-file</code> 的格式存储于 <code>/var/lib/docker/containers/&lt;容器id&gt;/&lt;容器id&gt;-json.log</code> 下，不过并不建议去这里直接读取内容，因为 Docker 提供了更完善地日志收集方式 - <code>Docker 日志收集驱动</code>。</p>
<p>关于日志收集，<code>Docker</code> 内置了很多日志驱动，可以通过类似于 <code>fluentd</code>, <code>syslog</code> 这类服务收集日志。无论是 <code>Docker</code> 引擎，还是容器，都可以使用日志驱动。比如，如果打算用 <code>fluentd</code> 收集某个容器日志，可以这样启动容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    --<span class="built_in">log</span>-driver=fluentd \</span><br><span class="line">    --<span class="built_in">log</span>-opt fluentd-address=10.2.3.4:24224 \</span><br><span class="line">    --<span class="built_in">log</span>-opt tag=<span class="string">"docker.&#123;&#123;.Name&#125;&#125;"</span> \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure>
<p>其中 <code>10.2.3.4:24224</code> 是 <code>fluentd</code> 服务地址，实际环境中应该换成真实的地址。</p>
<p>具体使用 <code>fluentd</code> 的方法，请参考我写的一组 <code>fluentd</code> 日志收集的例子：</p>
<p><a href="https://coding.net/u/twang2218/p/docker-example/git/tree/master/fluentd" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-example/git/tree/master/fluentd</a></p>
<h3 id="不同容器的日志汇聚到-fluentd-后如何区分？"><a href="#不同容器的日志汇聚到-fluentd-后如何区分？" class="headerlink" title="不同容器的日志汇聚到 fluentd 后如何区分？"></a>不同容器的日志汇聚到 <code>fluentd</code> 后如何区分？</h3><p>有两种概念的区分，一种是区分开<code>不同容器</code>的日志，另一种是区分开来<code>不同服务</code>的日志。</p>
<p>区分不同容器的日志是很直观的想法。运行了几个不同的容器，日志都送向日志收集，那么显然不希望 <code>nginx</code> 容器的日志和 <code>MySQL</code> 容器的日志混杂在一起看。</p>
<p>但是在 Swarm 集群环境中，区分容器就已经不再是合理的做法了。因为同一个服务可能有许多副本，而又有很多个服务，如果一个个的容器区分去分析，很难看到一个整体上某个服务的服务状态是什么样子的。而且，容器是短生存周期的，在维护期间容器生存死亡是很常见的事情。如果是像传统虚拟机那样子以容器为单元去分析日志，其结果很难具有价值。因此更多的时候是对某一个服务的日志整体分析，无需区别日志具体来自于哪个容器，不需要关心容器是什么时间产生以及是否消亡，只需要以服务为单元去区分日志即可。</p>
<p>这两类的区分日志的办法，Docker 都可以做到，这里我们以 <code>fluentd</code> 为例说明。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.11-alpine</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"3000:80"</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">            section:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">            group:</span> <span class="string">alpha</span></span><br><span class="line"><span class="attr">            service:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">            image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">            base_os:</span> <span class="string">alpine</span></span><br><span class="line"><span class="attr">        logging:</span></span><br><span class="line"><span class="attr">            driver:</span> <span class="string">fluentd</span></span><br><span class="line"><span class="attr">            options:</span></span><br><span class="line"><span class="attr">                fluentd-address:</span> <span class="string">"localhost:24224"</span></span><br><span class="line"><span class="attr">                tag:</span> <span class="string">"frontend.web.nginx.<span class="template-variable">&#123;&#123;.Name&#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">                labels:</span> <span class="string">"section,group,service,image,base_os"</span></span><br></pre></td></tr></table></figure>
<p>这里我们运行了一个 <code>nginx:alpine</code> 的容器，服务名为 <code>web</code>。容器的日志使用 <code>fluentd</code> 进行收集，并且附上标签 <code>frontend.web.nginx.&lt;容器名&gt;</code>。除此以外，我们还定义了一组 <code>labels</code>，并且在 <code>logging</code> 的 <code>options</code> 中的 <code>labels</code> 中指明希望哪些标签随日志记录。这些信息中很多一部分都会出现在所收集的日志里。</p>
<p>让我们来看一下 <code>fluentd</code> 收到的信息什么样子的。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"frontend.web.nginx.service_web_1"</span>: &#123;</span><br><span class="line">    <span class="attr">"image"</span>: <span class="string">"nginx"</span>,</span><br><span class="line">    <span class="attr">"base_os"</span>: <span class="string">"alpine"</span>,</span><br><span class="line">    <span class="attr">"container_id"</span>: <span class="string">"f7212f7108de033045ddc22858569d0ac50921b043b97a2c8bf83b1b1ee50e34"</span>,</span><br><span class="line">    <span class="attr">"section"</span>: <span class="string">"frontend"</span>,</span><br><span class="line">    <span class="attr">"service"</span>: <span class="string">"web"</span>,</span><br><span class="line">    <span class="attr">"log"</span>: <span class="string">"172.20.0.1 - - [09/Dec/2016:15:02:45 +0000] \"GET / HTTP/1.1\" 200 612 \"-\" \"curl/7.49.1\" \"-\""</span>,</span><br><span class="line">    <span class="attr">"group"</span>: <span class="string">"alpha"</span>,</span><br><span class="line">    <span class="attr">"container_name"</span>: <span class="string">"/service_web_1"</span>,</span><br><span class="line">    <span class="attr">"source"</span>: <span class="string">"stdout"</span>,</span><br><span class="line">    <span class="attr">"remote"</span>: <span class="string">"172.20.0.1"</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"-"</span>,</span><br><span class="line">    <span class="attr">"user"</span>: <span class="string">"-"</span>,</span><br><span class="line">    <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/"</span>,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"200"</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="string">"612"</span>,</span><br><span class="line">    <span class="attr">"referer"</span>: <span class="string">"-"</span>,</span><br><span class="line">    <span class="attr">"agent"</span>: <span class="string">"curl/7.49.1"</span>,</span><br><span class="line">    <span class="attr">"forward"</span>: <span class="string">"-"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果去除 <code>nginx</code> 正常的访问日志项目外，我们就可以更清晰的看到有哪些元数据信息可以利用了。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"frontend.web.nginx.service_web_1"</span>: &#123;</span><br><span class="line">    <span class="attr">"image"</span>: <span class="string">"nginx"</span>,</span><br><span class="line">    <span class="attr">"base_os"</span>: <span class="string">"alpine"</span>,</span><br><span class="line">    <span class="attr">"container_id"</span>: <span class="string">"f7212f7108de033045ddc22858569d0ac50921b043b97a2c8bf83b1b1ee50e34"</span>,</span><br><span class="line">    <span class="attr">"section"</span>: <span class="string">"frontend"</span>,</span><br><span class="line">    <span class="attr">"service"</span>: <span class="string">"web"</span>,</span><br><span class="line">    <span class="attr">"group"</span>: <span class="string">"alpha"</span>,</span><br><span class="line">    <span class="attr">"container_name"</span>: <span class="string">"/service_web_1"</span>,</span><br><span class="line">    <span class="attr">"source"</span>: <span class="string">"stdout"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在 <code>logging</code> 下所有指定的 <code>labels</code> 都在。我们完全可以对每个服务设定不同的标签，通过标签来区分服务。比如这里，我们对 <code>web</code> 服务指定了 <code>service=web</code> 的标签，我们同样可以对数据库的服务设定标签为 <code>service=mysql</code>，这样在汇总后，只需要对 <code>service</code> 标签分组过滤即可，分离聚合不同服务的日志。</p>
<p>此外，我们可以设置不止一个标签，比如上面的例子，我们设置了多组不同颗粒度的标签，在后期分组的时候，可以很灵活的进行组合，以满足不同需求。</p>
<p>此外，注意 <code>frontend.web.nginx.service_web_1</code>，这是我们之前利用 <code>--log-opt tag=frontend.web.nginx.&lt;容器名&gt;</code> 进行设定的，其中 <code>&lt;容器名&gt;</code> 我们使用的是 Go 模板表达式 <em>&lbrace;&lbrace;.Name}}</em>。Go 模板很强大，我们可以用它实现非常复杂的标签。在 <code>fluentd</code> 中，<code>&lt;match&gt;</code> 项可以根据标签来进行筛选。</p>
<p>这里可以唯一表示容器的，有容器 ID <code>container_id</code>，而容器名 <code>container_name</code> 也从某种程度上可以用来区分不同容器。因此进行容器区分日志的时候，可以使用这两项。</p>
<p>还有一个 <code>source</code>，这表示了日志是从<code>标准输出</code>还是<code>标准错误输出</code>得到的，由此可以区分<code>正常日志</code>和<code>错误日志</code>。</p>
<p>现在我们可以知道，除了容器自身输出的信息外，Docker 还可以为每一个容器的日志添加很多元数据，以帮助后期的日志处理中应对不同需求的搜索和过滤。</p>
<p>在后期处理中，<code>fluentd</code> 中可以利用 <code>&lt;match&gt;</code> 或者 <code>&lt;filter&gt;</code> 插件根据 <code>tag</code> 或者其它元数据进行分别处理。而日志到了 ElasticSearch 这类系统后，则可以用更丰富的查询语言进行过滤、聚合。</p>
<h2 id="使用问题-11"><a href="#使用问题-11" class="headerlink" title="使用问题 (11)"></a>使用问题 <code>(11)</code></h2><h3 id="为什么容器一运行就退出啊？"><a href="#为什么容器一运行就退出啊？" class="headerlink" title="为什么容器一运行就退出啊？"></a>为什么容器一运行就退出啊？</h3><p>这是初学 Docker 常常碰到的问题，此时还以虚拟机来理解 Docker，认为启动 Docker 就是启动虚拟机，也没有搞明白前台和后台的区别。</p>
<p>首先，碰到这类问题应该查日志和容器主进程退出码。</p>
<p>检查容器日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器ID&gt;</span><br></pre></td></tr></table></figure>
<p>查看容器退出码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                           COMMAND             CREATED             STATUS                      PORTS                                                                  NAMES</span><br><span class="line">cc2aa3f4745f        ubuntu                          <span class="string">"/bin/bash"</span>         23 hours ago        Exited (0) 22 hours ago                                                                            clever_lewin</span><br><span class="line">25510a2cb171        twang2218/gitlab-ce-zh:8.15.3   <span class="string">"/assets/wrapper"</span>   2 days ago          Exited (127) 2 days ago                                                                            determined_mirzakhani</span><br></pre></td></tr></table></figure>
<p>在 <code>STATUS</code> 一栏中，可以看到退出码是多少。</p>
<ul>
<li>如果看到了 <code>Exited (127)</code> 那很可能是由于内存超标导致触发 <code>Out Of Memory</code> 然后被强制终止了。</li>
<li>如果看到了 <code>Exited (0)</code>，这说明容器主进程正常退出了。</li>
<li>如果是其他情况，应该检查容器日志。</li>
</ul>
<p>初学 Docker 的人常常会不理解既然正常怎么会退出的意思。不得不在强调一遍，Docker 不是虚拟机，容器只是进程。因此当执行 <code>docker run</code> 的时候，实际所做的只是启动一个进程，如果进程退出了，那么容器自然就终止了。</p>
<p>那么进程为什么会退出？</p>
<ul>
<li>如果是执行 <code>service nginx start</code> 这类启动后台服务程序的命令，那说明还是把 Docker 当做虚拟机了。Docker 启动的是进程，因此所谓的后台服务应该放到前台，比如应该 <code>nginx -g &#39;daemon off;&#39;</code> 这样直接前台启动应用才对。</li>
<li>如果发现 <code>COMMAND</code> 一栏是 <code>/bin/bash</code>，那还是说明把 Docker 当虚拟机了。<code>COMMAND</code> 应该是应用程序，而不交互式操作界面，容器不需要交互式操作界面。此外，如果使用 <code>/bin/bash</code> 希望起一个交互式的界面，那么也必须提供给其输入和终端，因此必须加 <code>-it</code> 选项，比如 <code>docker run -it ubuntu /bin/bash</code></li>
</ul>
<h3 id="如何在-Docker-容器内使用-docker-命令-比如在-Jenkins-容器中-？"><a href="#如何在-Docker-容器内使用-docker-命令-比如在-Jenkins-容器中-？" class="headerlink" title="如何在 Docker  容器内使用 docker 命令(比如在 Jenkins 容器中)？"></a>如何在 Docker  容器内使用 <code>docker</code> 命令(比如在 Jenkins 容器中)？</h3><p>首先，不要在 Docker 容器中安装、运行 Docker 引擎，也就是所谓的 Docker In Docker (DIND)，参考文章：</p>
<p><a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" target="_blank" rel="noopener">https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/</a></p>
<p>为了让容器内可以构建镜像，应该使用 <code>Docker Remote API</code> 的客户端来直接调用宿主的 Docker Engine。可以是原生的 Docker CLI （<code>docker</code> 命令），也可以是<a href="https://docs.docker.com/engine/reference/api/remote_api_client_libraries/" target="_blank" rel="noopener">其它语言的库</a>。</p>
<h4 id="为-Jenkins-添加-Docker-命令行"><a href="#为-Jenkins-添加-Docker-命令行" class="headerlink" title="为 Jenkins 添加 Docker 命令行"></a>为 Jenkins 添加 Docker 命令行</h4><p>下面以定制 <code>jenkins</code> 镜像为例，使用 <code>Dockerfile</code> 添加 <code>docker</code> 命令行可执行文件，并调整权限。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> jenkins:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载安装Docker CLI</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -O https://get.docker.com/builds/Linux/x86_64/docker-latest.tgz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar zxvf docker-latest.tgz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp docker/docker /usr/<span class="built_in">local</span>/bin/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf docker docker-latest.tgz</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 将 `jenkins` 用户的组 ID 改为宿主 `docker` 组的组ID，从而具有执行 `docker` 命令的权限。</span></span></span><br><span class="line"><span class="bash">ARG DOCKER_GID=999</span></span><br><span class="line"><span class="bash">USER jenkins:<span class="variable">$&#123;DOCKER_GID&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>在这个例子里，我们下载了静态编译的 <code>docker</code> 可执行文件，并提取命令行安装到系统目录下。然后调整了 <code>jenkins</code> 用户的组 ID，调整为宿主 <code>docker</code> 组ID，从而使其具有执行 <code>docker</code> 命令的权限。</p>
<p>组 ID 使用了 <code>DOCKER_GID</code> 参数来定义，以方便进一步定制。构建时可以通过 <code>--build-arg</code> 来改变 <code>DOCKER_GID</code> 的默认值，运行时也可以通过 <code>--user jenkins:1234</code> 来改变运行用户的身份。</p>
<p><em>这里的基础镜像使用的是 <code>jenkins:alpine</code>，换为非 <code>alpine</code> 的镜像 <code>jenkins:latest</code> 也是一样的。</em></p>
<p>用下面的命令来构建镜像（假设镜像名为 <code>jenkins-docker</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t jenkins-docker .</span><br></pre></td></tr></table></figure>
<p>如果需要构建时调整 <code>docker</code> 组 ID，可以使用 <code>--build-arg</code> 来覆盖参数默认值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t jenkins-docker --build-arg DOCKER_GID=1234 .</span><br></pre></td></tr></table></figure>
<p>在启动容器的时候，将宿主的 <code>/var/run/docker.sock</code> 文件挂载到容器内的同样位置，从而让容器内可以通过 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">unix socket</a> 调用宿主的 Docker 引擎。</p>
<p>比如，可以用下面的命令启动 <code>jenkins</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name jenkins \</span><br><span class="line">    -d \</span><br><span class="line">    -p 8080:8080 \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    jenkins-docker</span><br></pre></td></tr></table></figure>
<p>在 <code>jenkins</code> 容器中，就已经可以执行 <code>docker</code> 命令了，可以通过 <code>docker exec</code> 来验证这个结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it jenkins sh</span><br><span class="line">/ $ id</span><br><span class="line">uid=1000(jenkins) gid=999(ping) groups=999(ping)</span><br><span class="line">/ $ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      1.12.3</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.3</span><br><span class="line"> Git commit:   6b644ec</span><br><span class="line"> Built:        Wed Oct 26 23:26:11 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.13.0-rc2</span><br><span class="line"> API version:  1.25</span><br><span class="line"> Go version:   go1.7.3</span><br><span class="line"> Git commit:   1f9b3ef</span><br><span class="line"> Built:        Wed Nov 23 06:32:39 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line">/ $</span><br></pre></td></tr></table></figure>
<h3 id="Docker-容器如何随系统一同启动？"><a href="#Docker-容器如何随系统一同启动？" class="headerlink" title="Docker 容器如何随系统一同启动？"></a>Docker 容器如何随系统一同启动？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--restart=always</span><br></pre></td></tr></table></figure>
<p>参考官网文档：<a href="https://docs.docker.com/engine/reference/commandline/run/#restart-policies-restart" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/#restart-policies-restart</a></p>
<h3 id="docker-stats-显示的只有容器ID，怎么才能显示容器名字？"><a href="#docker-stats-显示的只有容器ID，怎么才能显示容器名字？" class="headerlink" title="docker stats 显示的只有容器ID，怎么才能显示容器名字？"></a><code>docker stats</code> 显示的只有容器ID，怎么才能显示容器名字？</h3><p>对于之前的版本，默认的 <code>docker stats</code> 里只显示容器 ID，后来即使支持了 <code>--format</code>，为了向后兼容，而没有将其变为默认配置。<code>17.10</code> 以后的版本，<code>docker container stats</code> 默认将显示容器名称。</p>
<p>对于以前的版本，可以修改客户端本地的 <code>~/.docker/config.json</code> 文件，加入一行配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"statsFormat"</span>: <span class="string">"table &#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;\t&#123;&#123;.MemPerc&#125;&#125;\t&#123;&#123;.NetIO&#125;&#125;\t&#123;&#123;.BlockIO&#125;&#125;\t&#123;&#123;.PIDs&#125;&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样默认格式就会改为这里指定的格式。</p>
<p>对于不支持这个配置文件的版本，还可以直接使用 <code>--format</code> 来指定显示格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats --format <span class="string">"table &#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;\t&#123;&#123;.MemPerc&#125;&#125;\t&#123;&#123;.NetIO&#125;&#125;\t&#123;&#123;.BlockIO&#125;&#125;\t&#123;&#123;.PIDs&#125;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>这种情况，建议将其添加为一个 <code>alias</code>，方便使用。</p>
<p>对于不支持 <code>--format</code> 的老版本，则可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps --format=<span class="string">'&#123;&#123;.Names&#125;&#125;'</span>)</span><br></pre></td></tr></table></figure>
<p>其缺点是不支持动态添加、删除的容器，所以不能作为持续观察。</p>
<h3 id="我用的是阿里云-Ubuntu-14-04-主机，内核还是3-13，怎么办？"><a href="#我用的是阿里云-Ubuntu-14-04-主机，内核还是3-13，怎么办？" class="headerlink" title="我用的是阿里云 Ubuntu 14.04 主机，内核还是3.13，怎么办？"></a>我用的是阿里云 <code>Ubuntu 14.04</code> 主机，内核还是<code>3.13</code>，怎么办？</h3><p>其实 <code>Ubuntu 14.04</code> 官方维护的内核已经到 <code>4.4</code> 了，可以通过下面的命令升级内核：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y --install-recommends linux-generic-lts-xenial</span><br></pre></td></tr></table></figure>
<h3 id="如何动态修改内存限制？"><a href="#如何动态修改内存限制？" class="headerlink" title="如何动态修改内存限制？"></a>如何动态修改内存限制？</h3><p><code>Docker 1.10</code> 之后支持动态修改，使用 <code>docker update</code> 命令，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update -m 300m</span><br></pre></td></tr></table></figure>
<h3 id="经常在各种-Docker-命令里看到-label，label-是什么？干什么用的？"><a href="#经常在各种-Docker-命令里看到-label，label-是什么？干什么用的？" class="headerlink" title="经常在各种 Docker 命令里看到 --label，label 是什么？干什么用的？"></a>经常在各种 <code>Docker</code> 命令里看到 <code>--label</code>，<code>label</code> 是什么？干什么用的？</h3><p><code>Label</code> 是<code>键值对</code>，是 <code>metadata</code>，是贯穿于 <code>Docker</code> 各个资源的，包括引擎、镜像、容器、卷、网络、Swarm 节点、服务等。</p>
<ul>
<li>键 <code>key</code>：格式要求只可以包含字母和数字，以及<code>.</code>，<code>-</code>。推荐使用类似于 <code>Java</code> 那种反向域名格式，如 <code>com.example.mytag</code>。</li>
<li>值 <code>value</code>：格式必须是字符串，除了普通字符串外，还可以是 <code>JSON</code>, <code>XML</code>, <code>CSV</code> 或者 <code>YAML</code>，当然，需要先进行序列化。</li>
</ul>
<p>当资源很少的时候，我们可以直接对一个个资源进行操作，但是，在管理很多资源的时候，这么做就变得不大现实。经常的需求是针对某一类的资源进行操作，而不是一个个的操作。这种情况，经常会使用 <code>label</code> 来帮助实现。</p>
<p>当创建一个资源的时候，可以指定这个资源的 <code>label</code>（一个资源可以有很多个 <code>label</code>），而当创建了很多个资源的时候，就可以通过过滤 <code>label</code> 的键、值来得到所需的资源列表。</p>
<p>比如，我们可以使用 <code>docker run</code> 运行一堆容器，在运行时，通过 <code>label</code> 指定容器是架构中的哪一部分。</p>
<ul>
<li>前端：<code>--label type=frontend</code></li>
<li>中间件：<code>--label type=middleware</code></li>
<li>存储：<code>--label type=storage</code></li>
</ul>
<p>在后期维护时，可以直接过滤显示想要的容器，比如我们只想看前端容器运行情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --filter label=<span class="built_in">type</span>=frontend</span><br></pre></td></tr></table></figure>
<p>而且，还可以进一步的和其它命令配合操作这组容器，比如我们需要停止所有前端容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -f label=<span class="built_in">type</span>=frontend)</span><br></pre></td></tr></table></figure>
<p>使用 <code>label</code> 在集群调度中也非常有用。</p>
<p>比如，我们可以在不同的 Docker 主机的引擎 <code>dockerd</code> 参数中，通过 <code>label</code> 来加入存储类型的信息，如：</p>
<ul>
<li>存储类型为 <code>SSD</code>：<code>--label storage=ssd</code></li>
<li>存储类型为 <code>HDD</code>：<code>--label storage=hdd</code></li>
</ul>
<p>对于数据库的服务，我们自然希望跑在 <code>SSD</code> 上以获得更大的性能，而日志、备份服务则希望跑在 <code>HDD</code> 上获得更高的容量。那么可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">    --name mysql \</span><br><span class="line">    --constraint <span class="string">'engine.labels.storage == ssd'</span> \</span><br><span class="line">    mysql</span><br></pre></td></tr></table></figure>
<h4 id="添加label以及过滤"><a href="#添加label以及过滤" class="headerlink" title="添加label以及过滤"></a>添加<code>label</code>以及过滤</h4><p>添加 <code>label</code> 大多格式都是在创建、修改资源时，使用 <code>--label &lt;key&gt;=&lt;value&gt;</code> 参数（部分命令提供了 <code>-l</code> 缩写形式）。<code>value</code> 可以省略，格式为 <code>--label &lt;key&gt;</code>。如果需要定义多组 <code>label</code>，只需多组 <code>--label</code> 即可。</p>
<p>过滤 <code>label</code> 则大多发生在列表命令中，使用 <code>--filter label=&lt;key&gt;=&lt;value&gt;</code>，或者对于不关心 <code>value</code> 的情况，<code>--filter label=&lt;key&gt;</code>（部分命令提供了 <code>-f</code> 的缩写形式）。</p>
<p>下面的列表，列出了支持 <code>label</code> 的命令（除非特殊声明，”添加”命令使用 <code>--label</code> 选项添加 <code>label</code>；”过滤”命令使用 <code>--filter</code> 过滤<code>label</code>）：</p>
<ul>
<li>Docker 引擎<ul>
<li>添加：<code>dockerd</code>： <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/</a></li>
</ul>
</li>
<li>镜像<ul>
<li>添加：<ul>
<li><code>docker build</code>：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a></li>
<li><code>Dockerfile</code> 中的 <code>LABEL</code>（会继承<code>FROM</code>镜像的<code>LABEL</code>）：<a href="https://docs.docker.com/engine/reference/builder/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/#/label</a></li>
</ul>
</li>
<li>过滤：<code>docker images</code>：<a href="https://docs.docker.com/engine/reference/commandline/images/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/images/#/filtering</a></li>
</ul>
</li>
<li>容器<ul>
<li>添加：<code>docker create</code>：<a href="https://docs.docker.com/engine/reference/commandline/create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/create/</a><ul>
<li>除了 <code>--label</code> 外，<code>docker create</code> 还支持使用选项 <code>--label-file</code> 从文件中加载 <code>label</code></li>
</ul>
</li>
<li>添加：<code>docker run</code>：<a href="https://docs.docker.com/engine/reference/commandline/run/#/set-metadata-on-container--l---label---label-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/#/set-metadata-on-container--l---label---label-file</a><ul>
<li>除了 <code>--label</code> 外，<code>docker run</code> 还支持使用选项 <code>--label-file</code> 从文件中加载 <code>label</code></li>
</ul>
</li>
<li>过滤：<code>docker ps</code>：<a href="https://docs.docker.com/engine/reference/commandline/ps/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/ps/#/label</a></li>
</ul>
</li>
<li>卷<ul>
<li>添加：<code>docker volume create</code>：<a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/volume_create/</a></li>
<li>过滤：<code>docker volume ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/volume_ls/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/volume_ls/#/filtering</a></li>
</ul>
</li>
<li>网络<ul>
<li>添加：<code>docker network create</code>：<a href="https://docs.docker.com/engine/reference/commandline/network_create/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/network_create/</a></li>
<li>过滤：<code>docker network ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/network_ls/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/network_ls/#/filtering</a></li>
</ul>
</li>
<li>Swarm 节点<ul>
<li><code>docker node update</code>：<a href="https://docs.docker.com/engine/reference/commandline/node_update/#/add-label-metadata-to-a-node" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/node_update/#/add-label-metadata-to-a-node</a><ul>
<li>添加：<code>--label-add</code></li>
<li>删除：<code>--label-rm</code></li>
</ul>
</li>
<li>过滤：<code>docker node ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/node_ls/#/filtering" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/node_ls/#/filtering</a></li>
<li>过滤：<code>docker node ps</code>：<a href="https://docs.docker.com/engine/reference/commandline/node_ps/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/node_ps/#/label</a></li>
</ul>
</li>
<li>服务<ul>
<li>添加：<code>docker service create</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_create/#/set-metadata-on-a-service--l---label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_create/#/set-metadata-on-a-service--l---label</a><ul>
<li>除了 <code>--label</code> 外，还可以通过 <code>--container-label</code> 来添加容器 <code>label</code></li>
</ul>
</li>
<li><code>docker service update</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_update/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_update/</a><ul>
<li>添加容器 <code>label</code>：<code>--container-label-add</code></li>
<li>删除容器 <code>label</code>：<code>--container-label-rm</code></li>
<li>添加服务 <code>label</code>：<code>--label-add</code></li>
<li>删除服务 <code>label</code>：<code>--label-rm</code></li>
</ul>
</li>
<li>过滤：<code>docker service ls</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_ls/#/label" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_ls/#/label</a></li>
</ul>
</li>
</ul>
<p>除了上述资源外，<code>docker events</code> 也可以使用 <code>label</code> 过滤结果：<a href="https://docs.docker.com/engine/reference/commandline/events/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/events/</a></p>
<h4 id="集群调度约束"><a href="#集群调度约束" class="headerlink" title="集群调度约束"></a>集群调度约束</h4><ul>
<li>一代 Swarm：使用环境变量添加约束<ul>
<li><code>docker run</code>：<code>-e constraint:storage==sdd</code>：<a href="https://docs.docker.com/swarm/scheduler/filter/#/how-to-write-filter-expressions" target="_blank" rel="noopener">https://docs.docker.com/swarm/scheduler/filter/#/how-to-write-filter-expressions</a></li>
<li><code>docker-compose.yml</code>：使用 <code>environment</code> 来进行约束：<a href="https://docs.docker.com/compose/swarm/#/manual-scheduling" target="_blank" rel="noopener">https://docs.docker.com/compose/swarm/#/manual-scheduling</a></li>
</ul>
</li>
</ul>
<p>如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    redis:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"constraint:storage==ssd"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>二代 Swarm<ul>
<li><code>docker service create</code>：<code>--constraint value</code>：<a href="https://docs.docker.com/engine/reference/commandline/service_create/#/specify-service-constraints---constraint" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_create/#/specify-service-constraints---constraint</a></li>
</ul>
</li>
</ul>
<p>如下面的例子中，使用 <code>Swarm 节点</code> 的 <code>label</code> 进行约束（注意，这次用的不是<code>引擎</code>的<code>label</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">    --name web \</span><br><span class="line">    --constraint <span class="string">'node.labels.type == frontend'</span> \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure>
<h3 id="都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？"><a href="#都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？" class="headerlink" title="都说不要用 root 去运行服务，但我看到的 Dockerfile 都是用 root 去运行，这不安全吧？"></a>都说不要用 <code>root</code> 去运行服务，但我看到的 <code>Dockerfile</code> 都是用 <code>root</code> 去运行，这不安全吧？</h3><p>并非所有官方镜像的 <code>Dockerfile</code> 都是用 <code>root</code> 用户去执行的。比如 <code>mysql</code> 镜像的执行身份就是 <code>mysql</code> 用户；<code>redis</code> 镜像的服务运行用户就是 <code>redis</code>；<code>mongo</code> 镜像内的服务执行身份是 <code>mongo</code> 用户；<code>jenkins</code> 镜像内是 <code>jenkins</code> 用户启动服务等等。所以说 “都是用 <code>root</code> 去运行” 是不客观的。</p>
<p>当然，这并不是说在<strong>容器内</strong>使用 <code>root</code> 就非常危险。容器内的 <code>root</code> 和宿主上的 <code>root</code> 不同，容器内的 <code>root</code> 虽然 <code>uid</code> 也默认为 <code>0</code>，但是却处于一个隔离的命名空间，而且被去掉了大量的特权。容器内的 <code>root</code> 是一个没有什么特权的用户，危险的操作基本都无法执行。</p>
<p>不过，如果用户可以打破这个安全保护，那就是另外一回事了。比如，如果用户挂载了宿主目录给容器，这就是打通了一个容器内的 <code>root</code> 操控宿主的一个通道，使得容器内的 <code>root</code> 可以修改所挂载的目录下的任何文件。</p>
<p>因为当前版本的 Docker 中，<strong>默认情况下</strong>容器的 <code>user namespace</code> 并未开启，所以容器内的用户和宿主用户共享 <code>uid</code> 空间。容器内的 <code>uid</code> 为 <code>0</code> 的 <code>root</code>，就被系统视为 <code>uid=0</code> 的宿主 <code>root</code>，因此磁盘读写时，具有宿主 <code>root</code> 同等读写权限。这也是为什么一般不推荐挂载宿主目录、特别是挂载宿主系统目录的原因之一。这一切只要定制镜像的时候，容器内不使用 <code>root</code> 启动服务就没这个问题了。</p>
<p>当然，上面说的问题只是默认情况下 <code>user namespace</code> 不会启用的问题。<code>dockerd</code> 有一个 <code>--userns-remap</code> 参数，只要配置了这个参数，就可以确保容器内的 <code>uid</code> 是独立命名空间，容器内的 <code>uid</code> 变到宿主的时候，会被 <code>remap</code> 到另一个范围。因此，容器内的 <code>uid=0</code> 的 <code>root</code> 将完全跟 <code>root</code> 没有任何关系，仅仅是个普通用户而已。</p>
<p>相关信息请参考官方文档：</p>
<ul>
<li><code>--userns-remap</code> 的介绍：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options</a></li>
<li>Docker 安全：<a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/security/</a></li>
</ul>
<h3 id="我在容器里运行-systemctl-start-xxx-怎么报错啊？"><a href="#我在容器里运行-systemctl-start-xxx-怎么报错啊？" class="headerlink" title="我在容器里运行 systemctl start xxx 怎么报错啊？"></a>我在容器里运行 <code>systemctl start xxx</code> 怎么报错啊？</h3><p>如果在容器内使用 <code>systemctl</code> 命令，经常会发现碰到这样的错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br></pre></td></tr></table></figure>
<p>这很正常，因为 <code>systemd</code> 是完整系统的服务启动、维护的系统服务程序，而且需要特权去执行。但是容器不是完整系统，既没有配合的服务，也没有特权，所以自然用不了。</p>
<p>如果你碰到这样的问题，只能再次提醒你，<strong>Docker 不是虚拟机</strong>。试图在容器里执行 <code>systemctl</code> 命令的，大多都是还没有搞明白容器和虚拟机的区别，因为看到了可以有 Shell，就以为这是个虚拟机，试图重复自己在完整系统上的体验。这是用法错误，<strong>不要把 Docker 当做虚拟机去用，容器有自己的用法</strong>。</p>
<blockquote>
<p>Docker 不是虚拟机，容器只是受限进程。</p>
</blockquote>
<p>容器内根本不需要后台服务，也不需要服务调度和维护，自然也不需要 <code>systemd</code>。容器只有一个主进程，也就是应用进程。容器的生存周期就是围绕着这个主进程而存在的，所以所试图启动的后台服务，应该改为直接在前台运行，根本不需要也不应该使用 <code>systemctl</code> 命令去在后台加载。日志之类的也是直接从 <code>stdout</code>/<code>stderr</code> 输出，而不是走 <code>journald</code>。</p>
<h3 id="容器内的时间和宿主不一致，怎么同步啊？"><a href="#容器内的时间和宿主不一致，怎么同步啊？" class="headerlink" title="容器内的时间和宿主不一致，怎么同步啊？"></a>容器内的时间和宿主不一致，怎么同步啊？</h3><p>问这个问题的人往往混淆了<strong>时间</strong>和<strong>时区</strong>的概念。</p>
<p><strong>时间</strong>是从 <code>epoch</code> 到当前的秒数或者毫秒数，全球都一样，这是绝对值；而<strong>时区</strong>则是由于地理位置差异、行政区划导致各地显示时间的差异。</p>
<p>对于 Docker 容器而言，根本不存在宿主和容器的时间差异问题，因为他们使用的是同一个内核、同一个时钟，二者完全一样，所以根本不存在同步问题。还是那句话 <strong>Docker 不是虚拟机</strong>。</p>
<p>所看到的差异，如果细心一点，很可能会发现其实根本不是<strong>时间</strong>同步问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu bash</span><br><span class="line">root@08c6ad41f343:/<span class="comment"># date</span></span><br><span class="line">Tue Dec 13 01:36:37 UTC 2016</span><br></pre></td></tr></table></figure>
<p>注意到 <code>UTC</code> 了么，这是说使用的是国际标准 <code>0 时区</code> 的时间显示，因此这只是显示所用的时区设置差异问题。而且之前如果稍微注意一下，就会发现所谓时间不一致，实际上是整整差了 <code>8</code> 个小时，还记得中学地理课上讲的中国时区是多少么？是 <code>+8 时区</code>，所以自然和 <code>0 时区</code> 差了 <code>8</code> 个小时。应该很快就意识到是自己的时区设错了（或者偷懒没设）导致。</p>
<p>解决办法很简单，设置时区即可。一般情况直接设置环境变量 <code>TZ</code> 就够了，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -e TZ=Asia/Shanghai debian bash</span><br><span class="line">root@8e6d6c588328:/<span class="comment"># date</span></span><br><span class="line">Tue Dec 13 09:41:21 CST 2016</span><br></pre></td></tr></table></figure>
<p>看到了么？时区调整到了 <code>CST</code>，也就是<code>China Standard Time - 中国标准时间</code>，因此显示就正常了。</p>
<p>不过并非所有系统都可以如此方便的设置时区。可以直接使用 <code>TZ=Asia/Shanghai</code> 环境变量修改时区的系统有：</p>
<ul>
<li><code>centos</code> (<code>5</code>, <code>6</code>, <code>7</code>)</li>
<li><code>debian</code> (<code>7</code>, <code>8</code>, <code>9</code>)</li>
<li><code>fedora</code> (<code>24</code>, <code>25</code>, <code>26</code>)</li>
<li><code>ubuntu</code> (<code>14.04</code>)</li>
</ul>
<p>而下面的这些系统可能出于镜像体积的考虑，去掉了时区的软件包 <code>tzdata</code>，因此需要在 <code>Dockerfile</code> 中先行安装时区包。</p>
<ul>
<li><code>ubuntu</code>: (<code>16.04</code>, <code>17.04</code>, <code>17.10</code>) (~15MB)<ul>
<li><code>Dockerfile</code>:</li>
</ul>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -xe \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt-get install tzdata locales \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>alpine</code> (~1.3MB)<ul>
<li><code>Dockerfile</code>: <code>RUN apk --no-cache add tzdata</code></li>
</ul>
</li>
<li><code>opensuse</code> (~12MB)<ul>
<li><code>Dockerfile</code>:</li>
</ul>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -xe \</span></span><br><span class="line"><span class="bash">    &amp;&amp; zypper --non-interactive refresh \</span></span><br><span class="line"><span class="bash">    &amp;&amp; zypper --non-interactive -qn install --no-recommends timezone \</span></span><br><span class="line"><span class="bash">    &amp;&amp; zypper --non-interactive clean -a</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>clearlinux</code> (~280MB …😂)<ul>
<li><code>Dockerfile</code>:</li>
</ul>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -xe \</span></span><br><span class="line"><span class="bash">    &amp;&amp; swupd bundle-add sysadmin-basic \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/swupd/*</span></span><br></pre></td></tr></table></figure>
<p>上面列表除了列出系统外，还给出了每个系统需要添加到 <code>Dockerfile</code> 的安装包的命令，以及安装后镜像体积增加的大小。其中 <code>clearlinux</code> 不能单个安装软件包，所以体积增加的有些夸张，因此更好地办法是直接 <code>COPY</code> 时区信息进镜像。</p>
<blockquote>
<p>注意：<code>ubuntu:16.04</code> 以后的版本，在 2017年4月10 日以后，已经去除 <code>tzdata</code>，因此要改变其时区需要进行时区安装操作，而<strong>不是</strong>像以前那样只需配置 <code>TZ</code> 环境变量即可。<br>不过大部分<strong>官方镜像</strong>是基于 <code>debian</code> 的，因此它们<strong>不受影响</strong>。</p>
<p>参考 issue:</p>
<ul>
<li><a href="https://bugs.launchpad.net/cloud-images/+bug/1682622" target="_blank" rel="noopener">https://bugs.launchpad.net/cloud-images/+bug/1682622</a></li>
<li><a href="https://bugs.launchpad.net/cloud-images/+bug/1682305" target="_blank" rel="noopener">https://bugs.launchpad.net/cloud-images/+bug/1682305</a></li>
<li><a href="https://github.com/docker-library/official-images/issues/2863" target="_blank" rel="noopener">https://github.com/docker-library/official-images/issues/2863</a></li>
<li><a href="https://github.com/docker-library/official-images/issues/2856" target="_blank" rel="noopener">https://github.com/docker-library/official-images/issues/2856</a></li>
</ul>
</blockquote>
<p>这仅仅是调整容器内系统环境的时区，大部分程序都会遵循这个标准。但是有些应用并不遵守这类约定，会使用自己的时区设置。</p>
<p>一般应用、服务的配置文件里一般都有时区选项，应该根据自己需求把中国时区配上。</p>
<p>比如，PHP 配置文件中的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Date]</span></span><br><span class="line">date.timezone = Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>再比如 <code>mysqld</code> 中的参数 <code>--timezone=Asia/Shanghai</code>；<code>Java</code> 的 <code>-Duser.timezone=Asia/Shanghai</code> <code>JVM</code> 参数，都可以指定上层应用时区，而不依赖于系统默认时区，这也是推荐的做法。避免系统部署时受系统时区影响，这在全球云服务器环境中其实很常见，因此尽量在应用层设置好。很多应用都有自己的时区设置，应该去了解一下并且进行设置，不要总用默认值。</p>
<p>一些人在配置服务的时候很懒惰，只要默认能用即可，而不会一一检查每一个配置的默认值是否和自己期望一致，这是很不专业的做法，正是这种不专业才导致了出现了这种问题。所以做事情，一定要让自己以专业的视角和态度看问题。</p>
<h3 id="我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？"><a href="#我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？" class="headerlink" title="我想让我的程序平滑退出，为什么截获 SIGTERM 信号不管用啊？"></a>我想让我的程序平滑退出，为什么截获 <code>SIGTERM</code> 信号不管用啊？</h3><p><code>docker stop</code>, <code>docker service rm</code> 在停止容器时，都会先发 <code>SIGTERM</code> 信号，等待一段时间（默认为 10 秒）后，如果程序没响应，则强行 <code>SIGKILL</code> 杀掉进程。</p>
<p>这样应用进程就有机会平滑退出，在接收到 <code>SIGTERM</code> 后，可以去 Flush 缓存、完成文件读写、关闭数据库连接、释放文件资源、释放锁等等，然后再退出。所以试图截获 <code>SIGTERM</code> 信号的做法是对的。</p>
<p>但是，可能在截获 <code>SIGTERM</code> 时却发现，却发现应用并没有收到 <code>SIGTERM</code>，于是盲目的认为 Docker 不支持平滑退出，其实并非如此。</p>
<p>还记得我们提到过，<strong>Docker 不是虚拟机，容器只是受限进程，而一个容器只应该跑一个主进程</strong>的说法么？如果你发现你的程序没有截获到 <code>SIGTERM</code>，那就很可能你没有遵循这个最佳实践的做法。因为 <code>SIGTERM</code> 只会发给主进程，也就是容器内 <code>PID</code> 为 <code>1</code> 的进程。</p>
<p>至于说主进程启动的那些子进程，完全看主进程是否愿意转发 <code>SIGTERM</code> 给子进程了。所以那些把 Docker 当做虚拟机用的，主进程跑了个 <code>bash</code>，然后 exec 进去启动程序的，或者来个 <code>&amp;</code> 让程序跑后台的情况，应用进程必然无法收到 <code>SIGTERM</code>。</p>
<p>还有一种可能是在 <code>Dockerfile</code> 中的 <code>CMD</code> 那行用的是 <code>shell</code> 格式写的命令，而不是 <code>exec</code> 格式。还记得前面提到过的 <code>shell</code> 格式的命令，会加一个 <code>sh -c</code> 来去执行么？因此使用 <code>shell</code> 格式写 <code>CMD</code> 的时候，<code>PID</code> 为 <code>1</code> 的进程是 <code>sh</code>，而它不转发信号，所以主程序收不到。</p>
<p>明白了道理，解决方法就很简单，换成 <code>exec</code> 格式，并且将主进程执行文件放在第一位即可。这也是为什么之前推荐 <code>exec</code> 格式的原因之一。</p>
<h1 id="Docker-Compose-相关问题-2"><a href="#Docker-Compose-相关问题-2" class="headerlink" title="Docker Compose 相关问题 (2)"></a>Docker Compose 相关问题 <code>(2)</code></h1><h2 id="你那个-LNMP-例子中的-docker-compose-yml-中有好多-networks，都是什么意思啊？"><a href="#你那个-LNMP-例子中的-docker-compose-yml-中有好多-networks，都是什么意思啊？" class="headerlink" title="你那个 LNMP 例子中的 docker-compose.yml 中有好多 networks，都是什么意思啊？"></a>你那个 <code>LNMP</code> 例子中的 <code>docker-compose.yml</code> 中有好多 <code>networks</code>，都是什么意思啊？</h2><p>我写的 <code>LNMP</code> 多容器互通的例子：<a href="https://coding.net/u/twang2218/p/docker-lnmp/git" target="_blank" rel="noopener">https://coding.net/u/twang2218/p/docker-lnmp/git</a></p>
<p>前面 <code>services</code> 下的每个服务下面的 <code>networks</code>，是说这个服务要接到哪个网络上。<br>而最后的那个总的<code>networks</code>下面的，是这几个网络的定义。</p>
<p>也就是说，<code>nginx</code> 接到了名为 <code>frontend</code> 的前端网络；<code>mysql</code> 接到了名为 <code>backend</code> 的后端网络；而作为中间的 <code>php</code> 既需要和 <code>nginx</code> 通讯，又需要和 <code>mysql</code> 通讯，所以同时连接了 <code>frontend</code> 和 <code>backend</code> 网络。由于 <code>nginx</code> 和 <code>mysql</code> 不处于同一网络，所以二者无法通讯，起到了隔离的作用。</p>
<p>关于 Docker 自定义网络，你可以看一下官方文档的介绍：<br><a href="https://docs.docker.com/engine/userguide/networking/dockernetworks/#/user-defined-networks" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/networking/dockernetworks/#/user-defined-networks</a></p>
<p>关于在 Docker Compose 中使用自定义网络的部分，可以看官方这部分文档：<br><a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">https://docs.docker.com/compose/networking/</a></p>
<h2 id="使用-Compose-的时候碰到-“An-HTTP-request-took-too-long-to-complete…-”-错误，怎么办？"><a href="#使用-Compose-的时候碰到-“An-HTTP-request-took-too-long-to-complete…-”-错误，怎么办？" class="headerlink" title="使用 Compose 的时候碰到 “An HTTP request took too long to complete….” 错误，怎么办？"></a>使用 Compose 的时候碰到 “An HTTP request took too long to complete….” 错误，怎么办？</h2><p>Compose 的请求超时时限是可以配置的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> COMPOSE_HTTP_TIMEOUT=120</span><br></pre></td></tr></table></figure>
<p>不过，这不是问题的解决办法，因为一般情况下不应该超时，超时的原因是因为所访问的 Docker Engine 过于繁忙，而无法响应 Compose 的请求。应该检查具体 Docker Engine 出了什么问题，是不是还在用着 <code>CentOS</code> 默认的 <code>device mapper</code> 的 <code>loop</code> 设备，等等。</p>
<h1 id="Docker-Swarm-相关问题-8"><a href="#Docker-Swarm-相关问题-8" class="headerlink" title="Docker Swarm 相关问题 (8)"></a>Docker Swarm 相关问题 <code>(8)</code></h1><h2 id="我的-Docker-版本是-1-12，请问我跑的是一代-Swarm-还是二代-Swarm-啊？"><a href="#我的-Docker-版本是-1-12，请问我跑的是一代-Swarm-还是二代-Swarm-啊？" class="headerlink" title="我的 Docker 版本是 1.12，请问我跑的是一代 Swarm 还是二代 Swarm 啊？"></a>我的 Docker 版本是 1.12，请问我跑的是一代 Swarm 还是二代 Swarm 啊？</h2><p>……自己运行的 Swarm 怎么会连自己都不知道跑的是啥？😅</p>
<p>首先，至于是运行的一代 Swarm 还是二代 Swarm，单看版本是没意义的。<strong>Docker 1.12+ 的版本同时支持一代 Swarm 和二代 Swarm</strong>。</p>
<p>如果是使用容器形式运行的 Swarm，也就是 <code>docker run swarm</code> 形式构建的 Swarm，这是<strong>一代 Swarm</strong>，也被称为 <strong>Docker Swarm</strong>。</p>
<p>如果是使用内置命令形式构建的 Swarm，也就是使用命令 <code>docker swarm init</code> 形式构建的 Swarm，这是内置的 Swarm，是<strong>二代 Swarm</strong>，也被称为 <strong>Docker Swarm Mode</strong>。</p>
<h2 id="Swarm环境中怎么指定某个容器在指定的宿主上运行呢？"><a href="#Swarm环境中怎么指定某个容器在指定的宿主上运行呢？" class="headerlink" title="Swarm环境中怎么指定某个容器在指定的宿主上运行呢？"></a>Swarm环境中怎么指定某个容器在指定的宿主上运行呢？</h2><p>每个 Docker Host 建立时都可以通过 <code>--label</code> 指定其 Docker 引擎的标签，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockerd \</span><br><span class="line">    --label com.example.environment=<span class="string">"production"</span> \</span><br><span class="line">    --label com.example.storage=<span class="string">"ssd"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，上面的配置参数应该配置在 <code>Docker</code> 引擎的配置文件里修改，如 <code>docker.service</code>，而不是简单的命令行执行……</p>
</blockquote>
<p>然后运行容器时，使用环境变量约束调度即可。可以使用 Compose 文件的 <code>environment</code> 配置，也可以使用 <code>docker run</code> 的 <code>-e</code> 环境变量参数。下面以 Compose 配置文件为例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  mongodb:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mongo:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"constraint:com.example.storage==ssd"</span></span><br></pre></td></tr></table></figure>
<p>这样这个 <code>mongodb</code> 的服务就会运行在标记为 <code>com.example.storage=&quot;ssd&quot;</code> 的宿主上运行。</p>
<h2 id="为什么-Swarm-集群的-overlay-network-跨宿主无法互访？"><a href="#为什么-Swarm-集群的-overlay-network-跨宿主无法互访？" class="headerlink" title="为什么 Swarm 集群的 overlay network 跨宿主无法互访？"></a>为什么 Swarm 集群的 overlay network 跨宿主无法互访？</h2><p>首先，检查建立 Swarm 的时候，对其它节点所宣告的本节点的地址是否正确。</p>
<p>对于单网卡、单IP的宿主，Swarm 会自动选择网卡地址，但是多网卡、多IP的宿主，就必须手动宣告地址。</p>
<ul>
<li>对于一代 Swarm 而言，检查一下 <code>dockerd</code> 的配置中，<code>--cluster-advertise</code> 地址是否配置正确。</li>
<li>对于二代 Swarm，则检查一下创建、加入 Swarm 的时候，<code>--advertise-addr</code> 是否填写正确。</li>
</ul>
<p>宣告地址必须是全集群可以互访的，由于该地址端口是 <code>Docker Remote API</code> 端口，所以可以用 <code>curl</code> 来连接其它节点，以判断互通性。</p>
<p>然后，检查宿主间的网络互通问题，特别是宿主的防火墙开启的情况下，检查下列服务端口有没有放开：</p>
<ul>
<li><code>7946/{udp,tcp}</code></li>
<li><code>4789/{udp,tcp}</code></li>
<li>{<code>2375</code>,<code>2376</code>,<code>2377</code>,<code>3375</code>,<code>3376</code>}/<code>tcp</code> （具体端口取决于实际 <code>Swarm</code> 或 <code>Engine</code> 守护端口)</li>
</ul>
<p>可以通过 <code>telnet</code>, <code>curl</code> 之类的工具确保上述端口可以互访。</p>
<p>如果还是有问题，可以进一步启用各个节点的 Docker 引擎的调试模式。和配置 <code>--insecure-registry</code> 的方法一样，编辑 Docker 配置文件，在 <code>dockerd</code> 后添加 <code>-D</code> 参数。然后重新启动 Docker 引擎，建立集群、网络、服务。如果问题重现，可以分析 <code>Docker</code> 引擎的日志，具体查看日志的方法见前面的问答。</p>
<p>需要注意的是，在 <code>1.13</code> 以前的版本中，跨宿主的情况下，无法在容器内 <code>ping</code> 到另一个服务的 <code>VIP</code>，这种情况，可以 <code>ping tasks.&lt;服务名&gt;</code>，来跳过 <code>VIP</code> 进行 <code>ping</code>。</p>
<p>参考：</p>
<p><a href="https://docs.docker.com/swarm/plan-for-production/" target="_blank" rel="noopener">https://docs.docker.com/swarm/plan-for-production/</a></p>
<p><a href="https://docs.docker.com/engine/swarm/swarm-tutorial/#/open-ports-between-the-hosts" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/swarm-tutorial/#/open-ports-between-the-hosts</a></p>
<p><a href="https://docs.docker.com/engine/swarm/networking/" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/networking/</a></p>
<h2 id="Docker-二代Swarm-既-Swarm-Mode-，docker-service-create-不可以使用-v-那怎么使用卷-Volume-？"><a href="#Docker-二代Swarm-既-Swarm-Mode-，docker-service-create-不可以使用-v-那怎么使用卷-Volume-？" class="headerlink" title="Docker 二代Swarm (既 Swarm Mode)，docker service create 不可以使用 -v 那怎么使用卷(Volume)？"></a>Docker 二代Swarm (既 Swarm Mode)，<code>docker service create</code> 不可以使用 <code>-v</code> 那怎么使用卷(Volume)？</h2><p>从二代 Swarm 开始，将使用 <code>--mount</code> 参数来进行卷挂载，并且对语义进行更明确的划分。</p>
<p>挂载分两种：</p>
<ul>
<li>绑定挂载 <code>bind-mount</code>：这类挂载将宿主目录/文件绑定到容器的某个位置。这类挂载需要注意宿主和容器的不同uid导致的权限、访问控制差异问题。</li>
<li>数据卷 <code>data volumes</code>：这类挂载是之前推荐使用的卷。卷可以分为命名卷<code>named volume</code>以及匿名卷<code>anonymous volume</code></li>
</ul>
<p>挂载参数的格式基本上为 <code>--mount &lt;key1&gt;=&lt;value1&gt;[,&lt;key2&gt;=&lt;value2&gt;,...]</code>。</p>
<p>主要参数有：</p>
<ul>
<li><code>type</code>: 如之前所说，两种类型： <code>volume</code> 和 <code>bind</code>。如果不指定 <code>type</code>，默认为 <code>volume</code>；</li>
<li><code>src</code> 或 <code>source</code>：源：<ul>
<li>如果 <code>type=volume</code>，<code>src</code> 则是卷的名字，是可选项。如果存在就是命名卷，如果没指定 <code>src</code> 则是匿名卷；</li>
<li>如果 <code>type=bind</code>，<code>src</code> 是宿主本地的路径；</li>
</ul>
</li>
<li><code>dst</code> 或 <code>destination</code> 或 <code>target</code>：将在容器内挂载的路径。如果路径不存在，会在挂载前自动建立路径。</li>
<li><code>readonly</code> 或 <code>ro</code>：是否让该挂载为只读，默认是读写。</li>
</ul>
<p>除此之外还有一些常见的参数可以设置：</p>
<ul>
<li><code>volume-driver</code>：指定卷驱动，默认是 <code>local</code>，可以通过这个参数指定其它（如 <code>flocker</code>, <code>glusterfs</code>, <code>ceph</code>）之类的驱动；</li>
<li><code>volume-label</code>：指定卷的元数据(metadata)，从而方便过滤操作；</li>
<li><code>volume-opt</code>：不同的卷驱动可能需要额外的参数，这个选项可以指定这些参数。</li>
</ul>
<p><code>--mount</code> 和 <code>--volume</code> 有一些差异需要注意：</p>
<ul>
<li><code>--mount</code> 可以直接使用卷，而无需事先使用 <code>docker volume create</code> 来创建卷，并且可以多组不同驱动的卷；</li>
<li><code>--mount</code> 如果 <code>type=bind</code> 的话，宿主必须存在指定目录，否则报错。而 <code>--volume</code> 则在宿主不存在该路径时，在宿主创建一个空目录来进行绑定。</li>
</ul>
<p>举几个例子：</p>
<p>挂载命名卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name my-service \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=my-volume,destination=/path/<span class="keyword">in</span>/container,volume-label=<span class="string">"color=red"</span>,volume-label=<span class="string">"shape=round"</span> \</span><br><span class="line">  nginx:alpine</span><br></pre></td></tr></table></figure>
<p>挂载匿名卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name my-service \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  --mount <span class="built_in">type</span>=volume,destination=/path/<span class="keyword">in</span>/container \</span><br><span class="line">  nginx:alpine</span><br></pre></td></tr></table></figure>
<p>绑定宿主目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line"> --name my-service \</span><br><span class="line"> --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/path/on/host,destination=/path/<span class="keyword">in</span>/container \</span><br><span class="line"> nginx:alpine</span><br></pre></td></tr></table></figure>
<p>参考官网文档：<a href="https://docs.docker.com/engine/reference/commandline/service_create/#/add-bind-mounts-or-volumes" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/service_create/#/add-bind-mounts-or-volumes</a></p>
<h2 id="对于两节点集群来说，-replicas-2-和-mode-global-是不是一个意思？"><a href="#对于两节点集群来说，-replicas-2-和-mode-global-是不是一个意思？" class="headerlink" title="对于两节点集群来说，--replicas=2 和 --mode=global 是不是一个意思？"></a>对于两节点集群来说，<code>--replicas=2</code> 和 <code>--mode=global</code> 是不是一个意思？</h2><p>首先，二者语义就不同。</p>
<ul>
<li><code>--replicas=2</code>，是要求该服务有2个副本，无论集群多少个节点，也不在乎这两个副本是不是都跑在一个宿主上，所以无法确保每个节点一个副本；</li>
<li><code>--mode=global</code>，是要求服务在集群每一个节点上跑一个副本。</li>
</ul>
<p>现象上也不一样，<code>--replicas=2</code> 是要确保副本为2个。那么如果一个节点挂了，会在另一个节点上在起一个副本，从而确保副本数为2。而对于 <code>--mode=global</code> 来说，如果一个节点挂了，不会再另一个节点上起一个副本。</p>
<h2 id="一代-Swarm-的时候可以用-docker-run-啊，二代怎么又弄个-docker-service-create-出来？为什么要多此一举？"><a href="#一代-Swarm-的时候可以用-docker-run-啊，二代怎么又弄个-docker-service-create-出来？为什么要多此一举？" class="headerlink" title="一代 Swarm 的时候可以用 docker run 啊，二代怎么又弄个 docker service create 出来？为什么要多此一举？"></a>一代 Swarm 的时候可以用 <code>docker run</code> 啊，二代怎么又弄个 <code>docker service create</code> 出来？为什么要多此一举？</h2><p>因为 <code>docker run</code> 和 <code>docker service create</code> 是两个不同理念的东西。</p>
<p>一代 Swarm 中，将 Swarm 集群视为一个巨大的 Docker 主机，本质上和单机没有区别，都是直接调度运行容器。因此依旧使用单机的 <code>docker run</code> 的方式来启动特定容器。</p>
<p>二代 Swarm 则改变了这个理念，增加了服务栈(<code>Stack</code>)、服务(<code>Service</code>)、任务(<code>Task</code>) 的概念。在二代 Swarm 中，一组服务可以组成一个整体进行部署，也就是部署服务栈，这相当于是之前的 Docker Compose 所完成的目的。但是这次，是真正的针对<strong>服务</strong>的。</p>
<p>一个<strong>服务</strong>并非一个<strong>容器</strong>，一个服务可以有多个副本<strong>任务</strong>，每个任务对应一个容器。这个概念在一代 Swarm 和单机环境中是没有的，因此 Docker Compose 为了实现服务的概念，用了各种办法去模拟，包括使用 <code>labels</code>，使用网络别名等等，但是本质上，依旧是以容器为单位进行运行，也就是本质上还是一组 <code>docker run</code>。</p>
<p>正是由于二代 Swarm 中用户操作的单元是服务，所以传统的以容器为中心的 <code>docker run</code> 就不再适用，因此有新的一组针对服务的命令，<code>docker service</code>。</p>
<h2 id="docker-service-ps-里面总是有一堆失败或者shutdown的历史容器，怎么删啊？"><a href="#docker-service-ps-里面总是有一堆失败或者shutdown的历史容器，怎么删啊？" class="headerlink" title="docker service ps 里面总是有一堆失败或者shutdown的历史容器，怎么删啊？"></a><code>docker service ps</code> 里面总是有一堆失败或者shutdown的历史容器，怎么删啊？</h2><p>使用了一段时间二代 Swarm 后，特别是维护了几次服务后，会发现 <code>docker service ps</code> 中显示了很多之前失败的容器记录，很是烦人。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps web                                                                                                       [e641012]</span><br><span class="line">NAME                    IMAGE                NODE  DESIRED STATE  CURRENT STATE                ERROR                             PORTS</span><br><span class="line">web.1.uultetkovwch      nginx:1.11.3-alpine  moby  Running        Running 43 seconds ago</span><br><span class="line">\_ web.1.etb0jpr21mhe  nginx:1.11.2-alpine  moby  Shutdown       Rejected about a minute ago  <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.1.uhyl9158ldf9  nginx:1.11.2-alpine  moby  Shutdown       Rejected about a minute ago  <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.1.mwallx77rc3m  nginx:1.11.1-alpine  moby  Shutdown       Shutdown about a minute ago</span><br><span class="line">\_ web.1.zmyvszvv21ak  nginx:1.10-alpine    moby  Shutdown       Shutdown 3 minutes ago</span><br><span class="line">web.2.dp0imr8kbmad      nginx:1.11.3-alpine  moby  Running        Running 43 seconds ago</span><br><span class="line">\_ web.2.0xzwj9o8kfzn  nginx:1.11.2-alpine  moby  Shutdown       Rejected about a minute ago  <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.2.mk3g1l5js4ph  nginx:1.11.2-alpine  moby  Shutdown       Rejected about a minute ago  <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.2.v9x98vxma1q3  nginx:1.11.2-alpine  moby  Shutdown       Rejected 2 minutes ago       <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.2.vo5mvyux3vok  nginx:1.11.2-alpine  moby  Shutdown       Rejected 2 minutes ago       <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">web.3.cc3mrji1dlz2      nginx:1.11.3-alpine  moby  Running        Running 42 seconds ago</span><br><span class="line">\_ web.3.uvubn2pdceaa  nginx:1.11.2-alpine  moby  Shutdown       Rejected about a minute ago  <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.3.mt7xwl4a0bii  nginx:1.11.2-alpine  moby  Shutdown       Rejected 2 minutes ago       <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.3.cdseizjlnzoj  nginx:1.11.2-alpine  moby  Shutdown       Rejected 2 minutes ago       <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.3.kwlz5mxbu2t6  nginx:1.11.2-alpine  moby  Shutdown       Rejected 2 minutes ago       <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">web.4.zoadbqu3wtzf      nginx:1.11.3-alpine  moby  Running        Running 42 seconds ago</span><br><span class="line">\_ web.4.u6p58nzxlib9  nginx:1.11.2-alpine  moby  Shutdown       Rejected about a minute ago  <span class="string">"No such container: web.4.u6p5…"</span></span><br><span class="line">\_ web.4.kf420b73lwcc  nginx:1.11.2-alpine  moby  Shutdown       Rejected about a minute ago  <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.4.tzzmc1zuffn7  nginx:1.11.2-alpine  moby  Shutdown       Rejected 2 minutes ago       <span class="string">"No such image: nginx:1.11.2-a…"</span></span><br><span class="line">\_ web.4.mccsks74u370  nginx:1.11.1-alpine  moby  Shutdown       Shutdown 2 minutes ago</span><br><span class="line">web.5.u0i5cnh0m5jb      nginx:1.11.3-alpine  moby  Running        Running 39 seconds ago</span><br><span class="line">\_ web.5.xzv6o5hoxjay  nginx:1.11.1-alpine  moby  Shutdown       Shutdown 41 seconds ago</span><br><span class="line">\_ web.5.f0ssiwebempk  nginx:1.10-alpine    moby  Shutdown       Shutdown 3 minutes ago</span><br></pre></td></tr></table></figure>
<p>可以看到那些历史上运行过的容器，它们当然已经停止运行，保留在这里是为了帮助进行服务排障，默认情况下，会保留最后 5 个容器历史，其余的会被删除。这个参数可以在集群建立时(<code>docker swarm init</code>)或者更新时(<code>docker swarm update</code>)，可以通过参数 <code>--task-history-limit</code> 来调整。</p>
<p>但是不要因为只是看着乱，就将历史记录设的很少，因为历史记录的存在是有原因的，可以通过历史记录来进行排障。如果没有这些信息，在将来维护出现问题的时候，故障根本无从查起。</p>
<p>如果只是觉得看着乱而不想显示，直接用 <code>--filter</code> 加过滤即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps -f <span class="string">'desired-state=running'</span> web                                                                            [e641012]</span><br><span class="line">NAME                IMAGE                NODE  DESIRED STATE  CURRENT STATE           ERROR  PORTS</span><br><span class="line">web.1.uultetkovwch  nginx:1.11.3-alpine  moby  Running        Running 11 minutes ago</span><br><span class="line">web.2.dp0imr8kbmad  nginx:1.11.3-alpine  moby  Running        Running 11 minutes ago</span><br><span class="line">web.3.cc3mrji1dlz2  nginx:1.11.3-alpine  moby  Running        Running 11 minutes ago</span><br><span class="line">web.4.zoadbqu3wtzf  nginx:1.11.3-alpine  moby  Running        Running 11 minutes ago</span><br><span class="line">web.5.u0i5cnh0m5jb  nginx:1.11.3-alpine  moby  Running        Running 10 minutes ago</span><br></pre></td></tr></table></figure>
<h2 id="怎么才能让-docker-service-create-创建的服务正常退出时不重启啊？"><a href="#怎么才能让-docker-service-create-创建的服务正常退出时不重启啊？" class="headerlink" title="怎么才能让 docker service create 创建的服务正常退出时不重启啊？"></a>怎么才能让 <code>docker service create</code> 创建的服务正常退出时不重启啊？</h2><p>有些时候会有这样的需求，比如服务是由应用层的远程控制指令关闭的，这种进程退出是正常行为，并非错误。但是默认情况下，只要容器退出，引擎就视为异常，就会尝试重新调度启动这个容器。这会导致明明关了的服务，又被启动了。</p>
<p>这种情况可以使用 <code>--restart-condition=on-failure</code> 参数，这样只有在主进程退出码为 <strong>非 0</strong> 的时候，才会重启，而正常退出（<code>exited code = 0</code>) 无需重启。</p>
<h1 id="Docker-Machine-相关问题-5"><a href="#Docker-Machine-相关问题-5" class="headerlink" title="Docker Machine 相关问题 (5)"></a>Docker Machine 相关问题 <code>(5)</code></h1><h2 id="打开命令行后，看到下载啥-boot2docker-iso，然后总是超时失败，怎么办？"><a href="#打开命令行后，看到下载啥-boot2docker-iso，然后总是超时失败，怎么办？" class="headerlink" title="打开命令行后，看到下载啥 boot2docker.iso，然后总是超时失败，怎么办？"></a>打开命令行后，看到下载啥 <code>boot2docker.iso</code>，然后总是超时失败，怎么办？</h2><p>装了 Docker Toolbox 的 Windows 用户，或者第一次使用 <code>docker-machine</code> 创建本地 VirtualBox 虚拟机的用户，经常会看到这样的报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(default) Latest release <span class="keyword">for</span> github.com/boot2docker/boot2docker is v17.06.2-ce</span><br><span class="line">(default) Downloading /Users/jessie/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v17.06.2-ce/boot2docker.iso...</span><br></pre></td></tr></table></figure>
<p>然后经过漫长的等待后，说超时、或者下载失败，最后创建虚拟机失败。</p>
<p>这首先还是先去<em>感谢</em>伟大的墙及其亲属，没有他们的作祟，这个错误基本出现不了。</p>
<p>众所周知，我们通常所说的 Docker 是基于 Linux 内核的。因此在 Windows 环境中，Docker Toolbox 会使用 Docker Machine 建立一个名为 <code>default</code> 的 VirtualBox Linux 虚拟机，来进行 Docker 操作。由于只需要运行 Docker，因此这个 Linux 可以非常精简，不需要任何复杂的系统功能。由于历史原因，这个微缩版的 Linux 系统是被称为 <code>boot2docker</code> 的系统。</p>
<p>而 Docker Machine 在建立虚拟机的时候，会从<a href="https://github.com/boot2docker/boot2docker/releases" target="_blank" rel="noopener">网上</a>检查 Docker 最新的版本是什么，如果发现本地缓存中的 ISO 不存在，或者不是最新版本，那就会去从官网下载最新版本的 ISO 文件。而这个文件，就是提示中所说的 <code>boot2docker.iso</code> 文件。由于伟大的墙经常做出刷出镜率的行为，从 GitHub 上下载东西经常会被干扰和阻断。这就是为啥经常出现超时、或者无法访问的问题。</p>
<p>解决办法很简单，直接下不行，那就手工翻墙下……😹</p>
<p>当然，还有另一个办法，可以用迅雷下载。迅雷拥有<em>细思极恐</em>的下载缓存，基本用迅雷下载过的东西，迅雷的服务器上都会缓存一份😨……。如果你用迅雷下载这个 <code>boot2docker.iso</code> 的话，很大的几率迅雷的缓存服务器上已经有了一份这个文件。因此如果存在，迅雷会直接从它的缓存服务器上帮你把这个文件下载下来，这样就避免了翻墙了。</p>
<p>从上面的报错中，我们已经得知，需要下载的链接为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/boot2docker/boot2docker/releases/download/v17.06.2-ce/boot2docker.iso</span><br></pre></td></tr></table></figure>
<p>将这个链接添加到你的迅雷下载任务中去，<strong>注意：换成你的报错中的链接！！</strong>。</p>
<p>下载完成后，确保文件名为 <code>boot2docker.iso</code>，然后用 <code>shasum -a 256 boot2docker.iso</code> 校验一下文件的完整性，确保和<a href="https://github.com/boot2docker/boot2docker/releases" target="_blank" rel="noopener">官网</a><strong>对应的版本</strong>一样后，再放置到报错中的那个位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/jessie/.docker/machine/cache/boot2docker.iso</span><br></pre></td></tr></table></figure>
<p><strong>注意：换成你的报错中的那个文件位置！！</strong></p>
<p>手工下载好后，重新运行 Docker Quickstart Terminal，或者重新使用 <code>docker-machine</code> 创建 Virtualbox 虚拟机，一切就应该正常了。</p>
<h2 id="装完-Docker-Toolbox-后发现下载镜像速度太慢，是不是需要修改什么配置文件？"><a href="#装完-Docker-Toolbox-后发现下载镜像速度太慢，是不是需要修改什么配置文件？" class="headerlink" title="装完 Docker Toolbox 后发现下载镜像速度太慢，是不是需要修改什么配置文件？"></a>装完 Docker Toolbox 后发现下载镜像速度太慢，是不是需要修改什么配置文件？</h2><p>安装 Docker Toolbox 时，安装程序会使用 <code>docker-machine</code> 为你创建一个名为 <code>default</code> 的虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox default</span><br></pre></td></tr></table></figure>
<p>这个虚拟机没有加任何参数，因此对于拥有伟大的墙的国内网络来说，有些不方便使用。所以最简单的做法是在安装完 Docker Toolbox 后，删掉默认的虚拟机，然后重新创建该虚拟机，创建时加入有中国特色的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-machine rm default</span><br><span class="line"></span><br><span class="line">docker-machine create -d virtualbox \</span><br><span class="line">     --engine-registry-mirror https://registry.docker-cn.com \</span><br><span class="line">     --engine-insecure-registry 192.168.99.0/24 \</span><br><span class="line">     --engine-storage-driver overlay2 \</span><br><span class="line">     default</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除 <code>default</code> 虚拟机的时候要注意，其中镜像、容器等内容都会被删除。</p>
</blockquote>
<h2 id="如何在-Docker-Toolbox-中创建的-default-虚拟机中添加DOCKER-OPTS之类的配置？"><a href="#如何在-Docker-Toolbox-中创建的-default-虚拟机中添加DOCKER-OPTS之类的配置？" class="headerlink" title="如何在 Docker Toolbox 中创建的 default 虚拟机中添加DOCKER_OPTS之类的配置？"></a>如何在 Docker Toolbox 中创建的 <code>default</code> 虚拟机中添加<code>DOCKER_OPTS</code>之类的配置？</h2><p>其实在最初创建该docker host时，就可以利用 <code>docker-machine</code> 指定引擎配置参数，如果不要紧，可以直接rm掉这个虚拟机，重新建立。</p>
<p>如果不方便 rm 掉这个虚拟机，可以 <code>docker-machine ssh</code> 进入这个虚拟机，然后修改 <code>/var/lib/boot2docker/profile</code> 文件，修改里面的 <code>EXTRA_ARGS</code> 参数即可。</p>
<h2 id="为什么我安装好的Docker没有docker-machine-命令"><a href="#为什么我安装好的Docker没有docker-machine-命令" class="headerlink" title="为什么我安装好的Docker没有docker-machine 命令"></a>为什么我安装好的Docker没有<code>docker-machine</code> 命令</h2><p>装好的docker默认没有<code>docker-machine</code>命令，它是用于操纵虚拟机的命令，一般配合<code>Virtual Box</code>使用。</p>
<h2 id="docker-machine-创建的主机怎么直接-ssh-进去？改了-root-密码好像也没用？"><a href="#docker-machine-创建的主机怎么直接-ssh-进去？改了-root-密码好像也没用？" class="headerlink" title="docker-machine 创建的主机怎么直接 ssh 进去？改了 root 密码好像也没用？"></a><code>docker-machine</code> 创建的主机怎么直接 <code>ssh</code> 进去？改了 <code>root</code> 密码好像也没用？</h2><p><code>docker-machine</code> 创建的主机，会遵循安全最佳实践，因此一般不会允许 <code>root</code> 登录，而且一般不会允许密码登录，只允许<code>密钥</code>登录（也就是很多国内文章称为的免密登录，其实并非免密）。</p>
<p>因此，使用密钥 <code>~/.docker/machine/machines/&lt;机器名&gt;/id_rsa</code> 登录即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.docker/machine/machines/default/id_rsa \</span><br><span class="line">    -o UserKnownHostsFile=/dev/null \</span><br><span class="line">    -o StrictHostKeyChecking=no \</span><br><span class="line">    docker@$(docker-machine ip default)</span><br></pre></td></tr></table></figure>
<p>这个例子中连接的是 <code>default</code> 这个机器，需要连接其它的机器换成别的即可。另外的两个 <code>-o</code> 的参数是让其不要校验服务器密钥，这当然是不安全的，不过这里只是试验的虚拟机，所以没关系。</p>
<h2 id="docker-machine-使用-d-generic-时，指定用户-generic-ssh-user-后发现要-sudo-密码，结果报错退出，这是怎么回事？"><a href="#docker-machine-使用-d-generic-时，指定用户-generic-ssh-user-后发现要-sudo-密码，结果报错退出，这是怎么回事？" class="headerlink" title="docker-machine 使用 -d generic 时，指定用户 --generic-ssh-user 后发现要 sudo 密码，结果报错退出，这是怎么回事？"></a><code>docker-machine</code> 使用 <code>-d generic</code> 时，指定用户 <code>--generic-ssh-user</code> 后发现要 <code>sudo</code> 密码，结果报错退出，这是怎么回事？</h2><p>你应该再仔细看看 <code>generic</code> 的官方文档：<a href="https://docs.docker.com/machine/drivers/generic/#/sudo-privileges" target="_blank" rel="noopener">https://docs.docker.com/machine/drivers/generic/#/sudo-privileges</a></p>
<p>里面说的很清楚，默认用户是 <code>root</code>，但如果通过 <code>--generic-ssh-user</code> 指定其它用户的话，该用户必须拥有无密码<code>sudo</code>的能力，换句话说，就是在 <code>sudoers</code> 文件中对该用户配置 <code>NOPASSWD</code>。</p>
<h1 id="Docker-Registry-相关问题-10"><a href="#Docker-Registry-相关问题-10" class="headerlink" title="Docker Registry 相关问题 (10)"></a>Docker Registry 相关问题 <code>(10)</code></h1><h2 id="我-docker-push-的时候怎么报-authentication-required-错误？"><a href="#我-docker-push-的时候怎么报-authentication-required-错误？" class="headerlink" title="我 docker push 的时候怎么报 authentication required 错误？"></a>我 <code>docker push</code> 的时候怎么报 <code>authentication required</code> 错误？</h2><p>因为你没有登录。如果是向 Docker Hub 推送镜像，需要在注册一个用户： <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h2 id="为什么我-docker-login-失败了？我注册用户了，在网站登录也没问题呀？"><a href="#为什么我-docker-login-失败了？我注册用户了，在网站登录也没问题呀？" class="headerlink" title="为什么我 docker login 失败了？我注册用户了，在网站登录也没问题呀？"></a>为什么我 <code>docker login</code> 失败了？我注册用户了，在网站登录也没问题呀？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don<span class="string">'t have a Docker ID, </span></span><br><span class="line"><span class="string">head over to https://hub.docker.com to create one.</span></span><br><span class="line"><span class="string">Username: pinkman@heisenb.org</span></span><br><span class="line"><span class="string">Password:</span></span><br><span class="line"><span class="string">Error response from daemon: Get https://registry-1.docker.io/v2/: unauthorized: incorrect username or password</span></span><br></pre></td></tr></table></figure>
<p>呃，这里应该是<strong>用户名</strong>的，怎么写了个<strong>电子邮件</strong> <code>pinkman@heisenb.org</code> 呢？虽然 <a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub 网站</a>允许你使用用户名或电子邮件登录，但是 <code>docker login</code> 只可以使用用户名，换成你的用户名登录就好了。</p>
<h2 id="我注册用户-pinkman-了，怎么还是无法-docker-push-mrwhite-xxx-啊？"><a href="#我注册用户-pinkman-了，怎么还是无法-docker-push-mrwhite-xxx-啊？" class="headerlink" title="我注册用户 pinkman 了，怎么还是无法 docker push mrwhite/xxx 啊？"></a>我注册用户 <code>pinkman</code> 了，怎么还是无法 <code>docker push mrwhite/xxx</code> 啊？</h2><p>😒……因为你 <code>push</code> 到别人（<strong>mrwhite</strong>）的 <code>repo</code> 了，你只能 <code>push</code> 到 <code>pinkman/xxx</code> 下。</p>
<h2 id="不管用啊，我这回-docker-push-pinkman-xxx-了，怎么告诉我镜像不存在啊？"><a href="#不管用啊，我这回-docker-push-pinkman-xxx-了，怎么告诉我镜像不存在啊？" class="headerlink" title="不管用啊，我这回 docker push pinkman/xxx 了，怎么告诉我镜像不存在啊？"></a>不管用啊，我这回 <code>docker push pinkman/xxx</code> 了，怎么告诉我镜像不存在啊？</h2><p>😓……因为你没有 <code>tag</code> 对应的镜像为 <code>pinkman/xxx</code>。</p>
<p>所有这些问题，都是由于你没有去看文档，建议不要这么一次次的瞎撞，去看官网文档：</p>
<p><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">https://docs.docker.com/get-started/</a></p>
<h2 id="docker-push-到私有-registry-总是不成功，怎么办？"><a href="#docker-push-到私有-registry-总是不成功，怎么办？" class="headerlink" title="docker push 到私有 registry 总是不成功，怎么办？"></a><code>docker push</code> 到私有 <code>registry</code> 总是不成功，怎么办？</h2><p>如果在报错中看到了 <code>https</code>，那很可能是因为 <code>registry</code> 没有配置证书。</p>
<p>很多人最开始配置 <code>registry</code> 的时候，为了简单而没有配置 <code>TLS</code> 证书。</p>
<p>这是<strong>不安全</strong>的做法，在 Docker 中<strong>不推荐</strong>使用。因此，刻意的增加了使用这种不安全 <code>registry</code> 的复杂度。使用者必须在 <code>dockerd</code> 配置中，明确声明要使用这些不安全的 <code>registry</code>。</p>
<p>比如，在 <a href="http://www.ubuntu.com/download/server" target="_blank" rel="noopener">Ubuntu 16.04</a> 中，编辑 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code> 中的 <code>ExecStart=</code> 的结尾，加入 <code>--insecure-registry=192.168.99.100:5000</code>，将 <code>192.168.99.100:5000</code> 替换成你的 <code>registry</code> 地址。如果有很多 <code>registry</code>，可以设置多组。或者如果虚拟机的 <code>IP</code> 总是变化，也可以使用 <code>CIDR</code> 的形式，比如 <code>--insecure-registry=192.168.99.0/24</code>。</p>
<p>不过测试过后，一定要<a href="https://docs.docker.com/registry/deploying/#/get-a-certificate" target="_blank" rel="noopener">配上 TLS 证书</a>。现在 <a href="https://letsencrypt.org/getting-started/" target="_blank" rel="noopener">Let’s Encrpyt</a> 已经支持 <code>DNS</code> 认证了，不需要暴露内部的机器于公网，用其<a href="https://certbot.eff.org/" target="_blank" rel="noopener">脚本</a>自动取得免费证书是很方便的。</p>
<h2 id="我-docker-push-了很多镜像到私有的-registry-上，怎么才能查看上面都有啥？或者搜索？"><a href="#我-docker-push-了很多镜像到私有的-registry-上，怎么才能查看上面都有啥？或者搜索？" class="headerlink" title="我 docker push 了很多镜像到私有的 registry 上，怎么才能查看上面都有啥？或者搜索？"></a>我 <code>docker push</code> 了很多镜像到私有的 <code>registry</code> 上，怎么才能查看上面都有啥？或者搜索？</h2><p>两种办法，一种是使用 Registry V2 API。可以列出所有镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://&lt;私有registry地址&gt;/v2/_catalog</span><br></pre></td></tr></table></figure>
<p>如果私有 Registry 尚支持 V1 API（<strong>已经废弃</strong>），可以使用 <code>docker search</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search &lt;私有registry地址&gt;/&lt;关键字&gt;</span><br></pre></td></tr></table></figure>
<h2 id="docker-search-为什么没有办法在私有-Registry-中用？"><a href="#docker-search-为什么没有办法在私有-Registry-中用？" class="headerlink" title="docker search 为什么没有办法在私有 Registry 中用？"></a><code>docker search</code> 为什么没有办法在私有 <code>Registry</code> 中用？</h2><p><code>docker search</code> 命令所使用的 <code>API</code> 是 <code>/search</code>，而这是已经废弃的 Registry <code>v1</code> 的 API，目前的 Registry 都已经是 <code>v2</code> API了，早就不支持 <code>v1</code> API 了，所以自然用不了。而 <code>v2</code> 的 API 中只有列表 <code>/_catalogs</code> API，没有同等的 <code>search</code> API。所以事实上 <code>docker search</code> 命令已经废弃了。</p>
<p>另外，<code>docker search</code> 功能太过局限，其实并不实用。远不如直接去 <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">Docker Hub 网站</a> 搜索。Docker Hub 网站上，可以搜索查找镜像，找到后还可以看对应的<strong>标签</strong>、镜像<strong>使用文档</strong>、每个镜像的 <code>Dockerfile</code>、<strong>安全扫描结果</strong>等等。</p>
<p>如果只使用开源的 <code>docker registry</code> 自建仓库的话，目前只能用 <code>API</code> 访问其内容。除此以外，官方还有商业版的 <code>Docker Trusted Registry</code> 项目，里面有一些增值的内容在里面，提供了类似于 Docker Hub 似得 UI 等，可以搜索过滤。目前 Docker Trusted Registry 属于 <a href="https://www.docker.com/products/docker-datacenter" target="_blank" rel="noopener">Docker Datacenter</a> 的一部分。</p>
<p>另外，第三方也有一些提供了UI的。比如 <a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">VMWare Harbor</a>。VMWare Harbor 是 VMWare 中国基于开源 docker registry 进一步开发的项目，有更复杂的上层逻辑。包括用户管理、镜像管理、Registry集群之类的功能。Harbor 是开源的，免费的。</p>
<p>第三方的 registry 还有 Java 世界里常见的 Nexus，其<a href="https://github.com/sonatype/docker-nexus3" target="_blank" rel="noopener">第三代</a>支持 Docker Registry API。</p>
<h2 id="如何删除私有-registry-中的镜像？"><a href="#如何删除私有-registry-中的镜像？" class="headerlink" title="如何删除私有 registry 中的镜像？"></a>如何删除私有 <code>registry</code> 中的镜像？</h2><p>首先，在默认情况下，docker registry 是不允许删除镜像的，需要在配置<code>config.yml</code>中启用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">delete:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后，使用 API <code>GET /v2/&lt;镜像名&gt;/manifests/&lt;tag&gt;</code> 来取得要删除的<code>镜像:Tag</code>所对应的 <code>digest</code>。</p>
<p>Registry <code>2.3</code> 以后，必须加入头 <code>Accept: application/vnd.docker.distribution.manifest.v2+json</code>，否则取到的 <code>digest</code> 是错误的，这是为了防止误删除。</p>
<p>比如，要删除 <code>myimage:latest</code> 镜像，那么取得 <code>digest</code> 的命令是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl --header <span class="string">"Accept: application/vnd.docker.distribution.manifest.v2+json"</span> \</span><br><span class="line">  -I -X HEAD http://192.168.99.100:5000/v2/myimage/manifests/latest \</span><br><span class="line">  | grep Digest</span><br><span class="line">Docker-Content-Digest: sha256:3a07b4e06c73b2e3924008270c7f3c3c6e3f70d4dbb814ad8bff2697123ca33c</span><br></pre></td></tr></table></figure>
<p>然后调用 API <code>DELETE /v2/&lt;镜像名&gt;/manifests/&lt;digest&gt;</code> 来删除镜像。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  -X DELETE http://192.168.99.100:5000/v2/myimage/manifests/sha256:3a07b4e06c73b2e3924008270c7f3c3c6e3f70d4dbb814ad8bff2697123ca33c</span><br></pre></td></tr></table></figure>
<p>至此，镜像已从 <code>registry</code> 中标记删除，外界访问 <code>pull</code> 不到了。但是 <code>registry</code> 的本地空间并未释放，需要等待垃圾收集才会释放。而垃圾收集不可以在线进行，必须停止 <code>registry</code>，然后执行。比如，假设 <code>registry</code> 是用 Compose 运行的，那么下面命令用来垃圾收集：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">docker run -it --name gc --rm --volumes-from registry_registry_1 registry:2 garbage-collect /etc/registry/config.yml</span><br><span class="line">docker-compose start</span><br></pre></td></tr></table></figure>
<p>其中 <code>registry_registry_1</code> 可以替换为实际的 <code>registry</code> 的容器名，而 <code>/etc/registry/config.yml</code> 则替换为实际的 <code>registry</code> 配置文件路径。</p>
<p>参考官网文档：</p>
<p><a href="https://docs.docker.com/registry/configuration/#/delete" target="_blank" rel="noopener">https://docs.docker.com/registry/configuration/#/delete</a></p>
<p><a href="https://docs.docker.com/registry/spec/api/#/deleting-an-image" target="_blank" rel="noopener">https://docs.docker.com/registry/spec/api/#/deleting-an-image</a></p>
<h2 id="使用国内镜像还是慢，公司内好多-docker-主机，都需要去重复下载镜像，咋办？"><a href="#使用国内镜像还是慢，公司内好多-docker-主机，都需要去重复下载镜像，咋办？" class="headerlink" title="使用国内镜像还是慢，公司内好多 docker 主机，都需要去重复下载镜像，咋办？"></a>使用国内镜像还是慢，公司内好多 docker 主机，都需要去重复下载镜像，咋办？</h2><p>在局域网内，本地架设个 Docker Registry mirror，作为缓存即可。</p>
<p>建立一个空目录，并且添加 Registry 的配置文件 <code>config.yml</code>，其内容为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line"><span class="attr">    fields:</span></span><br><span class="line"><span class="attr">        service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line"><span class="attr">    cache:</span></span><br><span class="line"><span class="attr">        blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line"><span class="attr">    filesystem:</span></span><br><span class="line"><span class="attr">        rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="attr">    addr:</span> <span class="string">:5000</span></span><br><span class="line"><span class="attr">    headers:</span></span><br><span class="line"><span class="attr">        X-Content-Type-Options:</span> <span class="string">[nosniff]</span></span><br><span class="line"><span class="attr">health:</span></span><br><span class="line"><span class="attr">    storagedriver:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">        threshold:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">proxy:</span></span><br><span class="line"><span class="attr">    remoteurl:</span> <span class="attr">https://registry.docker-cn.com</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里的 <code>remoteurl</code>，其地址可以填写任意一个国内镜像加速器的地址，这里使用的是 Docker 官方在中国的镜像站点。如果在国外的话，可以使用 Docker Hub 的官方地址：<code>https://registry-1.docker.io</code>。</p>
</blockquote>
<p>然后，建立个 <code>docker-compose.yml</code> 文件方便启动这个服务：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    mirror:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">registry:2</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">./config.yml:/etc/docker/registry/config.yml</span></span><br></pre></td></tr></table></figure>
<p>然后用 Docker Compose 启动这个镜像服务：<code>docker-compose up -d</code></p>
<p>然后在局域网中的所有 Docker 主机中的 Docker 引擎配置中，都添加一条 <code>--registry-mirror=&lt;这个镜像服务器的地址&gt;</code></p>
<p>首先用 <code>docker pull</code> 下载一个本地不存在的镜像，看一下时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ time docker pull php:7-fpm-alpine</span><br><span class="line">7-fpm-alpine: Pulling from library/php</span><br><span class="line">e110a4a17941: Pull complete</span><br><span class="line">d9f63633faf6: Pull complete</span><br><span class="line">ac309a5bc5d5: Pull complete</span><br><span class="line">4523ec888a62: Pull complete</span><br><span class="line">6a77f79ab9b5: Pull complete</span><br><span class="line">27243562b67c: Pull complete</span><br><span class="line">33e1803456c2: Pull complete</span><br><span class="line">a1219b0a1418: Pull complete</span><br><span class="line">Digest: sha256:f7d6f6844df64f8f615fa50ca28b3f1ad82be0a2dcde0b55205d31c1bb9f4820</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> php:7-fpm-alpine</span><br><span class="line">docker pull php:7-fpm-alpine  0.07s user 0.07s system 0% cpu 2:30.43 total</span><br></pre></td></tr></table></figure>
<p>上面我们下载了 php:7-fpm-alpine，用时 2 分 30秒，然后我们删掉镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi php:7-fpm-alpine</span><br><span class="line">Untagged: php:7-fpm-alpine</span><br><span class="line">Deleted: sha256:b80ca1f4f99d13e00ac6ef13aca7c1ef6e2fb83ec2fe6a035e8beeeb05afb4b6</span><br><span class="line">Deleted: sha256:69ee0f31988504dc3e3b068476f11d06b43fc34465a1c58d351406b9d2368e7a</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后重新下载镜像，测试时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ time docker pull php:7-fpm-alpine</span><br><span class="line">7-fpm-alpine: Pulling from library/php</span><br><span class="line">e110a4a17941: Pull complete</span><br><span class="line">d9f63633faf6: Pull complete</span><br><span class="line">ac309a5bc5d5: Pull complete</span><br><span class="line">4523ec888a62: Pull complete</span><br><span class="line">6a77f79ab9b5: Pull complete</span><br><span class="line">27243562b67c: Pull complete</span><br><span class="line">33e1803456c2: Pull complete</span><br><span class="line">a1219b0a1418: Pull complete</span><br><span class="line">Digest: sha256:f7d6f6844df64f8f615fa50ca28b3f1ad82be0a2dcde0b55205d31c1bb9f4820</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> php:7-fpm-alpine</span><br><span class="line">docker pull php:7-fpm-alpine  0.05s user 0.04s system 0% cpu 13.778 total</span><br></pre></td></tr></table></figure>
<p>这次由于该 docker image 本地 mirror 缓存了，所以用时约14秒，速度大大提高了。</p>
<p>参考官网文档：</p>
<p>服务端：<a href="https://docs.docker.com/registry/configuration/#/proxy" target="_blank" rel="noopener">https://docs.docker.com/registry/configuration/#/proxy</a></p>
<p>客户端：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/</a></p>
<h2 id="自己架的-registry-怎么任何用户都可以取到镜像？这不安全啊？"><a href="#自己架的-registry-怎么任何用户都可以取到镜像？这不安全啊？" class="headerlink" title="自己架的 registry 怎么任何用户都可以取到镜像？这不安全啊？"></a>自己架的 <code>registry</code> 怎么任何用户都可以取到镜像？这不安全啊？</h2><p>那是因为没有加认证，不加认证的意思就是允许任何人访问的。</p>
<p>添加认证有两种方式：</p>
<ul>
<li>Registry 配置中加入认证： <a href="https://docs.docker.com/registry/configuration/#/auth" target="_blank" rel="noopener">https://docs.docker.com/registry/configuration/#/auth</a></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auth:</span></span><br><span class="line"><span class="attr">  token:</span></span><br><span class="line"><span class="attr">    realm:</span> <span class="string">token-realm</span></span><br><span class="line"><span class="attr">    service:</span> <span class="string">token-service</span></span><br><span class="line"><span class="attr">    issuer:</span> <span class="string">registry-token-issuer</span></span><br><span class="line"><span class="attr">    rootcertbundle:</span> <span class="string">/root/certs/bundle</span></span><br><span class="line"><span class="attr">  htpasswd:</span></span><br><span class="line"><span class="attr">    realm:</span> <span class="string">basic-realm</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/path/to/htpasswd</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前端架设 nginx 进行认证：<a href="https://docs.docker.com/registry/recipes/nginx/" target="_blank" rel="noopener">https://docs.docker.com/registry/recipes/nginx/</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /v2/ &#123;</span><br><span class="line">    ...</span><br><span class="line">    auth_basic <span class="string">"Registry realm"</span>;</span><br><span class="line">    auth_basic_user_file /etc/nginx/conf.d/nginx.htpasswd;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="系统相关问题-7"><a href="#系统相关问题-7" class="headerlink" title="系统相关问题 (7)"></a>系统相关问题 <code>(7)</code></h1><h2 id="CentOS-RHEL-红帽系统特有问题"><a href="#CentOS-RHEL-红帽系统特有问题" class="headerlink" title="CentOS/RHEL 红帽系统特有问题"></a>CentOS/RHEL 红帽系统特有问题</h2><h3 id="在-CentOS-6-上安装后怎么最高只有-Docker-1-7-这个版本？"><a href="#在-CentOS-6-上安装后怎么最高只有-Docker-1-7-这个版本？" class="headerlink" title="在 CentOS 6 上安装后怎么最高只有 Docker 1.7 这个版本？"></a>在 CentOS 6 上安装后怎么最高只有 Docker 1.7 这个版本？</h3><p>Docker 已经不再支持 CentOS 6 了，现在看到的是很久以前的老版本，之后再也没有发布过 CentOS 6 的版本。</p>
<p>所以不要再在 CentOS 6上用 Docker 了。换 CentOS 7 或者 Ubuntu 吧。</p>
<h3 id="挂载宿主目录，结果-Permission-denied，没权限"><a href="#挂载宿主目录，结果-Permission-denied，没权限" class="headerlink" title="挂载宿主目录，结果 Permission denied，没权限"></a>挂载宿主目录，结果 <code>Permission denied</code>，没权限</h3><p>原因是 <code>CentOS</code>/<code>RHEL</code>中的 <code>SELinux</code> 限制了目录权限。需要添加规则。</p>
<p>下面是 <code>man docker-run</code> 的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">When  using  SELinux,  be  aware that the host has no knowledge of container</span><br><span class="line">SELinux policy. Therefore, in the above example, if SELinux policy  is enforced,</span><br><span class="line">the /var/db directory is not  writable to the container. A &quot;Permission Denied&quot;</span><br><span class="line">message will occur and an avc: message in the host&apos;s syslog.</span><br><span class="line"></span><br><span class="line">To  work  around  this, at time of writing this man page, the following command</span><br><span class="line">needs to be run in order for the  proper  SELinux  policy  type label to be</span><br><span class="line">attached to the host directory:</span><br></pre></td></tr></table></figure>
<p>因此需要对特定目录添加规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chcon -Rt svirt_sandbox_file_t /var/db</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/" target="_blank" rel="noopener">http://www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/</a></p>
<h3 id="Docker的-var-lib-docker-devicemapper-占用空间不断增长-怎么破？"><a href="#Docker的-var-lib-docker-devicemapper-占用空间不断增长-怎么破？" class="headerlink" title="Docker的 /var/lib/docker/devicemapper 占用空间不断增长, 怎么破？"></a>Docker的 <code>/var/lib/docker/devicemapper</code> 占用空间不断增长, 怎么破？</h3><p>这类问题一般是 CentOS/RHEL 红帽系的问题，CentOS 这类红帽系统中，由于不像 <code>Ubuntu</code> 那样有成熟的 Union FS实现(如<code>aufs</code>)，所以只能使用 <code>devicemapper</code>，而默认使用的是<code>lvm-loop</code>，也就是用一个稀疏文件来当成一个块设备，给<code>devicemapper</code>用，作为Docker镜像容器文件系统。这是非常不推荐使用的，性能很差不说，不稳定，还有很多 bug，如果没办法换 <code>Ubuntu</code>/<code>Debian</code> 系统，那么最起码应该建立块设备（分区、卷）给 <code>devicemapper</code> 用。</p>
<p>参考官网文档：<a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production</a></p>
<p>严格来说 CentOS/RHEL 7 中实际上有一个 Union FS 实现，虽然 CentOS/RHEL 7 的内核是 3.10，不过红帽从 Linux 3.18 backport 回来了 <code>overlay</code> fs 的驱动。但是，红帽自己都在官方的发布声明中说能不要用就不用。</p>
<p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/7.2_Release_Notes/technology-preview-file_systems.html" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/7.2_Release_Notes/technology-preview-file_systems.html</a></p>
<h3 id="CentOS-7-的内核太老了-3-10，是不是很多-Docker-功能不支持？"><a href="#CentOS-7-的内核太老了-3-10，是不是很多-Docker-功能不支持？" class="headerlink" title="CentOS 7 的内核太老了 3.10，是不是很多 Docker 功能不支持？"></a>CentOS 7 的内核太老了 3.10，是不是很多 Docker 功能不支持？</h3><p>是的，有一些功能无法支持，比如 <code>overlay2</code> 的存储驱动就无法在 CentOS 上使用，但并非所有需要高版本内核的功能都不支持。</p>
<p>比如 Overlay FS 需要 Linux 3.18，而 Overlay network 需要 Linux 3.16。而 CentOS 7 内核为 3.10，确实低于这些版本需求。但实际上，红帽团队会把一些新内核的功能 backport 回老的内核。比如 <code>overlay fs</code>等。所以一些功能依旧会支持。因此 CentOS 7 的 Docker Engine 同样可以支持 <code>overlay network</code>，以及 <code>overlay</code> 存储驱动（不是<code>overlay2</code>）。因此在新的 Docker 1.12 中，CentOS/RHEL 7 才有可能支持 Swarm Mode。</p>
<p>即使红帽会把一些高版本内核的功能 backport 回 3.10 内核中，这种修修补补出来的功能，并不一定稳定。如果观察 Docker Issue 列表，会发现大量的由于 CentOS 老内核导致的问题，特别是在使用了 1.12 内置的 Swarm Mode 集群功能后，存储、网络出现的问题很多。</p>
<p>所以依旧建议使用其它维护内核版本升级的 Linux 发行版，如 Ubuntu。</p>
<h3 id="CentOS-7-RHEL-7-升级-1-12-后，无法启动，怎么回事？"><a href="#CentOS-7-RHEL-7-升级-1-12-后，无法启动，怎么回事？" class="headerlink" title="CentOS 7/RHEL 7 升级 1.12 后，无法启动，怎么回事？"></a>CentOS 7/RHEL 7 升级 1.12 后，无法启动，怎么回事？</h3><p>一些人在升级之后，启动 Docker 时发现无法启动，而在报错中看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unit docker.socket failed to load: No such file or directory.</span><br></pre></td></tr></table></figure>
<p>其原因是由于从 <code>1.12</code> 开始，不需要在 <code>systemd</code> 中写个 <code>docker.socket</code> 文件了，所以这个文件就随升级而删除了。而 <code>docker.service</code> 由于被修改过（或别的什么原因），导致 <code>yum</code> 升级的时候没有替换这个文件。于是出现了旧的 <code>docker.service</code> 中配置要求有 <code>docker.socket</code> 文件，而这个文件已经在新的版本中删除了，所以导致启动错误。</p>
<p>解决办法很简单，直接打开 <code>docker.service</code>，将其参照 <code>1.12</code> 的默认配置文件修改即可。寻找到 <code>Required=docker.socket</code> 那行，删掉。然后寻找到 <code>docker daemon</code>(或者 <code>dockerd</code>) 那行，将其后的 <code>-H fd://</code> 删掉。并且进一步将 <code>docker daemon</code> 改为 <code>dockerd</code>，因为从 <code>1.12</code> 开始改名叫这个了。保存退出重启服务即可。</p>
<h2 id="Mac-Windows-相关问题"><a href="#Mac-Windows-相关问题" class="headerlink" title="Mac / Windows 相关问题"></a>Mac / Windows 相关问题</h2><h3 id="为什么在Mac下挂载宿主目录-usr-local-nginx不成功？"><a href="#为什么在Mac下挂载宿主目录-usr-local-nginx不成功？" class="headerlink" title="为什么在Mac下挂载宿主目录/usr/local/nginx不成功？"></a>为什么在<code>Mac</code>下挂载宿主目录<code>/usr/local/nginx</code>不成功？</h3><p>虽然 Docker 团队尽量让使用 <a href="https://www.docker.com/products/docker-toolbox" target="_blank" rel="noopener">Docker Toolbox</a>, <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker for Mac</a> and <a href="https://docs.docker.com/docker-for-windows" target="_blank" rel="noopener">Docker for Windows</a> 的用户感觉操作 Docker 就像在 Linux 下一样，但实际上在 Mac/Windows 上并非是直接运行 Docker 的。中间经过了一个 Linux 虚拟机，而 Docker 运行在那个虚拟机里。</p>
<p>因此 Mac 主机上的目录实际上并不是 Docker 眼中的宿主目录，为了让用户尽量感觉不到这个差异，<code>Boot2Docker</code> 或者 <code>Docker for Mac / Windows</code> 中，将一部分物理主机的目录映射到了 Linux 虚拟机中，这样其上 Docker 就可以访问到这些物理机的目录了。</p>
<p>出于安全考虑，并不会把物理机的所有目录都映射到 Linux 虚拟机内。一般来说只有当前用户目录在内的一些目录会被映射到 Linux 虚拟机内，比如 <code>/Users</code>, <code>/Volumes</code> 等。</p>
<p>对于 <code>Docker for Mac</code> 的用户，可以直接在配置界面 <code>File Sharing</code> 中添加额外的映射目录，但是，出于安全考虑，不添加额外映射，而使用当前用户目录下的目录，是更好地做法。</p>
<h3 id="听说-Windows-10、Windows-Server-2016-内置-Docker-了？和-Docker-官网下载的-Docker-for-Windows-有什么区别啊？"><a href="#听说-Windows-10、Windows-Server-2016-内置-Docker-了？和-Docker-官网下载的-Docker-for-Windows-有什么区别啊？" class="headerlink" title="听说 Windows 10、Windows Server 2016 内置 Docker 了？和 Docker 官网下载的 Docker for Windows 有什么区别啊？"></a>听说 Windows 10、Windows Server 2016 内置 Docker 了？和 Docker 官网下载的 Docker for Windows 有什么区别啊？</h3><p>二者完全不同。</p>
<p>Windows 10 或者 Windows Server 2016 自带的 Docker，被称为 <code>Docker on Windows</code>，其运行于 Windows NT 内核至上，以 Docker 类似的方式提供 Windows 容器服务，因此只可以运行 Windows 程序。</p>
<p>而 Docker 官网下载的，被称为 <code>Docker for Windows</code>。这是我们常说的 Docker，它是运行于 Linux 内核上的 Docker。在 Windows 上运行时实际上是在 Hyper-V 上的一个 Alpine Linux 虚拟机上运行的 Docker。它只可以运行 Linux 程序。</p>
<p><code>Docker on Windows</code> 极为臃肿，最小镜像也近 GB，启动时间并不快；而 <code>Docker for Windows</code> 则是正常的 Docker，最小镜像也就几十 KB，一般的镜像都在几百兆以内，而且启动时间基本是毫秒级。</p>
<p>希望对 <code>Docker on Windows</code> 有所了解的童鞋可以看一下一个 DockerCon 的视频，是由微软负责 Docker 项目的构架师进行的介绍，从中可以看到第一手的信息，Windows 到底有多惨。这个视频我做了笔记，可以到这里看一下：&lt;/post/docker-2016-08-12-video-windows-server-and-docker.html&gt;</p>
<h1 id="其它问题-1"><a href="#其它问题-1" class="headerlink" title="其它问题 (1)"></a>其它问题 <code>(1)</code></h1><h2 id="Kubernetes-这词咋念啊？为啥有人管它叫-k8s-？"><a href="#Kubernetes-这词咋念啊？为啥有人管它叫-k8s-？" class="headerlink" title="Kubernetes 这词咋念啊？为啥有人管它叫 k8s ？"></a><code>Kubernetes</code> 这词咋念啊？为啥有人管它叫 <code>k8s</code> ？</h2><p>Kubernetes 的发音：<code>koo-ber-nay&#39;-tace</code> ，（如果非用中文拼凑的话，大概是<code>“酷-博-内-忒丝”</code>），这词来自希腊<code>舵手</code>这个词。<br>但是经常有人念成：<code>koo-ber-net-ees</code>，（如果非用中文拼凑的话，大概是<code>“酷-博-耐-替”</code>）。也有人犯懒经常是念成 <code>k8s</code>，也就是 <code>k-eights</code>。</p>
<p><a href="http://www.biblestudytools.com/lexicons/greek/nas/kubernetes.html" target="_blank" rel="noopener">http://www.biblestudytools.com/lexicons/greek/nas/kubernetes.html</a></p>
<p>至于为啥叫 <code>k8s</code>，是因为发音接近么？……好吧，实话说了吧，是因为犯懒，数数 <code>k</code> 和 <code>s</code> 中间多少个字母？8 个吧，这个 8 的意思就是省略 8 个字母，懒得敲了…… 其实这类用法很多，比如 <code>i18n</code> (<code>internationalization</code>), <code>l11n</code> (<code>localization</code>) 等等，老外也懒得打字啊。</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://note.run-linux.com">Linus Lee</a>
            <p>原文链接：<a href="http://note.run-linux.com/2018/06/15/Docker-faq/">http://note.run-linux.com/2018/06/15/Docker-faq/</a>
            <p>发表日期：<a href="http://note.run-linux.com/2018/06/15/Docker-faq/">June 15th 2018, 8:43:22 pm</a>
            <p>更新日期：<a href="http://note.run-linux.com/2018/06/15/Docker-faq/">July 5th 2018, 12:38:22 am</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2018/06/21/Linux-Primer/" title= "Linux-Primer">
                    <div class="nextTitle">Linux-Primer</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2017/12/12/Binary-tree/" title= "Binary tree  of Data Structure">
                    <div class="prevTitle">Binary tree  of Data Structure</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zMjU0Ni85MTA3>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:708863861@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/mr-linus" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-引擎相关问题-67"><span class="toc-number">2.</span> <span class="toc-text">Docker 引擎相关问题 (67)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念问题-5"><span class="toc-number">2.1.</span> <span class="toc-text">概念问题 (5)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么-Docker-和虚拟机还有什么差别？"><span class="toc-number">2.1.1.</span> <span class="toc-text">宿主如果和容器系统不同的话，那不是和虚拟机一样，一层层的调用，那么 Docker 和虚拟机还有什么差别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-资料好少啊？网上的命令怎么不能用？"><span class="toc-number">2.1.2.</span> <span class="toc-text">Docker 资料好少啊？网上的命令怎么不能用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何选择-Docker-书籍？"><span class="toc-number">2.1.3.</span> <span class="toc-text">如何选择 Docker 书籍？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总说看官方文档，可是-Docker-官网文档经常被墙，看不了怎么办？"><span class="toc-number">2.1.4.</span> <span class="toc-text">总说看官方文档，可是 Docker 官网文档经常被墙，看不了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-1-8-以后版本都有什么改进么？"><span class="toc-number">2.1.5.</span> <span class="toc-text">Docker 1.8 以后版本都有什么改进么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装、配置问题-8"><span class="toc-number">2.2.</span> <span class="toc-text">安装、配置问题 (8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-怎么这么多软件，我该装哪个？"><span class="toc-number">2.2.1.</span> <span class="toc-text">Docker 怎么这么多软件，我该装哪个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#是直接用-yum-apt-get-安装-Docker-吗？"><span class="toc-number">2.2.2.</span> <span class="toc-text">是直接用 yum / apt-get 安装 Docker 吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-04-及以后的版本"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">17.04 及以后的版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-03-及以前的版本"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">17.03 及以前的版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不是都已经发布-Docker-17-07-了么？我怎么升级到最新还是-17-05-呀？"><span class="toc-number">2.2.3.</span> <span class="toc-text">不是都已经发布 Docker 17.07 了么？我怎么升级到最新还是 17.05 呀？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-pull-好慢啊怎么办？"><span class="toc-number">2.2.4.</span> <span class="toc-text">docker pull 好慢啊怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu-14-04-配置加速器（或其它使用-Upstart-的系统）"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu-16-04-或-CentOS-7-配置加速器（或其它使用-Systemd-的系统）"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么修改了-docker-服务配置后不起作用？"><span class="toc-number">2.2.5.</span> <span class="toc-text">怎么修改了 docker 服务配置后不起作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果-Docker-升级或者重启的话，那容器是不是都会被停掉然后重启啊？"><span class="toc-number">2.2.6.</span> <span class="toc-text">如果 Docker 升级或者重启的话，那容器是不是都会被停掉然后重启啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么执行-docker-命令会报-permission-denied-没权限的错误啊？"><span class="toc-number">2.2.7.</span> <span class="toc-text">为什么执行 docker 命令会报 permission denied 没权限的错误啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器上线后，怎么发现总有个-xmrig-的容器在跑，删了还出来，这是什么鬼？"><span class="toc-number">2.2.8.</span> <span class="toc-text">服务器上线后，怎么发现总有个 xmrig 的容器在跑，删了还出来，这是什么鬼？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络问题-13"><span class="toc-number">2.3.</span> <span class="toc-text">网络问题 (13)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么固定容器-IP-地址？每次重启容器都要变化-IP-地址怎么办？"><span class="toc-number">2.3.1.</span> <span class="toc-text">怎么固定容器 IP 地址？每次重启容器都要变化 IP 地址怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何修改容器的-etc-hosts-文件？"><span class="toc-number">2.3.2.</span> <span class="toc-text">如何修改容器的 /etc/hosts 文件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么映射宿主端口？Dockerfile-中的EXPOSE和-docker-run-p-有啥区别？"><span class="toc-number">2.3.3.</span> <span class="toc-text">怎么映射宿主端口？Dockerfile 中的EXPOSE和 docker run -p 有啥区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我要映射好几百个端口，难道要一个个-p-么？"><span class="toc-number">2.3.4.</span> <span class="toc-text">我要映射好几百个端口，难道要一个个 -p 么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-p-后还是无法通过映射端口访问容器里面的服务？"><span class="toc-number">2.3.5.</span> <span class="toc-text">为什么 -p 后还是无法通过映射端口访问容器里面的服务？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本机防火墙"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">本机防火墙</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#边界防火墙"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">边界防火墙</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vethxxxx-这种虚拟网卡和容器的对应关系从哪里看？"><span class="toc-number">2.3.6.</span> <span class="toc-text">vethxxxx 这种虚拟网卡和容器的对应关系从哪里看？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何让一个容器连接两个网络？"><span class="toc-number">2.3.7.</span> <span class="toc-text">如何让一个容器连接两个网络？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-多宿主网络怎么配置？"><span class="toc-number">2.3.8.</span> <span class="toc-text">Docker 多宿主网络怎么配置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#明明-docker-network-ls-中看到了建立的-overlay-网络，怎么-docker-run-还说网络不存在啊？"><span class="toc-number">2.3.9.</span> <span class="toc-text">明明 docker network ls 中看到了建立的 overlay 网络，怎么 docker run 还说网络不存在啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Swarm-Mode-的时，看到有个叫-ingress-的-overlay-网络，它和自己创建的网络有什么区别？"><span class="toc-number">2.3.10.</span> <span class="toc-text">使用 Swarm Mode 的时，看到有个叫 ingress 的 overlay 网络，它和自己创建的网络有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#听说-link-过时不再用了？那容器互联、服务发现怎么办？"><span class="toc-number">2.3.11.</span> <span class="toc-text">听说 --link 过时不再用了？那容器互联、服务发现怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-HBase-Hadoop-的时候，反向解析总是不对，怎么办？"><span class="toc-number">2.3.12.</span> <span class="toc-text">使用 HBase/Hadoop 的时候，反向解析总是不对，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器怎么取宿主机-IP-啊？"><span class="toc-number">2.3.13.</span> <span class="toc-text">容器怎么取宿主机 IP 啊？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单机环境"><span class="toc-number">2.3.13.1.</span> <span class="toc-text">单机环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集群环境"><span class="toc-number">2.3.13.2.</span> <span class="toc-text">集群环境</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储问题-11"><span class="toc-number">2.4.</span> <span class="toc-text">存储问题 (11)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器磁盘可以限制配额么？"><span class="toc-number">2.4.1.</span> <span class="toc-text">容器磁盘可以限制配额么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器内的数据该保存在镜像里还是物理机里？"><span class="toc-number">2.4.2.</span> <span class="toc-text">容器内的数据该保存在镜像里还是物理机里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#看到总说要保持容器无状态，那什么是无状态？"><span class="toc-number">2.4.3.</span> <span class="toc-text">看到总说要保持容器无状态，那什么是无状态？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#容器存储层的无状态"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">容器存储层的无状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务层面的无状态"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">服务层面的无状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？"><span class="toc-number">2.4.4.</span> <span class="toc-text">数据容器、数据卷、命名卷、匿名卷、挂载目录这些都有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卷和挂载目录有什么区别？"><span class="toc-number">2.4.5.</span> <span class="toc-text">卷和挂载目录有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？"><span class="toc-number">2.4.6.</span> <span class="toc-text">为什么绑定了宿主的文件到容器，宿主修改了文件，容器内看到的还是旧的内容啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个-Docker-容器之间共享数据怎么办？NFS-？"><span class="toc-number">2.4.7.</span> <span class="toc-text">多个 Docker 容器之间共享数据怎么办？NFS ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#既然一个容器一个应用，那么我想在该容器中用计划任务-cron-怎么办？"><span class="toc-number">2.4.8.</span> <span class="toc-text">既然一个容器一个应用，那么我想在该容器中用计划任务 cron 怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何初始化卷？"><span class="toc-number">2.4.9.</span> <span class="toc-text">如何初始化卷？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#正常挂载该-mydata-卷，然后-docker-cp-进去"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">正常挂载该 mydata 卷，然后 docker cp 进去</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#专门制作初始化镜像"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">专门制作初始化镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在镜像的-Dockerfile-制作中，加入初始化部分"><span class="toc-number">2.4.9.3.</span> <span class="toc-text">在镜像的 Dockerfile 制作中，加入初始化部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么说数据库不适合放在-Docker-容器里运行？"><span class="toc-number">2.4.10.</span> <span class="toc-text">为什么说数据库不适合放在 Docker 容器里运行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何列出容器和所使用的卷的关系？"><span class="toc-number">2.4.11.</span> <span class="toc-text">如何列出容器和所使用的卷的关系？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像问题-17"><span class="toc-number">2.5.</span> <span class="toc-text">镜像问题 (17)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-pull-下来的镜像文件都在哪？"><span class="toc-number">2.5.1.</span> <span class="toc-text">docker pull 下来的镜像文件都在哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-images-命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？"><span class="toc-number">2.5.2.</span> <span class="toc-text">docker images 命令显示的镜像占了好大的空间，怎么办？每次都是下载这么大的镜像？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-images-a-后显示了好多-lt-none-gt-的镜像？都是什么呀？能删么？"><span class="toc-number">2.5.3.</span> <span class="toc-text">docker images -a 后显示了好多 &lt;none&gt; 的镜像？都是什么呀？能删么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#依赖镜像"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">依赖镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#丢了标签的镜像"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">丢了标签的镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-Docker-Hub-的镜像尺寸和-docker-images-不一致？"><span class="toc-number">2.5.4.</span> <span class="toc-text">为什么 Docker Hub 的镜像尺寸和 docker images 不一致？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-commit-怎么用啊？"><span class="toc-number">2.5.5.</span> <span class="toc-text">docker commit 怎么用啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么说不要使用-import-export-save-load-commit-来构建镜像？"><span class="toc-number">2.5.6.</span> <span class="toc-text">为什么说不要使用 import, export, save, load, commit 来构建镜像？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-怎么写？"><span class="toc-number">2.5.7.</span> <span class="toc-text">Dockerfile 怎么写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-就是-shell-脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。"><span class="toc-number">2.5.8.</span> <span class="toc-text">Dockerfile 就是 shell 脚本吧？那我懂，一行行把需要装的东西都写进去不就行了。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#那我把所有命令都合并到一个-RUN-就对了吧？"><span class="toc-number">2.5.9.</span> <span class="toc-text">那我把所有命令都合并到一个 RUN 就对了吧？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context-到底是一个什么概念？"><span class="toc-number">2.5.10.</span> <span class="toc-text">context 到底是一个什么概念？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENTRYPOINT-和-CMD-到底有什么不同？"><span class="toc-number">2.5.11.</span> <span class="toc-text">ENTRYPOINT 和 CMD 到底有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拿到一个镜像，如何获得镜像的-Dockerfile-？"><span class="toc-number">2.5.12.</span> <span class="toc-text">拿到一个镜像，如何获得镜像的 Dockerfile ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在你的-LNMP-的例子中，PHP-的-Dockerfile-里面的-“构建依赖”-和-“运行依赖”-都是什么意思？"><span class="toc-number">2.5.13.</span> <span class="toc-text">在你的 LNMP 的例子中，PHP 的 Dockerfile 里面的 “构建依赖” 和 “运行依赖” 都是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用代码是应该挂载宿主目录还是放入镜像内？"><span class="toc-number">2.5.14.</span> <span class="toc-text">应用代码是应该挂载宿主目录还是放入镜像内？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在-Dockerfile-中执行（导入-sql、service-xxx-start）不管用？"><span class="toc-number">2.5.15.</span> <span class="toc-text">为什么在 Dockerfile 中执行（导入 .sql、service xxx start）不管用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么基于-Alpine-的镜像那么小？我可以都换成基于-Alpine-的镜像么？"><span class="toc-number">2.5.16.</span> <span class="toc-text">为什么基于 Alpine 的镜像那么小？我可以都换成基于 Alpine 的镜像么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可以看到镜像各层的依赖关系么？"><span class="toc-number">2.5.17.</span> <span class="toc-text">可以看到镜像各层的依赖关系么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日志问题-2"><span class="toc-number">2.6.</span> <span class="toc-text">日志问题 (2)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-日志都在哪里？怎么收集？"><span class="toc-number">2.6.1.</span> <span class="toc-text">Docker 日志都在哪里？怎么收集？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-引擎日志"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">Docker 引擎日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器日志"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">容器日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同容器的日志汇聚到-fluentd-后如何区分？"><span class="toc-number">2.6.2.</span> <span class="toc-text">不同容器的日志汇聚到 fluentd 后如何区分？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用问题-11"><span class="toc-number">2.7.</span> <span class="toc-text">使用问题 (11)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么容器一运行就退出啊？"><span class="toc-number">2.7.1.</span> <span class="toc-text">为什么容器一运行就退出啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在-Docker-容器内使用-docker-命令-比如在-Jenkins-容器中-？"><span class="toc-number">2.7.2.</span> <span class="toc-text">如何在 Docker  容器内使用 docker 命令(比如在 Jenkins 容器中)？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为-Jenkins-添加-Docker-命令行"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">为 Jenkins 添加 Docker 命令行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-容器如何随系统一同启动？"><span class="toc-number">2.7.3.</span> <span class="toc-text">Docker 容器如何随系统一同启动？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-stats-显示的只有容器ID，怎么才能显示容器名字？"><span class="toc-number">2.7.4.</span> <span class="toc-text">docker stats 显示的只有容器ID，怎么才能显示容器名字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我用的是阿里云-Ubuntu-14-04-主机，内核还是3-13，怎么办？"><span class="toc-number">2.7.5.</span> <span class="toc-text">我用的是阿里云 Ubuntu 14.04 主机，内核还是3.13，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何动态修改内存限制？"><span class="toc-number">2.7.6.</span> <span class="toc-text">如何动态修改内存限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#经常在各种-Docker-命令里看到-label，label-是什么？干什么用的？"><span class="toc-number">2.7.7.</span> <span class="toc-text">经常在各种 Docker 命令里看到 --label，label 是什么？干什么用的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#添加label以及过滤"><span class="toc-number">2.7.7.1.</span> <span class="toc-text">添加label以及过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集群调度约束"><span class="toc-number">2.7.7.2.</span> <span class="toc-text">集群调度约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#都说不要用-root-去运行服务，但我看到的-Dockerfile-都是用-root-去运行，这不安全吧？"><span class="toc-number">2.7.8.</span> <span class="toc-text">都说不要用 root 去运行服务，但我看到的 Dockerfile 都是用 root 去运行，这不安全吧？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我在容器里运行-systemctl-start-xxx-怎么报错啊？"><span class="toc-number">2.7.9.</span> <span class="toc-text">我在容器里运行 systemctl start xxx 怎么报错啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器内的时间和宿主不一致，怎么同步啊？"><span class="toc-number">2.7.10.</span> <span class="toc-text">容器内的时间和宿主不一致，怎么同步啊？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我想让我的程序平滑退出，为什么截获-SIGTERM-信号不管用啊？"><span class="toc-number">2.7.11.</span> <span class="toc-text">我想让我的程序平滑退出，为什么截获 SIGTERM 信号不管用啊？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Compose-相关问题-2"><span class="toc-number">3.</span> <span class="toc-text">Docker Compose 相关问题 (2)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#你那个-LNMP-例子中的-docker-compose-yml-中有好多-networks，都是什么意思啊？"><span class="toc-number">3.1.</span> <span class="toc-text">你那个 LNMP 例子中的 docker-compose.yml 中有好多 networks，都是什么意思啊？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Compose-的时候碰到-“An-HTTP-request-took-too-long-to-complete…-”-错误，怎么办？"><span class="toc-number">3.2.</span> <span class="toc-text">使用 Compose 的时候碰到 “An HTTP request took too long to complete….” 错误，怎么办？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Swarm-相关问题-8"><span class="toc-number">4.</span> <span class="toc-text">Docker Swarm 相关问题 (8)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#我的-Docker-版本是-1-12，请问我跑的是一代-Swarm-还是二代-Swarm-啊？"><span class="toc-number">4.1.</span> <span class="toc-text">我的 Docker 版本是 1.12，请问我跑的是一代 Swarm 还是二代 Swarm 啊？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swarm环境中怎么指定某个容器在指定的宿主上运行呢？"><span class="toc-number">4.2.</span> <span class="toc-text">Swarm环境中怎么指定某个容器在指定的宿主上运行呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么-Swarm-集群的-overlay-network-跨宿主无法互访？"><span class="toc-number">4.3.</span> <span class="toc-text">为什么 Swarm 集群的 overlay network 跨宿主无法互访？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-二代Swarm-既-Swarm-Mode-，docker-service-create-不可以使用-v-那怎么使用卷-Volume-？"><span class="toc-number">4.4.</span> <span class="toc-text">Docker 二代Swarm (既 Swarm Mode)，docker service create 不可以使用 -v 那怎么使用卷(Volume)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对于两节点集群来说，-replicas-2-和-mode-global-是不是一个意思？"><span class="toc-number">4.5.</span> <span class="toc-text">对于两节点集群来说，--replicas=2 和 --mode=global 是不是一个意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一代-Swarm-的时候可以用-docker-run-啊，二代怎么又弄个-docker-service-create-出来？为什么要多此一举？"><span class="toc-number">4.6.</span> <span class="toc-text">一代 Swarm 的时候可以用 docker run 啊，二代怎么又弄个 docker service create 出来？为什么要多此一举？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-service-ps-里面总是有一堆失败或者shutdown的历史容器，怎么删啊？"><span class="toc-number">4.7.</span> <span class="toc-text">docker service ps 里面总是有一堆失败或者shutdown的历史容器，怎么删啊？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么才能让-docker-service-create-创建的服务正常退出时不重启啊？"><span class="toc-number">4.8.</span> <span class="toc-text">怎么才能让 docker service create 创建的服务正常退出时不重启啊？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Machine-相关问题-5"><span class="toc-number">5.</span> <span class="toc-text">Docker Machine 相关问题 (5)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#打开命令行后，看到下载啥-boot2docker-iso，然后总是超时失败，怎么办？"><span class="toc-number">5.1.</span> <span class="toc-text">打开命令行后，看到下载啥 boot2docker.iso，然后总是超时失败，怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装完-Docker-Toolbox-后发现下载镜像速度太慢，是不是需要修改什么配置文件？"><span class="toc-number">5.2.</span> <span class="toc-text">装完 Docker Toolbox 后发现下载镜像速度太慢，是不是需要修改什么配置文件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何在-Docker-Toolbox-中创建的-default-虚拟机中添加DOCKER-OPTS之类的配置？"><span class="toc-number">5.3.</span> <span class="toc-text">如何在 Docker Toolbox 中创建的 default 虚拟机中添加DOCKER_OPTS之类的配置？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么我安装好的Docker没有docker-machine-命令"><span class="toc-number">5.4.</span> <span class="toc-text">为什么我安装好的Docker没有docker-machine 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-machine-创建的主机怎么直接-ssh-进去？改了-root-密码好像也没用？"><span class="toc-number">5.5.</span> <span class="toc-text">docker-machine 创建的主机怎么直接 ssh 进去？改了 root 密码好像也没用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-machine-使用-d-generic-时，指定用户-generic-ssh-user-后发现要-sudo-密码，结果报错退出，这是怎么回事？"><span class="toc-number">5.6.</span> <span class="toc-text">docker-machine 使用 -d generic 时，指定用户 --generic-ssh-user 后发现要 sudo 密码，结果报错退出，这是怎么回事？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Registry-相关问题-10"><span class="toc-number">6.</span> <span class="toc-text">Docker Registry 相关问题 (10)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#我-docker-push-的时候怎么报-authentication-required-错误？"><span class="toc-number">6.1.</span> <span class="toc-text">我 docker push 的时候怎么报 authentication required 错误？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么我-docker-login-失败了？我注册用户了，在网站登录也没问题呀？"><span class="toc-number">6.2.</span> <span class="toc-text">为什么我 docker login 失败了？我注册用户了，在网站登录也没问题呀？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我注册用户-pinkman-了，怎么还是无法-docker-push-mrwhite-xxx-啊？"><span class="toc-number">6.3.</span> <span class="toc-text">我注册用户 pinkman 了，怎么还是无法 docker push mrwhite/xxx 啊？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不管用啊，我这回-docker-push-pinkman-xxx-了，怎么告诉我镜像不存在啊？"><span class="toc-number">6.4.</span> <span class="toc-text">不管用啊，我这回 docker push pinkman/xxx 了，怎么告诉我镜像不存在啊？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-push-到私有-registry-总是不成功，怎么办？"><span class="toc-number">6.5.</span> <span class="toc-text">docker push 到私有 registry 总是不成功，怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我-docker-push-了很多镜像到私有的-registry-上，怎么才能查看上面都有啥？或者搜索？"><span class="toc-number">6.6.</span> <span class="toc-text">我 docker push 了很多镜像到私有的 registry 上，怎么才能查看上面都有啥？或者搜索？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-search-为什么没有办法在私有-Registry-中用？"><span class="toc-number">6.7.</span> <span class="toc-text">docker search 为什么没有办法在私有 Registry 中用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何删除私有-registry-中的镜像？"><span class="toc-number">6.8.</span> <span class="toc-text">如何删除私有 registry 中的镜像？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用国内镜像还是慢，公司内好多-docker-主机，都需要去重复下载镜像，咋办？"><span class="toc-number">6.9.</span> <span class="toc-text">使用国内镜像还是慢，公司内好多 docker 主机，都需要去重复下载镜像，咋办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自己架的-registry-怎么任何用户都可以取到镜像？这不安全啊？"><span class="toc-number">6.10.</span> <span class="toc-text">自己架的 registry 怎么任何用户都可以取到镜像？这不安全啊？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统相关问题-7"><span class="toc-number">7.</span> <span class="toc-text">系统相关问题 (7)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CentOS-RHEL-红帽系统特有问题"><span class="toc-number">7.1.</span> <span class="toc-text">CentOS/RHEL 红帽系统特有问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在-CentOS-6-上安装后怎么最高只有-Docker-1-7-这个版本？"><span class="toc-number">7.1.1.</span> <span class="toc-text">在 CentOS 6 上安装后怎么最高只有 Docker 1.7 这个版本？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#挂载宿主目录，结果-Permission-denied，没权限"><span class="toc-number">7.1.2.</span> <span class="toc-text">挂载宿主目录，结果 Permission denied，没权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker的-var-lib-docker-devicemapper-占用空间不断增长-怎么破？"><span class="toc-number">7.1.3.</span> <span class="toc-text">Docker的 /var/lib/docker/devicemapper 占用空间不断增长, 怎么破？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CentOS-7-的内核太老了-3-10，是不是很多-Docker-功能不支持？"><span class="toc-number">7.1.4.</span> <span class="toc-text">CentOS 7 的内核太老了 3.10，是不是很多 Docker 功能不支持？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CentOS-7-RHEL-7-升级-1-12-后，无法启动，怎么回事？"><span class="toc-number">7.1.5.</span> <span class="toc-text">CentOS 7/RHEL 7 升级 1.12 后，无法启动，怎么回事？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mac-Windows-相关问题"><span class="toc-number">7.2.</span> <span class="toc-text">Mac / Windows 相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在Mac下挂载宿主目录-usr-local-nginx不成功？"><span class="toc-number">7.2.1.</span> <span class="toc-text">为什么在Mac下挂载宿主目录/usr/local/nginx不成功？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#听说-Windows-10、Windows-Server-2016-内置-Docker-了？和-Docker-官网下载的-Docker-for-Windows-有什么区别啊？"><span class="toc-number">7.2.2.</span> <span class="toc-text">听说 Windows 10、Windows Server 2016 内置 Docker 了？和 Docker 官网下载的 Docker for Windows 有什么区别啊？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其它问题-1"><span class="toc-number">8.</span> <span class="toc-text">其它问题 (1)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-这词咋念啊？为啥有人管它叫-k8s-？"><span class="toc-number">8.1.</span> <span class="toc-text">Kubernetes 这词咋念啊？为啥有人管它叫 k8s ？</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 29
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/03</span><a class="archive-post-title" href= "/2020/06/03/kubefed-SyncController/" >Kubefed - Sync Controller</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2020/06/02/kubefed-FTCcontroller/" >Kubefed - FTC Controller</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/01</span><a class="archive-post-title" href= "/2020/06/01/kubefed-clustercontroller/" >Kubefed - ClusterController</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/24</span><a class="archive-post-title" href= "/2019/11/24/k8s-storage/" >Kubernetes Storage</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span><a class="archive-post-title" href= "/2019/04/17/Kubernetes-s-API/" >Kubernetes's API</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href= "/2019/03/27/Istio-s-traffic-management/" >Istio's traffic management</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href= "/2019/03/27/Views-about-the-struct-of-istio/" >Views about the struct of istio</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/25</span><a class="archive-post-title" href= "/2019/03/25/Install-istio-with-helm/" >Install Istio using helm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2019/03/18/Install-Helm-with-k8s/" >Install Helm for k8s</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span><a class="archive-post-title" href= "/2019/03/15/Install-K8S-dashboard/" >Install K8S dashboard with ingress</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/10</span><a class="archive-post-title" href= "/2019/03/10/Install-K8S-with-kubeadm/" >Install a single master K8S cluster with kubeadm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/24</span><a class="archive-post-title" href= "/2019/01/24/Go-Core-Interface/" >Go Core Dev Interface</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/23</span><a class="archive-post-title" href= "/2019/01/23/Go-Core-TypeSystem/" >Go Core Dev Type-System</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/17</span><a class="archive-post-title" href= "/2019/01/17/Go-Core-Function/" >Go Core Dev Function</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span><a class="archive-post-title" href= "/2019/01/15/Go-Core-Base/" >Go Core Dev Base</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2018/09/09/Go-Primer/" >Go Primer</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/24</span><a class="archive-post-title" href= "/2018/08/24/Kubernetes StatefulSet/" >Kubernetes StatefulSet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/24</span><a class="archive-post-title" href= "/2018/08/24/contribute-to-opensource/" >How to contribute to open source projects</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href= "/2018/08/20/Linux-namespace/" >Views about Namespace & Cgroups of Linux Kernel</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span><a class="archive-post-title" href= "/2018/07/17/K8S-InfoCollection/" >Kubernetes Information Collection</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2018/07/01/Scraping-Primer/" >Scraping-Primer</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span><a class="archive-post-title" href= "/2018/06/21/Linux-Primer/" >Linux-Primer</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2018/06/15/Docker-faq/" >Docker-FAQ</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span><a class="archive-post-title" href= "/2017/12/12/Binary-tree/" >Binary tree  of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span><a class="archive-post-title" href= "/2017/12/12/Graph-traversal/" >Graph traversal  of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2017/10/28/search/" >Search of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2017/10/24/struct/" >Concept of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/23</span><a class="archive-post-title" href= "/2017/10/23/sort/" >Sort of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/20</span><a class="archive-post-title" href= "/2017/10/20/Docker-Primer/" >Docker-Primer</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Data Structure"><span class="iconfont-archer">&#xe606;</span>Data Structure</span>
    
        <span class="sidebar-tag-name" data-tags="docker"><span class="iconfont-archer">&#xe606;</span>docker</span>
    
        <span class="sidebar-tag-name" data-tags="Go"><span class="iconfont-archer">&#xe606;</span>Go</span>
    
        <span class="sidebar-tag-name" data-tags="k8s"><span class="iconfont-archer">&#xe606;</span>k8s</span>
    
        <span class="sidebar-tag-name" data-tags="istio"><span class="iconfont-archer">&#xe606;</span>istio</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="scraping"><span class="iconfont-archer">&#xe606;</span>scraping</span>
    
        <span class="sidebar-tag-name" data-tags="open-source"><span class="iconfont-archer">&#xe606;</span>open-source</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Linus Lee"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->    
     
    </body>
</html>


