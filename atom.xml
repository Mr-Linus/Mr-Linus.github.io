<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Funky&#39;s Blog</title>
  
  <subtitle>Share &amp; Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.geekfan.top/"/>
  <updated>2017-10-30T08:26:46.839Z</updated>
  <id>http://blog.geekfan.top/</id>
  
  <author>
    <name>Funky Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Graph traversal  of Data Structure</title>
    <link href="http://blog.geekfan.top/2017/10/30/Graph-traversal/"/>
    <id>http://blog.geekfan.top/2017/10/30/Graph-traversal/</id>
    <published>2017-10-30T07:53:44.000Z</published>
    <updated>2017-10-30T08:26:46.839Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h2><ul><li>广度优先搜索 （Breath-First-Search,BFS）</li><li>深度优先搜索 （Depth-First-Search,DFS）</li></ul><h3 id="常识"><a class="markdownIt-Anchor" href="#常识"></a> 常识</h3><p>图：Graph (G)<br>顶点（节点）：Vertex (V)<br>边：Edge (E)</p><h3 id="bfs-广度优先搜索"><a class="markdownIt-Anchor" href="#bfs-广度优先搜索"></a> BFS 广度优先搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> visited[MaxNum];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</div><div class="line">    Queue Q;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123; <span class="comment">//数组下标初始化</span></div><div class="line">        visited[i]=False;</div><div class="line">    &#125;</div><div class="line">    InitQueue Q;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(!visited[i])&#123; <span class="comment">//对每个连通分量调用一次BFS</span></div><div class="line">            BFS(G,i); <span class="comment">//i如果没被访问，从i开始BFS</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    visit(v);</div><div class="line">    visited[v]=True;</div><div class="line">    EnQueue(Q,v);</div><div class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</div><div class="line">        DeQueue(Q,v);</div><div class="line">        <span class="keyword">for</span>(w=FirstNeighbour(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))&#123;</div><div class="line">            <span class="keyword">if</span>(!visited[w])&#123;</div><div class="line">                visit(w);</div><div class="line">                visited[w]=True;</div><div class="line">                EnQueue(Q,w);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="bfs-性能分析"><a class="markdownIt-Anchor" href="#bfs-性能分析"></a> BFS 性能分析</h4><blockquote><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span><br>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathrm">∣</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p></blockquote><h3 id="bfs算法求单源最短路径"><a class="markdownIt-Anchor" href="#bfs算法求单源最短路径"></a> BFS算法求单源最短路径</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_Distance</span><span class="params">(Graph G,<span class="keyword">int</span> u)</span></span>&#123;</div><div class="line">    <span class="comment">//d[i]表示从u到i节点的最短路径</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</div><div class="line">        d[i]=MaxSize; <span class="comment">//初始化长度</span></div><div class="line">    &#125;</div><div class="line">    visited[u]=True;</div><div class="line">    d[u]=<span class="number">0</span>;</div><div class="line">    EnQueue(Q,u);</div><div class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</div><div class="line">        DeQueue(Q,u);</div><div class="line">        <span class="keyword">for</span>(w=FirstNeighbour(G,u),w&gt;=<span class="number">0</span>;w=NextNeighbour(G,u,w))&#123;</div><div class="line">            <span class="keyword">if</span>(!visited[w])&#123;</div><div class="line">                visited[w]=True;</div><div class="line">                d[w]=d[u]+<span class="number">1</span>;</div><div class="line">                EnQueue(Q,w);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="dfs-深度优先搜索"><a class="markdownIt-Anchor" href="#dfs-深度优先搜索"></a> DFS 深度优先搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> visited[MaxNum];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</div><div class="line">        visited[v]=False;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</div><div class="line">        <span class="keyword">if</span>(!visited[v])&#123;</div><div class="line">            DFS(G,v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">    visit(v);</div><div class="line">    visited[v]=True;</div><div class="line">    <span class="keyword">for</span>(w=FirstNeighbour(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbour(G,v,w))&#123;</div><div class="line">        DFS(G,w);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="dfs性能分析"><a class="markdownIt-Anchor" href="#dfs性能分析"></a> DFS性能分析</h4><blockquote><p>空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span><br>时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathrm">∣</span><span class="mbin">+</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;图的遍历&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://blog.geekfan.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Binary tree  of Data Structure</title>
    <link href="http://blog.geekfan.top/2017/10/29/binary-tree/"/>
    <id>http://blog.geekfan.top/2017/10/29/binary-tree/</id>
    <published>2017-10-29T14:43:22.000Z</published>
    <updated>2017-10-30T07:49:59.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="树与二叉树"><a class="markdownIt-Anchor" href="#树与二叉树"></a> 树与二叉树</h2><h3 id="度"><a class="markdownIt-Anchor" href="#度"></a> 度</h3><p>树中一个节点的子节点个数称为该<code>节点的度</code>，树中节点的最大度数称为<code>树的度</code>。<br>度大于0的节点称为<code>分支节点</code>(又称未终端节点)；度为0的节点称为叶子节点。</p><h3 id="节点的深度-高度-层次"><a class="markdownIt-Anchor" href="#节点的深度-高度-层次"></a> 节点的深度、高度、层次</h3><p><code>节点层次</code>从树根开始定义，根节点为第一层，他的子节点为第二层，以此类推。</p><p><code>节点深度</code>是从根节点开始从顶向下逐层累加。</p><p><code>节点高度</code>是从叶子节点开始从底向上逐层累加。</p><p><code>树的高度</code>（又称深度）是从树中节点的最大层数。</p><h3 id="树的性质"><a class="markdownIt-Anchor" href="#树的性质"></a> 树的性质</h3><ul><li>树中的节点数等于所有节点的度数加1.</li><li>度为m的树中第i层上至多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">m^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:0.824664em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个节点</li><li>高度为h的m叉树最多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(m^h-1)/(m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">h</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>个节点</li><li>具有n个节点的m叉树的最小高度为:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>m</mi></msub><mo>(</mo><mi>n</mi><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lceil log_m(n(m-1)+1) \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">m</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span></li></ul><blockquote><p>Tips: 二叉树可以为空，但是树不能为空</p></blockquote><h3 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h3><p>二叉树是有序树，一共有5种形态: 空二叉树、只有根节点、只有根节点和左孩子、只有根节点和右孩子、根节点和左孩子右孩子都有。</p><h3 id="二叉树和度为2的树的区别"><a class="markdownIt-Anchor" href="#二叉树和度为2的树的区别"></a> 二叉树和度为2的树的区别</h3><ul><li>度为2的树至少有2个节点，二叉树可以为空</li><li>度为2的树的孩子节点的左右次序是相对而言的，而二叉树的左右孩子节点是确定的。</li></ul><h3 id="特殊的二叉树"><a class="markdownIt-Anchor" href="#特殊的二叉树"></a> 特殊的二叉树</h3><h4 id="1-满二叉树"><a class="markdownIt-Anchor" href="#1-满二叉树"></a> 1) 满二叉树</h4><p>一颗高度为n，并且有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">h</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>个节点的二叉树称为满二叉树。</p><blockquote><p>满二叉树的叶子节点全部集中在二叉树的最下一层并且除了叶子节点外q其余节点度数均为2。</p></blockquote><h4 id="2-完全二叉树"><a class="markdownIt-Anchor" href="#2-完全二叉树"></a> 2) 完全二叉树</h4><p>设一个高度为h，有n个节点的二叉树，当且仅当每一个节点都与高度为h的满二叉树中编号为1-n的节点一一对应时，称为完全二叉树。</p><h3 id="二叉树的特点"><a class="markdownIt-Anchor" href="#二叉树的特点"></a> 二叉树的特点</h3><ul><li>非空二叉树是的叶子节点个数等于度为2的节点树加1,即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mn>0</mn></msub><mo>=</mo><msub><mi>N</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N_0=N_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10903em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></li><li>非空二叉树是第K层上至多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.849108em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个节点</li><li>高度为H的二叉树至多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>H</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^H-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>个节点（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">H\geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">≥</span><span class="mord mathrm">1</span></span></span></span>）</li><li>节点i的双亲编号为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lfloor i/2 \right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌊</span><span class="mord mathit">i</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌋</span></span></span></span></span>，左右孩子的编号为2i,2i+1</li><li>节点i所在层次（深度）为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>i</mi><mo fence="true">⌋</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left \lfloor log_2i \right \rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌊</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">i</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌋</span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></li><li>具有N个节点的完全二叉树的高度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lceil log_2(N+1) \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo fence="true">⌋</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left \lfloor log_2N \right \rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌊</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌋</span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取二叉树高度</span></div><div class="line"><span class="comment">//递归算法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BiTree T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">      <span class="keyword">if</span>(!T)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> Left = TreeDepth(T-&gt;lchild);</div><div class="line">      <span class="keyword">int</span> Right = TreeDepth(T-&gt;rchild);</div><div class="line">      <span class="keyword">return</span> (Left &gt; Right) ? (Left + <span class="number">1</span>) : (Right + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//非递归</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> front = <span class="number">-1</span> ,rear = <span class="number">-1</span> ,last = <span class="number">0</span> , level = <span class="number">0</span>;</div><div class="line">    BiTree Q[MaxSize],p;</div><div class="line">    <span class="keyword">if</span>(!T)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    Q[++rear]=T;</div><div class="line">    <span class="keyword">while</span>(front&lt;rear)&#123;</div><div class="line">        p=Q[++front];</div><div class="line">        <span class="keyword">if</span>(p-&gt;lchild)&#123;</div><div class="line">            Q[++rear]=p-&gt;lchild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(p-&gt;rchild)&#123;</div><div class="line">            Q[++rear]=p-&gt;rchild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(front==last)&#123;</div><div class="line">            level++;</div><div class="line">            last=rear++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> level;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="m叉树"><a class="markdownIt-Anchor" href="#m叉树"></a> m叉树</h3><p>一颗高为h的满m叉树的性质：</p><ul><li>第i层有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">m^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:0.824664em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个节点</li><li>在m叉树,节点i的第一个孩子编号为j=(i-1)*m+2,反之，节点i的父节点编号是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌊</mo><mo>(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi>m</mi><mo fence="true">⌋</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left \lfloor (i-2)/m \right \rfloor+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌊</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit">m</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌋</span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></li><li>节点i的第K个孩子编号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>m</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>(</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i-1)*m+k+1 (1\leq k \leq m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">≤</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span></li><li>如果编号为i的节点有有右兄弟，那么应满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≤</mo><mrow><mo fence="true">⌊</mo><mo>(</mo><mi>i</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>2</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi>m</mi><mo fence="true">⌋</mo></mrow><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">i\leq \left \lfloor (i+m-2)/m \right \rfloor*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mrel">≤</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌊</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathit">m</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌋</span></span><span class="mbin">∗</span><span class="mord mathit">m</span></span></span></span></li></ul><h3 id="二叉树遍历"><a class="markdownIt-Anchor" href="#二叉树遍历"></a> 二叉树遍历</h3><p>二叉树遍历一共有三种遍历:</p><ul><li>先序遍历（NLR） 即<code>先序遍历根节点</code></li><li>中序遍历（LNR）</li><li>后序遍历（LRN）</li><li>层序遍历 <code>(一层一层遍历)</code></li></ul><p>遍历算法：</p><ul><li>递归：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</div><div class="line">        visit(T);</div><div class="line">        PreOrder(T-&gt;lchild);</div><div class="line">        PreOrder(T-&gt;rchild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</div><div class="line">        PreOrder(T-&gt;lchild);</div><div class="line">        visit(T);</div><div class="line">        PreOrder(T-&gt;rchild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//后序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</div><div class="line">        PreOrder(T-&gt;lchild);</div><div class="line">        PreOrder(T-&gt;rchild);</div><div class="line">        visit(T);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//层序遍历</span></div><div class="line"><span class="comment">//递归函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelNode</span><span class="params">(BiTree T,<span class="keyword">int</span> level)</span></span>&#123; <span class="comment">//此函数是用于输出level层节点的所有元素</span></div><div class="line">    <span class="keyword">if</span> (!T||level&lt;<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(level == <span class="number">1</span>)&#123;</div><div class="line">        Visit[T];</div><div class="line">    &#125;</div><div class="line">    LevelNode(T-&gt;lchild,level<span class="number">-1</span>);</div><div class="line">    LevelNode(T-&gt;rchild,level<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//主函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> depth = Depth(T)，i;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==T)&#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;depth;i++)&#123; <span class="comment">//循环输出一层，二层，...，直到结束</span></div><div class="line">        LevelNodeOrder(T,i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>非递归：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    Stack S <span class="comment">//创建栈</span></div><div class="line">    InitStack(S); <span class="comment">//初始化栈</span></div><div class="line">    BiTree p=T; <span class="comment">//p设置为遍历指针</span></div><div class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</div><div class="line">        <span class="keyword">while</span>(p)&#123;</div><div class="line">            Push(S,p);</div><div class="line">            visit(p);</div><div class="line">            p=p-&gt;lchild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</div><div class="line">            Pop(S,p);</div><div class="line">            T-&gt;rchild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    Stack S <span class="comment">// 创建栈</span></div><div class="line">    InitStack(S); <span class="comment">//初始化栈</span></div><div class="line">    BiTree p=T; <span class="comment">//p设置为遍历指针</span></div><div class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123; <span class="comment">//只要栈非空或者p非空进入循环</span></div><div class="line">        <span class="keyword">if</span>(p)&#123;   <span class="comment">//p非空，则压栈，向左孩子遍历</span></div><div class="line">            Push(S,p);</div><div class="line">            p=p-&gt;child;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;  <span class="comment">//否则 根指针退栈，访问根节点，遍历右子树</span></div><div class="line">            Pop(S,p);</div><div class="line">            visit(p);</div><div class="line">            p=p-&gt;rchild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//后序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    Stack S;</div><div class="line">    InitStack(S);</div><div class="line">    BiTree p=T,r=<span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</div><div class="line">        <span class="keyword">if</span>(p)&#123;</div><div class="line">            Push(S,p);</div><div class="line">            p=p-&gt;lchild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            GetTop(S,p);<span class="comment">//取栈顶节点，但不弹出</span></div><div class="line">            <span class="keyword">if</span>(p-&gt;rchild &amp;&amp; p=p-&gt;rchild!=r)&#123; <span class="comment">//右子树存在，且未被访问</span></div><div class="line">                p=p-&gt;rchild; <span class="comment">//转向右子树</span></div><div class="line">                Push(S,p); <span class="comment">//压栈</span></div><div class="line">                p=p-&gt;lchild; <span class="comment">//转向左子树</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                Pop(S,p); <span class="comment">//否则弹出节点访问</span></div><div class="line">                visit(p-&gt;data);</div><div class="line">                r=p; <span class="comment">//记录最近被访问过的节点</span></div><div class="line">                p=<span class="literal">NULL</span>; <span class="comment">//重置p</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//层序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">    Queue Q;</div><div class="line">    InitQueue(Q);</div><div class="line">    BiTree p;</div><div class="line">    EnQueue (Q,T); <span class="comment">//根节点入队</span></div><div class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</div><div class="line">        DeQueue(Q,p); <span class="comment">//根节点出队</span></div><div class="line">        visit(p); </div><div class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123; </div><div class="line">            Enqueue(Q,p-&gt;lchild); <span class="comment">//左子树非空，左子树入队</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</div><div class="line">            Enqueue(Q,p-&gt;rchild); <span class="comment">//右子树非空，右子树入队</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="树和森林的遍历对应关系"><a class="markdownIt-Anchor" href="#树和森林的遍历对应关系"></a> 树和森林的遍历对应关系</h3><table><thead><tr><th style="text-align:right">树</th><th>森林</th><th style="text-align:right">二叉树</th></tr></thead><tbody><tr><td style="text-align:right">先根遍历</td><td>先序遍历</td><td style="text-align:right">先序遍历</td></tr><tr><td style="text-align:right">后根遍历</td><td>中序遍历</td><td style="text-align:right">中序遍历</td></tr></tbody></table><h3 id="二叉排序树-bst"><a class="markdownIt-Anchor" href="#二叉排序树-bst"></a> 二叉排序树 （BST）</h3><p>二叉树排序树的特点：<br>左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值</p><h4 id="bst查找"><a class="markdownIt-Anchor" href="#bst查找"></a> BST查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">BiTree <span class="title">Search</span> <span class="params">(BiTree T ,ElemType key)</span></span>&#123;</div><div class="line">    BiTree p=T;</div><div class="line">    <span class="keyword">if</span>(!p)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//return  NULL;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(p||key!=p-&gt;data)&#123;</div><div class="line">        <span class="keyword">if</span>(key&gt;p-&gt;data)&#123;</div><div class="line">            p=p-&gt;rchild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            p=p-lchild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>平均查找时间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mi>n</mi></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord textstyle uncramped"><span class="mord mathit">n</span></span><span class="mclose">)</span></span></span></span></p><h4 id="bst插入"><a class="markdownIt-Anchor" href="#bst插入"></a> BST插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非递归</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span> <span class="params">(BiTree T,ElemType key)</span></span>&#123;</div><div class="line">    BiTree p=T;</div><div class="line">    <span class="keyword">if</span>(p)&#123;</div><div class="line">        p=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</div><div class="line">        p-&gt;data=key;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(p)&#123;</div><div class="line">        <span class="keyword">if</span>(key&gt;p-&gt;data)&#123;</div><div class="line">            p=p-&gt;rchild;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data==key)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            p=p-&gt;lchild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    p=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</div><div class="line">    p-&gt;data=key;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span> <span class="params">(BiTree T,ElemType key)</span></span>&#123;</div><div class="line">    BiTree p=T;</div><div class="line">    <span class="keyword">if</span>(p)&#123;</div><div class="line">        p=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</div><div class="line">        p-&gt;data=key;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;p-&gt;data)&#123;</div><div class="line">        <span class="keyword">return</span> Insert(p-&gt;rchild,key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==p-&gt;data)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> Insert(p-&gt;lchild,key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="二叉平衡树"><a class="markdownIt-Anchor" href="#二叉平衡树"></a> 二叉平衡树</h3><p>二叉平衡树满足两个条件：</p><ul><li>是二叉树</li><li>二叉树上每个节点的左右子树高度之差不超过1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;树与二叉树&quot;&gt;&lt;a class=&quot;mark
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://blog.geekfan.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Search of Data Structure</title>
    <link href="http://blog.geekfan.top/2017/10/28/search/"/>
    <id>http://blog.geekfan.top/2017/10/28/search/</id>
    <published>2017-10-28T14:40:50.000Z</published>
    <updated>2017-10-29T14:35:48.299Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2><h3 id="查找方法"><a class="markdownIt-Anchor" href="#查找方法"></a> 查找方法</h3><ul><li>顺序查找</li><li>折半查找</li><li>分块查找</li></ul><h3 id="平均查找长度-aslaverage-search-length"><a class="markdownIt-Anchor" href="#平均查找长度-aslaverage-search-length"></a> 平均查找长度 ASL（Average Search Length  ）</h3><p>所有查找过程中进行关键字比较次数的平均值<br>数学定义为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">ASL=\sum _{i=1}^n P_i C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0500099999999999em;vertical-align:-0.30001em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">L</span><span class="mrel">=</span><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><blockquote><p>n是查找长度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是查找第i个元素的概率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是找到第i个元素所需进行比较次数</p></blockquote><h3 id="顺序查找"><a class="markdownIt-Anchor" href="#顺序查找"></a> 顺序查找</h3><p>适用于无序的表，挨个查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    ElemType *elem; <span class="comment">//元素存储空间基址</span></div><div class="line">    <span class="keyword">int</span> TableLen;<span class="comment">//表长</span></div><div class="line">&#125;SSTable;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</div><div class="line">    ST.elem[<span class="number">0</span>]=key; <span class="comment">//哨兵</span></div><div class="line">    <span class="keyword">for</span>(i=ST.TableLen;ST.elem[i]!=key;--i); <span class="comment">//从后往前找到i为0时退出for循环</span></div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>平均查找长度：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>P</mi><mi>i</mi></msub><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">ASL_{success}=\sum _{i=1}^n P_i(n-i-1)=\frac{n+1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>f</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>q</mi><mi>j</mi></msub><mo>(</mo><msub><mi>l</mi><mi>j</mi></msub><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mfrac><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">ASL_{failure}=\sum _{j=1}^n q_j(l_j-1)=\frac{n}{2}+\frac{n}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.186118em;vertical-align:-0.436118em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.01968em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p><h3 id="折半查找"><a class="markdownIt-Anchor" href="#折半查找"></a> 折半查找</h3><p>折半查找其实就是把查找表分成两半，然后在这两半里面继续分…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(SeqList L;ElemType key)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid; </div><div class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line">        mid=(low+high)/<span class="number">2</span>; <span class="comment">//取中间位置</span></div><div class="line">        <span class="keyword">if</span>(L.elem[mid]==key)&#123;<span class="keyword">return</span> mid;&#125; <span class="comment">//查找成功则返回所在位置</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)&#123;high=mid<span class="number">-1</span>;&#125; <span class="comment">//从前半部分查找</span></div><div class="line">        <span class="keyword">else</span> &#123;low=mid+<span class="number">1</span>;&#125; <span class="comment">//从后半部分查找</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>折半查找的过程可以用二叉树来描述，这个二叉树叫判定树，用折半查找到给定值的比较次数不会超过数的高度,即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lceil log_2 (n+1) \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span></p><p>平均查找长度：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL_{success}=log_2 (n+1)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span></p><h3 id="分块查找"><a class="markdownIt-Anchor" href="#分块查找"></a> 分块查找</h3><p>分块查找又称索引查找，吸取了折半查找和顺序查找的优点，块内元素可以无序，但是块之间是有序的。<br>示意图：</p><pre><code>索引表：</code></pre><table><thead><tr><th>24</th><th>54</th><th style="text-align:center">78</th><th style="text-align:left">88</th></tr></thead><tbody><tr><td>1</td><td>7</td><td style="text-align:center">10</td><td style="text-align:left">13</td></tr></tbody></table><p>查找表：</p><table><thead><tr><th>24</th><th style="text-align:right">21</th><th style="text-align:center">6</th><th style="text-align:left">11</th><th style="text-align:right">8</th><th style="text-align:right">22</th><th style="text-align:right">32</th><th style="text-align:left">31</th><th>54</th><th>72</th><th>61</th><th>78</th><th>88</th><th>83</th></tr></thead><tbody></tbody></table><p>平均查找长度：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msub><mi>L</mi><mi>I</mi></msub><mo>+</mo><msub><mi>L</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">ASL=L_I+L_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">L</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">L_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">L_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>分别为索引查找和块内查找的平均查找长度</p></blockquote><p>①若干将长度为n的产值表均匀分b块，每块s个记录，在等概率的情况下块内使用<code>顺序查找</code>那么平均查找长度为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msub><mi>L</mi><mi>I</mi></msub><mo>+</mo><msub><mi>L</mi><mi>S</mi></msub><mo>=</mo><mfrac><mrow><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">ASL=L_I+L_S=\frac{b+1}{2}+\frac{s+1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8801079999999999em;"></span><span class="strut bottom" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">L</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">b</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span><br>②此时若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msqrt><mrow><mi>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">s=\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mrel">=</span><span class="sqrt mord"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span>,则平均查找长度取最小值：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mi>n</mi></mrow></msqrt><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sqrt{n}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="base textstyle uncramped"><span class="sqrt mord"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>;若对索引表采用折半查找时，则平均查找长度为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><msub><mi>L</mi><mi>I</mi></msub><mo>+</mo><msub><mi>L</mi><mi>S</mi></msub><mo>=</mo><mrow><mo fence="true">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>b</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">ASL=L_I+L_S=\left \lceil log_2(b+1)+\frac{s+1}{2} \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.85em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">L</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">⌈</span></span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">s</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size1">⌉</span></span></span></span></span></span></p><h3 id="b树-b树"><a class="markdownIt-Anchor" href="#b树-b树"></a> B树 &amp; B+树</h3><p>B树，又称多路平衡查找树,B树中所有节点的孩子节点数的最大值称为<code>B数的阶</code>，通常用m表示。一颗m阶的树或为<code>空树</code>，或为满足如下特性的树:<br>1、树中每个节点至多有m颗子树（即至多含有m-1个关键字）。<br>2、若根节点不是终端节点，则至少有两颗子树（至少一个关键字）。<br>3、除根节点外的所有非叶子节点至少有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lceil m/2 \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span>颗子树（即至少含有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌉</mo></mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left \lceil m/2 \right \rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>个关键字）。<br>4、所有的叶节点都出现在同一层次上，并且不带信息（实际这些节点并不存在，指向这些节点的指针为空）。</p><blockquote><p>B树是所有节点的平衡因子均<code>等于0</code>的多路查找树</p></blockquote><h4 id="b树的高度磁盘存储次数"><a class="markdownIt-Anchor" href="#b树的高度磁盘存储次数"></a> B树的高度（磁盘存储次数）</h4><p>首先应该明确B树的高度不包括最后的不带任何信息的叶子节点那一层。</p><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">≥</span><span class="mord mathrm">1</span></span></span></span>，则对任意一颗包含n个关键字、高度为h、阶数为m的B树：<br>有一棵树的高度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>≥</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>m</mi></msub><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">h\geq log_m(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mrel">≥</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">m</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p><p>如果让每个节点中的关键字个数达到最少则高度为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>≤</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mrow><mo fence="true">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌉</mo></mrow></mrow></msub><mo>(</mo><mo>(</mo><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">h\leq log_{\left \lceil m/2 \right \rceil}(((n+1)/2)+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0.7em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="minner scriptstyle cramped"><span class="style-wrap reset-scriptstyle scriptstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit">m</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="style-wrap reset-scriptstyle scriptstyle uncramped" style="top:0em;">⌉</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0.7em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p>B树的大部分操作所需的磁盘存取次数与B树的高度成正比</p></blockquote><h3 id="散列hash表"><a class="markdownIt-Anchor" href="#散列hash表"></a> 散列(Hash)表</h3><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。<br>散列函数块内会把两个或两个以上的不同关键字映射到同一个地址，这种情况称“冲突”,这些发生碰撞的不同关键字称为“同义词”。</p><p><code>散列表</code> 是根据关键字而直接进行访问的数据结构。</p><h4 id="散列函数的构造遵循规则"><a class="markdownIt-Anchor" href="#散列函数的构造遵循规则"></a> 散列函数的构造遵循规则</h4><p>1.均匀分布,少冲突</p><p>2.计算简单,查找快</p><h5 id="1直接地址法"><a class="markdownIt-Anchor" href="#1直接地址法"></a> 1.直接地址法</h5><p>散列函数： H(key)=a*key+b</p><blockquote><p>特点: 计算简单，不会产生冲突，适合连续存储的情况，但如果关键字分布不连续，空位较多，将造成存储空间浪费。</p></blockquote><h5 id="2除留余数法"><a class="markdownIt-Anchor" href="#2除留余数法"></a> 2.除留余数法</h5><p>散列函数：H(key)=key%p</p><blockquote><p>特点：简单、常用，使用关键是选好p，尽量减少冲突</p></blockquote><h5 id="3数字分析法"><a class="markdownIt-Anchor" href="#3数字分析法"></a> 3.数字分析法</h5><p>设关键字是r进制数，而r个数码在各个位置上出现的频率不一定相同，在某些位上经常出现，则应选取数码分布较为均匀的若干位作为散列地址。</p><h5 id="4平方取中法"><a class="markdownIt-Anchor" href="#4平方取中法"></a> 4.平方取中法</h5><p>顾名思义，取关键字的平方值的中间几位作为散列地址:$10^{k-1} \leq n \leq 10^k $(其中n为集合中元素个数)</p><h5 id="5折叠法"><a class="markdownIt-Anchor" href="#5折叠法"></a> 5.折叠法</h5><p>将关键字分割成位数相同的几部分（最后一部分可以短一点），然后取这几部分的叠加作为散列地址。</p><h4 id="处理冲突的方法"><a class="markdownIt-Anchor" href="#处理冲突的方法"></a> 处理冲突的方法</h4><h5 id="1开地址法闭散列法"><a class="markdownIt-Anchor" href="#1开地址法闭散列法"></a> 1.开地址法（闭散列法）</h5><p>数学递推公式<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo>(</mo><mo>(</mo><mi>H</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub><mo>)</mo><mi mathvariant="normal">%</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H_i=((H(key)+d_i)\%m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mord mathrm">%</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span><br>式中,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>k</mi><mo>(</mo><mi>k</mi><mo>≥</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">i=1,2,3,...,k(k \geq m-1 )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">≥</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>;m表示散列表表长；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>为增量序列。</p><h6 id="1-线性探测法"><a class="markdownIt-Anchor" href="#1-线性探测法"></a> 1） 线性探测法</h6><p>不多说，冲突就往后挪，挪到有位置，停止</p><h6 id="2-平方探测法"><a class="markdownIt-Anchor" href="#2-平方探测法"></a> 2） 平方探测法</h6><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>k</mi><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mi>k</mi><mn>2</mn></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">d_i = 1^2,-1^2,2^2,-2^2,...,k^2,-k^2,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">1</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord">−</span><span class="mord"><span class="mord mathrm">1</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord">−</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span></span></span></span>其中$k \leq m/2 $，m必须是一个可以表示成4k+3的质数，又称二次探测法</p><h6 id="3再散列法"><a class="markdownIt-Anchor" href="#3再散列法"></a> 3)再散列法</h6><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mn>2</mn></msub><mo>(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d_i=Hash_2(Key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord"><span class="mord mathit">h</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>, 如果第一个散列函数Hash(key)得到的地址发生冲突时，利用第二个散列函数计算该关键字的地址增量。再散列法经过m-1次探测会遍历表中的所有的位置，回到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.08125em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>位置。</p><h6 id="4伪随机序列法简答题"><a class="markdownIt-Anchor" href="#4伪随机序列法简答题"></a> 4)伪随机序列法（简答题）</h6><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>=伪随机序列，称为伪随机序列法。</p><blockquote><p>注意在开放地址的情形下，不能随便物理删除所有元素，因为若删除元素将会截断其他具有相同散列地址元素的查找地址。所以若想删除一个元素时，给它做一个删除标记，进行逻辑删除。但副作用是，执行多次删除后，散列表表面上看起来很满，实际上有许多位置没用利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</p></blockquote><h5 id="2拉链法"><a class="markdownIt-Anchor" href="#2拉链法"></a> 2.拉链法</h5><p>假设散列地址为i的同义词链表的头指针存放在散列表的第i个单元中，因而查找、插入、删除都在同义词链中进行。</p><h3 id="散列查找及性能分析"><a class="markdownIt-Anchor" href="#散列查找及性能分析"></a> 散列查找及性能分析</h3><p>散列表的查找过程与构造散列表的过程基本一致。<br>装填因子：散列表的装填因子一般记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span>,定义为一个表的装满程度，即：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mrow><mi>n</mi></mrow><mrow><mi>m</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\alpha =\frac{n}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span> 其中n为表中记录数，m为散列表长度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;查找&quot;&gt;&lt;a class=&quot;markdow
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://blog.geekfan.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Concept of Data Structure</title>
    <link href="http://blog.geekfan.top/2017/10/24/struct/"/>
    <id>http://blog.geekfan.top/2017/10/24/struct/</id>
    <published>2017-10-24T12:59:21.000Z</published>
    <updated>2017-10-26T04:22:49.935Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="数据结构相关概念及定义"><a class="markdownIt-Anchor" href="#数据结构相关概念及定义"></a> 数据结构相关概念及定义</h2><h3 id="数据结构框架"><a class="markdownIt-Anchor" href="#数据结构框架"></a> 数据结构框架</h3><ul><li>数据结构<ul><li>逻辑结构<ul><li>线性结构<ul><li>线性表、栈、队列</li></ul></li><li>非线性结构<ul><li>树、图、集合</li></ul></li></ul></li><li>存储结构（存储结构）<ul><li>顺序存储、链式存储、索引存储、散列存储</li></ul></li><li>数据的运算</li></ul></li></ul><h3 id="什么是算法"><a class="markdownIt-Anchor" href="#什么是算法"></a> 什么是算法</h3><ul><li>算法 是对特定问题求解步骤的一种描述,它是指令的有限序列,其中每一条指令都表示一个或多个操作</li></ul><h3 id="算法的5个重要特性"><a class="markdownIt-Anchor" href="#算法的5个重要特性"></a> 算法的5个重要特性</h3><ul><li>有穷性 一个算法必须总是在执行有穷步之后结束,且每一步都可在有穷时间内完成</li><li>确定性 算法中每一条指令必须有确切的含义,读者理解时不会产生二义性,并且在任何条件下,算法只有-唯一的一条执行路径</li><li>可行性 一个算法是能行的,即算法描述的操作都是可以通过已经实现的基本运算执行优先次来实现的</li><li>输入   一个算法有零个或多个的输入,这些输入取自于某个特定的对象的集合</li><li>输出   一个算法有一个或多个输出,这些输出是同输入有着某些特定关系的量</li></ul><h3 id="算法设计要求"><a class="markdownIt-Anchor" href="#算法设计要求"></a> 算法设计要求</h3><ul><li>正确性 算法应当满足具体问题的需求。设计或选择的算法应当能正确的反应这种需求。</li><li>可读性 算法主要是为了人的阅读和交流，其次才是机器执行，可读性好有助于人对算法的理解。</li><li>健壮性 当输入数据非法时，算法也能适当的作出反应或进行处理，而不会产生莫名其妙的输出结果。</li></ul><h3 id="效率与低存储量需求"><a class="markdownIt-Anchor" href="#效率与低存储量需求"></a> 效率与低存储量需求</h3><p>通俗的说，效率指的是算法执行的时间。对于同一个问题如果有多种算法可以解决，执行时间短的算法效率高。低存储量需求指的是算法执行工程中所需要的最大存储空间。</p><h4 id="渐进时间复杂度"><a class="markdownIt-Anchor" href="#渐进时间复杂度"></a> 渐进时间复杂度</h4><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>它表示随问题规模n的增大,算法执行时间的增长率和f(n)的增长率相同,称做算法的渐进时间复杂度,简称时间复杂度,语句的频度指的是该语句重复执行的次数.<br>举例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">       (a)&#123;++x;s=<span class="number">0</span>;&#125;</div><div class="line">(b)<span class="keyword">for</span>(i= <span class="number">1</span>;i&lt;=n;++i)&#123;++x;s+=x;&#125;</div><div class="line">(c)<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;++j)</div><div class="line">       <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;++k)&#123;++x;s+=x;&#125;</div></pre></td></tr></table></figure><p>含基本操作”x增1”的语句频度分别为1、n和n2，则这三个程序段的时间复杂度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span> 分别称为常量阶、线性阶和平方阶，算法可能还有对数阶<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>、指数阶<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>等。</p><h3 id="数据结构的基本概念"><a class="markdownIt-Anchor" href="#数据结构的基本概念"></a> 数据结构的基本概念</h3><h4 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h4><p>数据，是对客观事务的符号表示,在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称</p><h4 id="数据元素"><a class="markdownIt-Anchor" href="#数据元素"></a> 数据元素</h4><p>数据元素，是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理</p><h4 id="数据对象"><a class="markdownIt-Anchor" href="#数据对象"></a> 数据对象</h4><p>数据对象 是性质形体的数据元素的集合,是数据的一个子集</p><h4 id="什么是数据结构"><a class="markdownIt-Anchor" href="#什么是数据结构"></a> 什么是数据结构</h4><p>数据结构 是相互直接存在一种或多种特定关系的数据元素的集合,这种数据元素相互之间的关系称为结构 ,根据数据元素之间关系的不同特性,通常有下列四类基本结构:</p><p>(1)集合 结构中的数据元素之间除了”属于同一个集合”的关系外,别无其他关系;<br>(2)线性结构  结构中的数据元素之间存在一个对一个的关系;<br>(3)树形结构 结构中的数据元素之间存在一个对多个的关系;<br>(4)图状结构或网状结构 结构中的数据元素之间存在多个对多个的关系</p><p>物理结构 数据结构在计算机中的表示(又称映像)称为数据的物理结构,又称存储结构</p><h4 id="元素节点"><a class="markdownIt-Anchor" href="#元素节点"></a> 元素/节点</h4><p>在计算机中,我们可以用一个由若干位组合起来形成的一个位串表示一个数据元素(如果一个字长的位串表示一个整数,用8位二进制数表示一个字符等),通常称这个位串为元素或节点.当数据元素由若干数据项组成时,位串中对应于各个数据项的子位串称为数据域.因此,元素或节点可看成是数据元素在计算机中的印象.</p><h4 id="存储结构-物理结构"><a class="markdownIt-Anchor" href="#存储结构-物理结构"></a> 存储结构 (物理结构)</h4><p>物理结构 数据结构在计算机中的表示(又称映像)称为数据的物理结构,又称存储结构</p><p>数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.顺序映像的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系.非顺序映像的特点是借助指示元素存储地址的指针表示数据元素之间的逻辑关系.</p><h4 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h4><p>数据类型是和数据结构密切相关的一个概念,他是最早出现在高级程序语言中,用以刻画(程序)操作对象的特性.</p><p>1.原子类型：其值不可再分<br>2.结构类型：可以在分解为若干分量<br>3.抽象数据类型：抽象数据组织和与之相关的操作</p><blockquote><p>按’值’的不同特性,高级程序语言中的数据类型可分为两类:<br>1.非结构的原子类型.原子类型的值是不可分解的,例如C语言中的基本类型(int/double…).<br>2.结构类型 结构类型的值是由若干成分按某种结构组成的,因此是可以分解的,并且它的成分可以是非结构的,也可以说是结构的.</p></blockquote><h4 id="抽象数据类型-adt"><a class="markdownIt-Anchor" href="#抽象数据类型-adt"></a> 抽象数据类型-ADT</h4><p>抽象数据类型(Abstract Date Type,简称ADT)是指一个数学模型以及定义在该模型上的一组操作.<br>ADT按其值的不同特性,可细分为下列三种类型:<br>原子类型 属原子类型的变量的值是不可分解的.这类抽象数据类型比较少,因为一般情况下已有的固有数据类型足以满足需求.<br>固定聚合类型 属该类型的变量,其值由确定数目的成分按某种结构组成.<br>可变聚合类型 和固定聚合类型相比较,构成可变聚合类型’值’的成分的数目不确定</p><p>和数据结构的形式相对应,抽象数据类型可用以下三元组表示:<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>D</mi><mi mathvariant="normal">.</mi><mi>S</mi><mi mathvariant="normal">.</mi><mi>P</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(D.S.P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span><br>D : 数据对象 S:   D上的关系集 P: 对D的基本操作集</p><h5 id="多形数据类型"><a class="markdownIt-Anchor" href="#多形数据类型"></a> 多形数据类型</h5><p>多形数据类型是指其值的成分不确定的数据类型</p><h3 id="线性表知识框架"><a class="markdownIt-Anchor" href="#线性表知识框架"></a> 线性表知识框架</h3><ul><li>线性表<ul><li>顺序存储<ul><li>顺序表</li></ul></li><li>链式存储<ul><li>单链表 （指针实现）</li><li>双链表 （指针实现）</li><li>循环链表 （指针实现）</li><li>静态链表</li></ul></li></ul></li></ul><h3 id="数据结构算法常用设置"><a class="markdownIt-Anchor" href="#数据结构算法常用设置"></a> 数据结构算法常用设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数结果状态码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TURE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></div><div class="line"><span class="comment">//Status 是函数的类型,其值是函数结果状态代码</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</div></pre></td></tr></table></figure><h4 id="基本函数"><a class="markdownIt-Anchor" href="#基本函数"></a> 基本函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//求最大值 </span></div><div class="line">max(表达式<span class="number">1</span>,…,表达式n)</div><div class="line"><span class="comment">//求最小值 </span></div><div class="line">min(表达式<span class="number">1</span>,…,表达式n)</div><div class="line"><span class="comment">//求绝对值 </span></div><div class="line"><span class="built_in">abs</span>(表达式)</div><div class="line"><span class="comment">//求不足整数值 </span></div><div class="line"><span class="built_in">floor</span>(表达式)</div><div class="line"><span class="comment">//求进位整数值 </span></div><div class="line"><span class="built_in">ceil</span> (表达式)</div><div class="line"><span class="comment">//判定文件结束 </span></div><div class="line">eof(文件变量) 或eof</div><div class="line"><span class="comment">//判定行结束 </span></div><div class="line">eoln(文件变量) 或eoln</div></pre></td></tr></table></figure><h3 id="常见数据结构类型定义"><a class="markdownIt-Anchor" href="#常见数据结构类型定义"></a> 常见数据结构类型定义</h3><h4 id="顺序表"><a class="markdownIt-Anchor" href="#顺序表"></a> 顺序表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//静态分配</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    ElemType data[MaxSize];</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">&#125;SqList;</div><div class="line"><span class="comment">//动态分配</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    ElemType *data;</div><div class="line">    <span class="keyword">int</span> MaxSize,length;</div><div class="line">&#125;SeqList;</div><div class="line"><span class="comment">//动态分配内存</span></div><div class="line">L.data=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType*)InitSize);</div></pre></td></tr></table></figure><h4 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;LNode, *LinkList;</div></pre></td></tr></table></figure><h4 id="静态链表"><a class="markdownIt-Anchor" href="#静态链表"></a> 静态链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50 </span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="keyword">int</span> next;</div><div class="line">&#125;SLinkList[MaxSize];</div></pre></td></tr></table></figure><h4 id="顺序栈"><a class="markdownIt-Anchor" href="#顺序栈"></a> 顺序栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    Elemtype data[MaxSize];</div><div class="line">    <span class="keyword">int</span> top;</div><div class="line">&#125; SqStack;</div></pre></td></tr></table></figure><h4 id="链式栈"><a class="markdownIt-Anchor" href="#链式栈"></a> 链式栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></div><div class="line">&#125; *LiStack;</div></pre></td></tr></table></figure><h4 id="顺序队列"><a class="markdownIt-Anchor" href="#顺序队列"></a> 顺序队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></div><div class="line"><span class="keyword">typedef</span> sturct &#123;</div><div class="line">    ElemType data[NaxSize];</div><div class="line">    <span class="keyword">int</span> front,rear;</div><div class="line">&#125;SqQueue;</div></pre></td></tr></table></figure><h4 id="链式队列"><a class="markdownIt-Anchor" href="#链式队列"></a> 链式队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;LinkNode;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    LinkNode *front , *rear ;</div><div class="line">&#125; LinkQueue;</div></pre></td></tr></table></figure><blockquote><p>队列相关操作：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">初始： Q.front=Q.rear=0</div><div class="line">队头指针进1(出队)：Q.front=(Q.front+1)%MaxSize</div><div class="line">队尾指针进1(入队)：Q.rear=(Q.rear+1)%MaxSize</div><div class="line">队列长度：(Q.rear+MaxSize-Q.front)%MaxSize</div><div class="line">队列已满：(Q.rear+1)%MaxSize==Q.front;</div><div class="line">队空:Q.front==Q.rear</div></pre></td></tr></table></figure><h4 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></div><div class="line">&#125;BiTNode,*BiTree;</div></pre></td></tr></table></figure><h4 id="线索二叉树"><a class="markdownIt-Anchor" href="#线索二叉树"></a> 线索二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></div><div class="line">&#125; ThreadNode,*ThreadNode;</div></pre></td></tr></table></figure><h4 id="图邻接矩阵法"><a class="markdownIt-Anchor" href="#图邻接矩阵法"></a> 图（邻接矩阵法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100 <span class="comment">//顶点数目的最大值</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">//顶点的数据类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;  <span class="comment">//带权图中边上权值的数据类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </div><div class="line">    VertexType Vex[MaxVertexNum]; <span class="comment">//顶点表</span></div><div class="line">    EdgeType Edge[MaxVertex]; <span class="comment">//邻接矩阵</span></div><div class="line">    <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的当前顶点数和弧度数</span></div><div class="line">&#125;MGragh;</div></pre></td></tr></table></figure><h4 id="图邻接表法"><a class="markdownIt-Anchor" href="#图邻接表法"></a> 图（邻接表法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100 <span class="comment">//顶点数目的最大值</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span> <span class="comment">//边表节点</span></div><div class="line">    <span class="keyword">int</span> adjvex; <span class="comment">//该弧所指向的顶点位置</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一条弧的指针</span></div><div class="line">    <span class="comment">//InfoType info; //网的边权值</span></div><div class="line">&#125;ArcNode;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> <span class="comment">//顶点表节点</span></div><div class="line">    VertexType data; <span class="comment">//顶点信息</span></div><div class="line">    ArcNode *first;  <span class="comment">//指向第一条依附该顶点的弧的指针</span></div><div class="line">&#125;VNode,AdjList[MaxVertexNum];</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">//邻接表</span></div><div class="line">    AdjList vertices;</div><div class="line">    <span class="keyword">int</span> vexnum,arcnum;  <span class="comment">//图的顶点数和弧数</span></div><div class="line">&#125;ALGraph; <span class="comment">//ALGraph是以邻接表存储的图类型</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;数据结构相关概念及定义&quot;&gt;&lt;a class
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://blog.geekfan.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Sort of Data Structure</title>
    <link href="http://blog.geekfan.top/2017/10/23/sort/"/>
    <id>http://blog.geekfan.top/2017/10/23/sort/</id>
    <published>2017-10-23T14:34:21.000Z</published>
    <updated>2017-10-24T10:36:41.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2><p>这里讨论的排序算法都是内排序算法</p><p>排序分为：</p><ul><li>插入排序<ul><li>直接插入排序</li><li>折半插入排序</li><li>Shell排序</li></ul></li><li>交换排序<ul><li>冒泡排序</li><li>快速排序</li></ul></li><li>选择排序<ul><li>简单选择排序</li><li>堆排序</li></ul></li><li>归并排序</li><li>基数排序</li></ul><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><p>插入排序是一种简单直观的排序方法,其基本思想在于每次将一个待排序的记录,按其关键字大小插入到前面已经排好序的子序列中,直到全部记录完成.</p><ul><li>由插入排序的思想可以引伸出三个重要排序算法: 直接插入排序 / 折半插入排序 / 希尔排序</li></ul><h4 id="直接插入排序"><a class="markdownIt-Anchor" href="#直接插入排序"></a> 直接插入排序</h4><p>在排序过程中序列的状态如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|  有序序列L[1...i-1]  |   L[i]   |    无序序列L[i+1...n]  |</div></pre></td></tr></table></figure><p>也就是说，每趟排序保证前面的序列是有序的。</p><p>排序流程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1 ) 查找出L[i]在L[1...i-1]中的位置 k</div><div class="line"></div><div class="line">2 ) 将L[k...i-1]中所有元素全部后移一个位置</div><div class="line"></div><div class="line">3 )将L[i]复制到L[k]</div></pre></td></tr></table></figure><p>C代码实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#不使用哨兵</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span> <span class="params">( ElemType A[ ],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j;</div><div class="line">    <span class="comment">//定义temp用于存储L[i]</span></div><div class="line">    ElemType temp;</div><div class="line">    <span class="comment">//外层循环</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</div><div class="line">        j=i;</div><div class="line">        <span class="comment">//将待排序的值赋值给temp</span></div><div class="line">        temp=A[i];</div><div class="line">        <span class="comment">//内存循环</span></div><div class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; temp &lt; A[j<span class="number">-1</span>] )&#123;</div><div class="line">            <span class="comment">//依次把待排序数和有序序列从后往前比较,如果比其小就往后移动</span></div><div class="line">            A[j]=A[j<span class="number">-1</span>];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找到所在位置，赋值</span></div><div class="line">        A[j]=temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#使用哨兵</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span> <span class="params">( ElemType A[ ],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j;</div><div class="line">    <span class="keyword">for</span>( i=<span class="number">2</span> ; i&lt;= n ; i++ )&#123;         <span class="comment">//依次将A[2]~A[n]插入到前面已排序</span></div><div class="line">        <span class="keyword">if</span>( A[i] &lt; A[i<span class="number">-1</span>] )&#123;  <span class="comment">//若A[i]小于其前驱</span></div><div class="line">            A[<span class="number">0</span>]=A[i];                <span class="comment">//复制为哨兵,A[0]不存放元素</span></div><div class="line">            <span class="keyword">for</span>( j=i<span class="number">-1</span> ; A[<span class="number">0</span>] &lt; A[j] ; --j )&#123;  <span class="comment">//从后往前查找待插入位置</span></div><div class="line">                A[j+<span class="number">1</span>] = A[j];        <span class="comment">//向后挪位</span></div><div class="line">            &#125;</div><div class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];              <span class="comment">//复制到插入位置</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>平均时间复杂度O(n²)</p><blockquote><p>最好情况下，表中元素已经有序，此时没插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)<br>最坏情况下，表中的元素为逆序，总的比较次数就达到最大，为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi></mrow><annotation encoding="application/x-tex">\sum _{i=1}^n i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0500099999999999em;vertical-align:-0.30001em;"></span><span class="base textstyle uncramped"><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">i</span></span></span></span>， 移动次数达到最大，为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></msubsup><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum _{i=2}^n (i+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0500099999999999em;vertical-align:-0.30001em;"></span><span class="base textstyle uncramped"><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">2</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p></blockquote><h4 id="折半插入排序"><a class="markdownIt-Anchor" href="#折半插入排序"></a> 折半插入排序:</h4><p>在前面简单插入排序过程中,每趟排序都进行了2项工作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.从前面的子表中查找出待插入元素应该被插入的位置</div><div class="line">2.给插入位置腾出空间</div></pre></td></tr></table></figure><p>折半查找原理很简单，就是把直接插入排序过程中的直接查找过程用二分查找代替，即减少比较次数。</p><p>C代码算法实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HalfInsertSort</span> <span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j , low , high , mid ;</div><div class="line">    <span class="keyword">for</span>( i=<span class="number">2</span> ; i &lt; n ; i++ )&#123;    <span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></div><div class="line">        A[<span class="number">0</span>] = A[i];             <span class="comment">//将A[i]暂存到A[0]</span></div><div class="line">        low = <span class="number">1</span>;                 <span class="comment">//设置折半查找的范围</span></div><div class="line">        high = i <span class="number">-1</span> ;           </div><div class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;      <span class="comment">//折半查找(默认递增有序)</span></div><div class="line">            mid = (low+high)/<span class="number">2</span>;  <span class="comment">//取中间点</span></div><div class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>])&#123; <span class="comment">//查找左半子表</span></div><div class="line">                high = mid<span class="number">-1</span>;   </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;  <span class="comment">//查找右半子表</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;high+<span class="number">1</span>;--j)&#123;  <span class="comment">//统一后移元素,空出插入位置</span></div><div class="line">            A[j+<span class="number">1</span>]=A[j];</div><div class="line">        &#125;</div><div class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];              <span class="comment">//插入操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>时间复杂度依旧为O(n²),折半插入排序仅仅是减少比较元素的次数,适用于n比较大时。</p></blockquote><h4 id="希尔shell排序"><a class="markdownIt-Anchor" href="#希尔shell排序"></a> 希尔(Shell)排序</h4><p>前面2种算法适用于基本有序或者数据量不大的排序表,基于这2点,1959年Shell提出希尔排序,又称为缩小增量排序.</p><p>基本思想:将排序表分成若干个形如L[i,i+d,i+2d,…,i+kd]的特殊子表,分别进行插入排序,当整个表基本有序时,再对全体记录经行一次直接插入排序</p><p>C代码算法实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span> <span class="params">(ElemType A[],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="comment">//对顺序表做希尔插入排序,该算法与直接插入排序相比,做了以下修改</span></div><div class="line">    <span class="comment">//1.前后记录位置增量是dk,不是1</span></div><div class="line">    <span class="comment">//2.A[0]知识暂存单元,不是哨兵,当j&lt;=0时,插入位置已到</span></div><div class="line">    <span class="keyword">int</span> dk,i,j;</div><div class="line">    <span class="keyword">for</span>(dk = n/<span class="number">2</span> ; dk &gt;= <span class="number">1</span> ; dk= dk/<span class="number">2</span> )&#123; <span class="comment">//步长变化</span></div><div class="line">        <span class="keyword">for</span>(i=dk+<span class="number">1</span>; i&lt;= n ; ++i )&#123;       </div><div class="line">            <span class="keyword">if</span>(A[i] &lt; A[i-dk] )&#123;  <span class="comment">//需将A[i]插入有序增量子表</span></div><div class="line">                A[<span class="number">0</span>]=A[i];                    <span class="comment">//暂存到A[0]</span></div><div class="line">                <span class="keyword">for</span>(j=i-dk ; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j] ; j-=dk )&#123; <span class="comment">//记录后移,查找插入位置</span></div><div class="line">                    A[j+dk]=A[j];</div><div class="line">                &#125;</div><div class="line">                A[j+dk]=A[<span class="number">0</span>];        <span class="comment">//插入</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度:O(n²)</p><h3 id="交换排序"><a class="markdownIt-Anchor" href="#交换排序"></a> 交换排序</h3><p>交换排序,就是根据序列中的两个元素关键字的比较结果来对换这两个记录在序列中的位置.基于交换的排序算法很多,考研主要要求冒泡排序和快速排序</p><h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h4><p>冒泡排序不多说,大家都懂,每趟排序都将待排序序列中最大/最小的元素找出来,这也是冒泡的由来</p><p>冒泡排序不同于直接插入排序，冒泡排序是两两相比，插入排序是</p><p>直接撸上C代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        flag=<span class="literal">false</span> ; <span class="comment">//表示每趟冒泡是否发生交换的标志</span></div><div class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123; <span class="comment">//一趟冒泡过程</span></div><div class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123; <span class="comment">//若为逆序</span></div><div class="line">                swap(A[j<span class="number">-1</span>],A[j]); <span class="comment">//交换</span></div><div class="line">                flag=<span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (flag==<span class="literal">false</span>)&#123;</div><div class="line">            <span class="keyword">return</span> ;  <span class="comment">//本趟遍历如果没有发送交换,说明表已经有序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度O(n²)</p><h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4><p>快速排序是对冒泡排序的一种改进。</p><p>C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">    <span class="comment">//i，j分别为扫描指针</span></div><div class="line">    <span class="comment">//i向右扫描大于等于left的元素</span></div><div class="line">    <span class="comment">//j向左扫描小于等于left的元素</span></div><div class="line">    <span class="keyword">int</span> i , j ; </div><div class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</div><div class="line">        i=left;</div><div class="line">        j=right+<span class="number">1</span>;</div><div class="line">        <span class="keyword">do</span>&#123;</div><div class="line">            <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(A[i] &lt;= A[left]);</div><div class="line">            <span class="keyword">do</span>&#123;j--;&#125;<span class="keyword">while</span>(A[j] &gt; A[left] );</div><div class="line">            <span class="comment">//大于left的数和小于left的数交换位置</span></div><div class="line">            <span class="keyword">if</span>(i&lt;j)&#123;swap(A[i],A[j]);&#125;</div><div class="line">        &#125;<span class="keyword">while</span>(i&lt;j);</div><div class="line">        <span class="comment">//当i大于等于j的时候跳出循环，此时将当前j所在位置，将left与j交换位置</span></div><div class="line">        swap(A[left],A[j]);        </div><div class="line">        <span class="comment">//从刚刚赋值的left的位置进行划分，分别进行快排</span></div><div class="line">        QuickSort(A,left,j<span class="number">-1</span>);</div><div class="line">        QuickSort(A,j+<span class="number">1</span>,right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j , left = <span class="number">0</span> , right = n<span class="number">-1</span>;</div><div class="line">    <span class="comment">//创建两个栈，分别用于存划分之后的左右部分</span></div><div class="line">    <span class="built_in">stack</span> SL,SR;</div><div class="line">    <span class="comment">//将left分别压栈</span></div><div class="line">    push(SL,left);</div><div class="line">    push(SR,left);</div><div class="line">    <span class="keyword">while</span>(!IsEmpty(SL) &amp;&amp; !IsEmpty(SR) )&#123;</div><div class="line">        left=pop(SL);</div><div class="line">        right=pop(SR);</div><div class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</div><div class="line">            i=left;</div><div class="line">            j=right+<span class="number">1</span>;</div><div class="line">            <span class="keyword">do</span>&#123;</div><div class="line">                <span class="comment">//比较方式与非递归算法相同</span></div><div class="line">                <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(A[i]&lt;A[left]);</div><div class="line">                <span class="keyword">do</span>&#123;j--;&#125;<span class="keyword">while</span>(A[j]&gt;A[left]);</div><div class="line">                <span class="comment">//大于left的数和小于left的数交换位置</span></div><div class="line">                <span class="keyword">if</span>(i&lt;j)swap(A[i],A[j]);</div><div class="line">            &#125;<span class="keyword">while</span>(i&lt;j);</div><div class="line">            <span class="comment">//当i大于等于j的时候跳出循环，此时将当前j所在位置，将left与j交换位置</span></div><div class="line">            swap(A[left],A[j]);</div><div class="line">            push(SL,j+<span class="number">1</span>);</div><div class="line">            push(SR,right);</div><div class="line">            push(SL,left);</div><div class="line">            push(SR,j<span class="number">-1</span>);</div><div class="line">            <span class="comment">//此时SL栈底是j+1(下一次i++，正好是中轴右面的元素)，栈顶是left（最左），SR栈底是right（最右），栈顶是j-1(中轴右面的元素)</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>空间效率：<br>最好情况: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lfloor log_2 (n+1) \right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌊</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌋</span></span></span></span></span><br>最坏情况： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>平均情况： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>有很多方法可以提高算法效率：</p><ul><li><p>[x] 当递归过程中划分得到的子序列规模较小时，不要再继续递归调用快速排序，可以直接采用直接插入排序法进行后续工作。</p></li><li><p>[x] 尽量取一个可以将数据中分的枢轴元素，使得最坏情况在实际排序中不会发生。</p></li></ul><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><p>选择排序的基本思想:<br>每一趟(如第i趟)在后面n-i+1(i=1,2…n-1) 个待排序元素中选取关键字最小的元素,作为有序子序列的第i个元素,直到第n-1趟做完,待排序元素只剩下1个,就不用再选了.</p><h4 id="简单选择排序"><a class="markdownIt-Anchor" href="#简单选择排序"></a> 简单选择排序</h4><h5 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想：</h5><p>每趟都从查找的集合里找到最大小的放最前面，然后缩小查找范围，直到查找范围里面只有一个数。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;  <span class="comment">//一共经行n-1趟</span></div><div class="line">        min=i;          <span class="comment">//记录最小元素位置</span></div><div class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;  <span class="comment">//在A[i...n-1]中选择最小元素</span></div><div class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])&#123;</div><div class="line">                min=j;</div><div class="line">                &#125; <span class="comment">//更新最小元素位置</span></div><div class="line">        &#125;                        </div><div class="line">        <span class="keyword">if</span> (min!=i)&#123;swap(A[i],A[min]);&#125; <span class="comment">//与第i个位置交换</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p><blockquote><p>元素移动次数不会超过3(n-1),比较次数与序列状态无关，始终是$ n(n-1)/2 $ 次</p></blockquote><p>空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p><h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4><h5 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h5><p>堆就是包含N个节点的完全二叉树，数的美国节点关键字值<code>大于等于1</code>或 <code>小于等于1</code> 其双亲节点的关键字的值，这颗二叉树的根称 <code>堆顶</code> ，是整个树的 <code>最大值</code>或者<code>最小值</code>,这个数分别对应的是 <code>最大堆</code> 或者 <code>最小堆</code> 。</p><h5 id="堆排序步骤"><a class="markdownIt-Anchor" href="#堆排序步骤"></a> 堆排序步骤</h5><ul><li>1. 建堆  <code>最大堆</code> 或者 <code>最小堆</code> （之后以最大堆为例）</li><li>2. 将堆顶与堆底互换，（然后把堆底元素拔下来）</li><li>3. 调整堆，使其为最大堆，重复2步骤。</li></ul><blockquote><p>跟冒泡和选择一样，每趟排序出一个最大的或者最小的，然后缩小范围,但是剩下的数组排列不一定和前面2个排序一样。</p></blockquote><h5 id="建堆大体流程"><a class="markdownIt-Anchor" href="#建堆大体流程"></a> 建堆大体流程</h5><p>构造堆的扫描指针，初始指针r在（n-1)/2,也就是最后一个有孩子的节点，对其所指的子树做向下调整操作（AdjustDown），最后结果是大元素放在树顶端调整结束后，初始指针r往前移动。</p><p>此时堆构造完成，开始第一趟排序，将堆顶A[0]与堆底元素A[n-1]交换，使用AdjustDown函数将A[0]向下调整，使得前n-1个元素仍是堆。</p><p>第i趟将A[0]与A[n-i]交换，A[0]向下调整，使剩余n-i个元素仍是堆，一直到堆中只剩下一个元素</p><p>C语言算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[],<span class="keyword">int</span> r,<span class="keyword">int</span> j)</span></span>&#123; <span class="comment">//j是最后一个节点编号</span></div><div class="line">    <span class="comment">//指向r的左孩子</span></div><div class="line">    <span class="keyword">int</span> child=<span class="number">2</span>*r+<span class="number">1</span>;</div><div class="line">    <span class="comment">//保存r的值</span></div><div class="line">    ElemType temp=A[r];</div><div class="line">    <span class="keyword">while</span>(child &lt;= j)&#123;</div><div class="line">        <span class="keyword">if</span>(child&lt;j &amp;&amp; (A[child]&lt;A[child+<span class="number">1</span>]))&#123;<span class="comment">//如果child不是最后的节点或并且小于兄弟节点</span></div><div class="line">            child++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp&gt;=A[child])&#123;<span class="keyword">break</span>;&#125;<span class="comment">//如果r比孩子节点都大则无需调整</span></div><div class="line">        A[(child<span class="number">-1</span>)/<span class="number">2</span>]=A[child];<span class="comment">//否则将child赋值给父节点</span></div><div class="line">        child=<span class="number">2</span>*child+<span class="number">1</span>; <span class="comment">//指向当前节点的左孩子</span></div><div class="line">    &#125;</div><div class="line">    A[(child<span class="number">-1</span>)/<span class="number">2</span>]=temp; <span class="comment">//将调整节点插入到该位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=(n<span class="number">-2</span>)/<span class="number">2</span>;i&gt;<span class="number">-1</span>;i--)&#123; AdjustDown(A,i,n<span class="number">-1</span>); &#125; <span class="comment">//构造堆</span></div><div class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123; <span class="comment">//进行堆排序</span></div><div class="line">        swap(A[<span class="number">0</span>],A[i]);</div><div class="line">        AdjustDown(A,<span class="number">0</span>,i<span class="number">-1</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>空间效率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><br>时间效率：建堆时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 平均调整时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><h3 id="归并排序二合一排序2-路归并排序"><a class="markdownIt-Anchor" href="#归并排序二合一排序2-路归并排序"></a> 归并排序（二合一排序/2-路归并排序）</h3><h4 id="思想-2"><a class="markdownIt-Anchor" href="#思想-2"></a> 思想</h4><p>将N个元素的序列看出是N个长度为1的有序子序列，然后两两合并子序列，得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lceil n/2 \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span>个长度为2或为1的有序子序列，再两两合并，直到得到一个长度为N的有序序列。</p><p>设置两个函数，<code>Merge()</code>的功能是将前后相邻的两个有序表归并成一个有序表的算法<code>MergeSort()</code>是完整的排序算法</p><p>C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ElemType *B = (ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>) *<span class="keyword">sizeof</span>(ElemType));<span class="comment">//构造辅助数组B</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i ,j ,k ;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)&#123;</div><div class="line">        B[k]=A[k]; <span class="comment">//将A中所有元素复制到B中</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i,i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</div><div class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])&#123;A[k]=B[i++];&#125; <span class="comment">//比较B左右两段中的元素，将较小的赋值到A中</span></div><div class="line">        <span class="keyword">else</span>&#123;A[k]=B[j++];&#125; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;A[k++]=B[i++];&#125; <span class="comment">//若第一个表未检测完 ，复制</span></div><div class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;A[k++]=B[j++];&#125; <span class="comment">//若第二个表未检测完 ，复制</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> mid ;</div><div class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</div><div class="line">        mid = (low+high)/<span class="number">2</span>; <span class="comment">//从中间划分子序列</span></div><div class="line">        MergeSort(A,low,mid); <span class="comment">//对左侧子序列进行递归排序</span></div><div class="line">        MergeSort(A,mid+<span class="number">1</span>,high); <span class="comment">//对右侧子序列进行递归排序</span></div><div class="line">        Merge(A,low,mid,high); <span class="comment">//归并</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>空间效率： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>时间效率： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mrow><mo fence="true">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">n \left \lceil log_2 n \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span></p><h3 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h3><p>基数排序是一种特别的排序方法，它不是基于比较进行排序的，而是采用多关键字思想（根据各位的大小排序），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。</p><h4 id="两种模式"><a class="markdownIt-Anchor" href="#两种模式"></a> 两种模式</h4><p>分为最高位优先排序（MSD），最低位优先（LSD）排序</p><p>直接附上C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, a[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, b[MAX], m = a[<span class="number">0</span>], <span class="built_in">exp</span> = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</div><div class="line">      m = a[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (m / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">int</span> bucket[BASE] = &#123; <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">      bucket[(a[i] / <span class="built_in">exp</span>) % BASE]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; BASE; i++) &#123;</div><div class="line">      bucket[i] += bucket[i - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">      b[--bucket[(a[i] / <span class="built_in">exp</span>) % BASE]] = a[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">      a[i] = b[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">exp</span> *= BASE;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOWPASS</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\nPASS   : "</span>);</div><div class="line">    print(a, n);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> arr[MAX];</div><div class="line">  <span class="keyword">int</span> i, n;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Enter total elements (n &lt;= %d) : "</span>, MAX);</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">  n = n &lt; MAX ? n : MAX;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Enter %d Elements : "</span>, n);</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nARRAY  : "</span>);</div><div class="line">  print(&amp;arr[<span class="number">0</span>], n);</div><div class="line"></div><div class="line">  radixsort(&amp;arr[<span class="number">0</span>], n);</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nSORTED : "</span>);</div><div class="line">  print(&amp;arr[<span class="number">0</span>], n);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>d</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(d(n+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 其中r是队列数，d是趟数<br>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;排序算法&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://blog.geekfan.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Primer</title>
    <link href="http://blog.geekfan.top/2017/10/20/Docker-Primer/"/>
    <id>http://blog.geekfan.top/2017/10/20/Docker-Primer/</id>
    <published>2017-10-20T07:34:21.000Z</published>
    <updated>2017-10-24T13:41:26.909Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="一-docker简介"><a class="markdownIt-Anchor" href="#一-docker简介"></a> 一、 Docker简介</h2><p>Docker 是一个开源项目。</p><p>可以把它理解为是一种新兴的超轻量级虚拟化技术。</p><p>传统虚拟化技术需要模拟计算机的一整套硬件出来，而且还要有自己的一套操作系统。</p><p>而 Docker 却不需要，它只需要与主机共享同一个内核，并充分利用 Linux 上内核的“环境隔离方案”来实现轻量级的虚拟化。</p><p>它在一些特定场景下与传统虚拟化技术相比，效率大幅提高，而资源开销却大幅降低。</p><p>Docker 的迁移也是十分方便的，基本上只需要把整个 Docker 目录搬过去即可。</p><p>Docker 使用 服务器-客户端 架构。</p><p>如果想在 Docker 上运行 exe 软件的话，那不用看下去了，左转找 KVM 去吧。</p><h2 id="二-理解-docker-的结构"><a class="markdownIt-Anchor" href="#二-理解-docker-的结构"></a> 二、理解 Docker 的结构</h2><p>四个基本结构：容器（Container）、镜像（Image）、仓库（Repository）、注册点（Registry）。</p><p>看着一脸懵逼对吧！是的，这几个概念确实比较难理解。但是我用类比法还是把它搞明白了。</p><p>先想象一个无盘系统是怎么样的，下面我们用一般的无盘系统来类比。</p><h3 id="21-镜像"><a class="markdownIt-Anchor" href="#21-镜像"></a> 2.1 镜像</h3><p>无盘服务器硬盘内有各种软件。比如说有 Win 7，还有各类应用软件。</p><p>而这些软件是相互依赖的。比如微信需要装 Win 7 系统才能运行。</p><p>各个无盘计算机（容器）想要运行什么软件可以直接告诉无盘服务器。</p><p>无盘服务器会准备好一切所需软件，打成一个包（镜像），然后推送给无盘计算机。</p><p>假设整个无盘系统中只有两种包。一种包是 Win 7 &amp; QQ，另一种包是 Win 7 &amp; 微信。</p><p>但是无论这两种包有多少个，都不会占用额外的硬盘空间（利用 Union mount 实现镜像分层）。只有 Win 7（某个镜像层） 、QQ、微信 这三个软件会占用硬盘空间。</p><p>一个镜像是这样被标识的：&lt;仓库名&gt;:&lt;标签名（版本号）&gt; ，例如nginx:latest。如果不指定标签，默认为 latest。</p><h3 id="22-容器"><a class="markdownIt-Anchor" href="#22-容器"></a> 2.2 容器</h3><p>相当于无盘计算机。</p><p>无盘计算机启动（容器启动）时，要从无盘服务器上拉取所需文件。如果无盘计算机对硬盘有写入操作的话，写入的数据将保存到无盘服务器的缓存区（容器存储层）。</p><p>无盘计算机关机（容器停止）时，如果没有额外设置，所有保存到无盘服务器的缓存区的文件（容器存储层）都将丢失。除非另外保存在 U 盘等外接设备（数据卷）中。</p><p>各个无盘计算机之间的运行互不干扰。（利用 cgroups 、namespace 实现隔离）</p><h3 id="23-仓库"><a class="markdownIt-Anchor" href="#23-仓库"></a> 2.3 仓库</h3><p>相当于同一个软件所有版本的集合。</p><h3 id="24-注册点"><a class="markdownIt-Anchor" href="#24-注册点"></a> 2.4 注册点</h3><p>相当于一个应用商店。</p><p>无盘服务器会来这里查找并下载软件。</p><h2 id="三-docker安装"><a class="markdownIt-Anchor" href="#三-docker安装"></a> 三、Docker安装</h2><h3 id="31-安装"><a class="markdownIt-Anchor" href="#31-安装"></a> 3.1 安装</h3><p>Docker 有好几个版本，社区版（Community Edition）、企业基础版（Enterprise Edition Basic）、企业标准版（Enterprise Edition Standard）、企业高级版（Enterprise Edition Advanced）。对于我们一般学习使用而言，使用社区版就已足够，所以记住CE就可以了。</p><p>其次，我们会看到一堆平台特定的版本， <code>Docker for Mac</code>、<code>Docker for Windows</code>、 <code>Docker Toolbox</code> 、 <code>Docker for Azure</code> 、<code>Docker for AWS</code> 等等，还有一堆不同 <code>Linux</code> 的发行版。那我们应该用哪个？其实不难选择，这都是平台特定的东西嘛，选择自己平台就完了：</p><ul><li>macOS 就选择 Docker for Mac；<ul><li>阿里云（未及时更新）：  <a href="https://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/" target="_blank" rel="external">https://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/stable/</a></li></ul></li><li>Linux 就选择自己平台的 Docker 源：<ul><li>Ubuntu: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/</a></li><li>Debian: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/debian/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/docker-ce/debian/</a></li><li>CentOS: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/docker-ce/centos/</a></li><li>Fedora: <a href="https://docs.docker.com/engine/installation/linux/docker-ce/fedora/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/docker-ce/fedora/</a></li></ul></li><li>Windows 要麻烦些：<ul><li>如果是 Windows 10 专业版、企业版、教育版，并且版本在 <code>10586</code> 以后，并且不打算在 Docker 运行同时再运行其它虚拟机的情况下，可以装 <code>Docker for Windows</code> 。<ul><li>阿里云（未及时更新）：<a href="https://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/stable/" target="_blank" rel="external">https://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/stable/</a></li></ul></li><li>其它情况都装 Docker Toolbox<ul><li>阿里云：<a href="https://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="external">https://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></li></ul></li></ul></li><li>如果是特定云服务平台，可以考虑特定服务平台的版本（当然，这不是必须）：<ul><li>AWS：Docker for AWS</li><li>Azure：Docker for Azure</li></ul></li></ul><p>最后是发布通道，从今年初开始，也就是从 <code>1.13</code> 以后，Docker 使用了新的版本号规则，将采用类似 Ubuntu 那种 <code>&lt;年&gt;.&lt;月&gt;</code> 的形式，比如 <code>17.03</code> , <code>17.06</code> 等。并且，将发布通道分为前沿版本(Edge)和稳定版本(Stable)。前沿通道将基本每个月发布一个版本，而稳定通道将基本每3个月发布一个版本。这样 Docker 的发布将有规律可寻。对于喜欢尝鲜的可以选择前沿版本，对于需要稳定的，可以选择稳定版本。</p><blockquote><p>这里面需要注意的是，在参考官方安装文档 (中文)配置 Linux 源的时候，如果是国内服务器，要将其中的 <code>https://download.docker.com/linux/</code> 替换为   <code>https://mirrors.aliyun.com/docker-ce/linux/</code>。</p></blockquote><p>比如，文档如果要求执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository \</div><div class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></div><div class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></div><div class="line"><span class="string">   stable"</span></div></pre></td></tr></table></figure><p>那么就替换为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository \</div><div class="line">   <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></div><div class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></div><div class="line"><span class="string">   stable"</span></div></pre></td></tr></table></figure><p>这样安装 <code>Docker</code>就会使用阿里云的软件源，而不需要翻墙了。</p><blockquote><p>（注：这不是加速器，不要搞错了，加速器依旧需要配！）</p></blockquote><h4 id="是直接用-yum-apt-get-安装-docker-吗"><a class="markdownIt-Anchor" href="#是直接用-yum-apt-get-安装-docker-吗"></a> 是直接用 yum / apt-get 安装 Docker 吗？</h4><h4 id="很多人问到-docker-dockerio-docker-engine-甚至-lxc-docker-都有什么区别"><a class="markdownIt-Anchor" href="#很多人问到-docker-dockerio-docker-engine-甚至-lxc-docker-都有什么区别"></a> 很多人问到 docker, <a href="http://docker.io" target="_blank" rel="external">docker.io</a>, docker-engine 甚至 lxc-docker 都有什么区别？</h4><p>其中，RHEL/CentOS 软件源中的 Docker 包名为 docker；Ubuntu 软件源中的 Docker 包名为 <a href="http://docker.io" target="_blank" rel="external">docker.io</a>；而很古老的 Docker 源中 Docker 也曾叫做 lxc-docker。这些都是非常老旧的 Docker 版本，并且基本不会更新到最新的版本，而对于使用 Docker 而言，使用最新版本非常重要。另外，17.04 以后，包名从 docker-engine 改为 docker-ce，因此从现在开始安装，应该都使用 docker-ce 这个包。</p><blockquote><p>不要使用操作系统提供的软件源中的 Docker 包，去使用 Docker 官方源的包。</p></blockquote><h4 id="正确的安装方法有两种"><a class="markdownIt-Anchor" href="#正确的安装方法有两种"></a> 正确的安装方法有两种：</h4><p>一种是参考官方安装文档去配置 apt 或者 yum 的源；<br>另一种则是使用官方提供的安装脚本快速安装。<br>官方文档对配置源的方法已经有很详细的讲解，这里就不赘述，需要的直接去看官方文档。这里只介绍使用官方的脚本快速安装：</p><ul><li>17.04 及以后的版本</li></ul><p>从 17.04 以后，可以用下面的命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export CHANNEL=stable</div><div class="line">curl -fsSL https://get.docker.com/ | sh -s -- --mirror Aliyun</div></pre></td></tr></table></figure><p>这里使用的是官方脚本安装，通过环境变量指定安装通道为 stable，（如果喜欢尝鲜可以改为 edge, test），并且指定使用阿里云的源(apt/yum)来安装 Docker CE 版本。</p><ul><li>17.03 及以前的版本</li></ul><p>早期的版本可以使用阿里云或者 DaoCloud 老的脚本安装：</p><p>使用阿里云的安装脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</div></pre></td></tr></table></figure><p>使用DaoCloud的Docker安装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/docker | sh</div></pre></td></tr></table></figure><h4 id="不是都已经发布-docker-1707-了么我怎么升级到最新还是-1705-呀"><a class="markdownIt-Anchor" href="#不是都已经发布-docker-1707-了么我怎么升级到最新还是-1705-呀"></a> 不是都已经发布 Docker 17.07 了么？我怎么升级到最新还是 17.05 呀？</h4><p>从 17.04 以后，Docker 的源的结构以及包名都进行了调整，因此如果你你还使用的是旧的源，那么需要参照官方文档，更新源的地址为新的源。前面的问答中已经给出了链接和替代用的阿里云源镜像地址，参照修改（apt/yum）源。</p><p>修改好后，卸载旧的 docker-engine，安装新的 docker-ce 即可。</p><h3 id="32-配置加速器"><a class="markdownIt-Anchor" href="#32-配置加速器"></a> 3.2 配置加速器</h3><p>首先，要“感谢”伟大的墙及其亲属。</p><p>然后，我们可以使用 Docker 镜像加速器来解决这个问题，加速器就是镜像、代理的概念。国内有不少机构提供了免费的加速器以方便大家使用，这里列出一些常用的加速器服务：</p><ul><li><p>Docker 官方的中国镜像加速器：从2017年6月9日起，Docker 官方提供了在中国的加速器，以解决墙的问题。不用注册，直接使用加速器地址：<code>https://registry.docker-cn.com</code> 即可。<br>中国科技大学的镜像加速器：中科大的加速器不用注册，直接使用地址 <code>https://docker.mirrors.ustc.edu.cn/</code> 配置加速器即可。进一步的信息可以访问：<code>http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker</code></p></li><li><p>阿里云加速器：注册阿里云开发账户(免费的)后，访问这个链接就可以看到加速器地址： <code>https://cr.console.aliyun.com/#/accelerator</code></p></li><li><p>DaoCloud 加速器：注册 DaoCloud 账户(支持微信登录)，然后访问： <code>https://www.daocloud.io/mirror#accelerator-doc</code></p></li></ul><p>注意：不要使用加速器网站所给的配置脚本，容易导致错误。我们只需获取其提供的加速器地址即可。</p><h4 id="ubuntu-1404-配置加速器或其它使用-upstart-的系统"><a class="markdownIt-Anchor" href="#ubuntu-1404-配置加速器或其它使用-upstart-的系统"></a> Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）</h4><p>Ubuntu 14.04 是使用 upstart 进行系统初始化的，对于这类系统，可以用通过编辑配置文件的方法来配置加速器。</p><p>如果是 Ubuntu 14.04，那么编辑 <code>/etc/default/docker</code> ，在里面寻找 DOCKER_OPTS 环境变量设置的这一行，在其后添加  <code>-–registry-mirror=&lt;加速器地址&gt;</code>。如果发现该行已被注释，或者不存在该行，那么新添一行即可。</p><p>比如，在使用官方源安装了 <code>docker-engine</code> 后，会建立一个默认的 <code>/etc/default/docker</code>，其中相关 <code>DOCKER_OPTS</code> 的行是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use DOCKER_OPTS to modify the daemon startup options.</span></div><div class="line"><span class="comment">#DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"</span></div></pre></td></tr></table></figure><p>假设我们的加速器地址为 <code>https://registry.docker-cn.com</code>，我们添加一行配置，将其改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Use DOCKER_OPTS to modify the daemon startup options.</span></div><div class="line"><span class="comment">#DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"</span></div><div class="line">DOCKER_OPTS=<span class="string">"--registry-mirror=https://registry.docker-cn.com"</span></div></pre></td></tr></table></figure><p>保存文件后，重启 Docker 引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo service docker restart</div><div class="line">docker stop/waiting</div><div class="line">docker start/running, process 3620</div></pre></td></tr></table></figure><p>重启成功后，确认一下配置是否已经生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo ps -ef | grep dockerd</div><div class="line">root      3620     1  0 04:26 ?        00:00:00 /usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com --raw-logs</div></pre></td></tr></table></figure><p>如果配置成功，生效后这里就会看到自己所配置的加速器的内容。</p><h4 id="ubuntu-1604-或-centos-7-配置加速器或其它使用-systemd-的系统"><a class="markdownIt-Anchor" href="#ubuntu-1604-或-centos-7-配置加速器或其它使用-systemd-的系统"></a> Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）</h4><p>Ubuntu 16.04 和 CentOS 7 这类系统都已经开始使用 systemd 进行系统初始化管理了，对于使用 systemd 的系统，应该通过编辑服务配置文件 docker.service 来进行加速器的配置。</p><p>在启用服务后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo systemctl <span class="built_in">enable</span> docker</div></pre></td></tr></table></figure><p>可以直接编辑 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code> 文件来进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/systemd/system/multi-user.target.wants/docker.service</div></pre></td></tr></table></figure><p>在文件中找到 ExecStart= 这一行，并且在其行尾添加上所需的配置。假设我们的加速器地址为 <code>https://registry.docker-cn.com</code> ，那么可以这样配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecStart=/usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com</div></pre></td></tr></table></figure><p>更多请参考官方文档：<br><code>https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/</code></p><h2 id="四-运行第一个容器"><a class="markdownIt-Anchor" href="#四-运行第一个容器"></a> 四、运行第一个容器</h2><h3 id="41-运行-helloworld-容器"><a class="markdownIt-Anchor" href="#41-运行-helloworld-容器"></a> 4.1 运行 Helloworld 容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run hello-world</div></pre></td></tr></table></figure><h3 id="42-过程解析"><a class="markdownIt-Anchor" href="#42-过程解析"></a> 4.2 过程解析</h3><ul><li>Docker 客户端向 Docker 守护进程发出运行命令。</li><li>Docker 守护进程发现没有 hello-world 这个镜像，于是从仓库中寻找并下载它。</li><li>下载完毕之后，Docker 守护进程以 hello-world 这个镜像创建一个新的容器。</li><li>容器向 Docker 守护进程输出内容之后，容器停止。Docker 守护进程把输出的内容传递给 Docker 客户端。</li></ul><h2 id="五-docker的基本操作"><a class="markdownIt-Anchor" href="#五-docker的基本操作"></a> 五、Docker的基本操作</h2><p>下面以创建一个 Ubuntu 系统的容器为例来了解一下 Docker 的基本操作。</p><p>为了方便理解，我把命令完整地写出来。</p><p>本节的命令参数只有最基本的参数，需要其他设置（如数据卷）的话会在后面讲到。</p><blockquote><p>PS:   Docker 命令支持自动补全</p></blockquote><h3 id="51-常用格式"><a class="markdownIt-Anchor" href="#51-常用格式"></a> 5.1 常用格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker image pull [&lt;注册点名&gt;/]&lt;仓库名&gt;[:&lt;标签名（版本号）&gt;]</div></pre></td></tr></table></figure><blockquote><p>若不指定注册点名，将使用默认的 library/。</p></blockquote><blockquote><p>若不指定标签名，将使用默认的 latest。</p></blockquote><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker image pull ubuntu</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Using default tag: latest</div><div class="line">latest: Pulling from library/ubuntu</div><div class="line">d5c6f90da05d: Pull complete </div><div class="line">1300883d87d5: Pull complete </div><div class="line">c220aa3cfc1b: Pull complete </div><div class="line">2e9398f099dc: Pull complete </div><div class="line">dc27a084064f: Pull complete </div><div class="line">Digest: sha256:34471448724419596ca4e890496d375801de21b0e67b81a77fd6155ce001edad</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</div></pre></td></tr></table></figure><p>可以明显地看出，镜像被分为了多个块。523315523315</p><h3 id="52-以某个镜像建立一个容器"><a class="markdownIt-Anchor" href="#52-以某个镜像建立一个容器"></a> 5.2 以某个镜像建立一个容器</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container create --interactive --tty [--name=&lt;容器名&gt;] &lt;镜像名&gt; [要运行的程序和参数]</div></pre></td></tr></table></figure><ul><li><p>如果不指定容器名，系统会自动为之分配一个无重复的容器名。</p></li><li><p>如果本地不存在指定的镜像，会自动从注册点中拉取。</p></li></ul><blockquote><p>–interactive 表示持续为容器打开 stdin 以便随时接受操作。</p></blockquote><blockquote><p>–tty 表示为容器分配一个伪终端，这样我们才可以方便的操作容器。</p></blockquote><p>要运行的程序和参数 指定容器启动后要运行镜像里的哪一个程序。这个程序运行结束后，容器也会停止。如果不指定，则使用镜像的默认值。</p><p>例如</p><p>以 ubuntu 为镜像，建立一个名为 ubuntu_test 的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container create --interactive --tty --name=ubuntu_test ubuntu</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">46cc818c92f0780ccd89811c12906c4527b554d18a61e72b0b2337b663ebab5f</div></pre></td></tr></table></figure><blockquote><p>这是自动生成的容器唯一长 ID。</p></blockquote><h3 id="53-启动一个容器"><a class="markdownIt-Anchor" href="#53-启动一个容器"></a> 5.3 启动一个容器</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container start &lt;容器名&gt; [容器名] [容器名] ...</div></pre></td></tr></table></figure><p>可同时启动多个容器。</p><p>例如</p><p>启动刚才创建的 ubuntu_test 容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container start ubuntu_test</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ubuntu_test</div></pre></td></tr></table></figure><p>返回容器名称，说明启动成功。</p><h3 id="54-查看容器信息"><a class="markdownIt-Anchor" href="#54-查看容器信息"></a> 5.4 查看容器信息</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container ls [--all] [--no-trunc]</div></pre></td></tr></table></figure><ul><li>如果不加 --all 选项，则只显示运行中的容器。</li></ul><blockquote><p>–no-trunc 表示完整显示容器的长 ID （形如 7.2 中命令的执行结果）。为了方便查看，一般不需要加此选项。</p></blockquote><p>例如</p><p>查看本机所有容器的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container ls --all</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</div><div class="line"><span class="comment">#&lt;容器ID&gt;         &lt;镜像名&gt;               &lt;命令参数&gt;          &lt;创建时间&gt;          &lt;状态&gt;                        &lt;打开的端口&gt;         &lt;容器名称&gt;</span></div><div class="line">d4bc3be9148d        hello-world         <span class="string">"/hello"</span>            5 hours ago         Exited (0) 5 hours ago                          practical_rosalind</div><div class="line">46cc818c92f0        ubuntu              <span class="string">"/bin/bash"</span>         3 hours ago         Up 2 minutes                                    ubuntu_test</div></pre></td></tr></table></figure><p>可以看到，除了刚创建的 ubuntu_test 容器之外，还有一个名为 practical_rosalind 容器。practical_rosalind 这个容器正是刚才运行 docker run hello-world 时生成的。</p><h3 id="55-操作一个容器-容器内外进程简析"><a class="markdownIt-Anchor" href="#55-操作一个容器-容器内外进程简析"></a> 5.5 操作一个容器 &amp; 容器内外进程简析</h3><h4 id="551-操作一个容器"><a class="markdownIt-Anchor" href="#551-操作一个容器"></a> 5.5.1 操作一个容器</h4><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container attach &lt;容器名&gt;</div></pre></td></tr></table></figure><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container attach ubuntu_test</div></pre></td></tr></table></figure><p>执行之后按几下回车，如果出现类似 root@46cc818c92f0:/# 的提示符，那说明您已经在容器内操作了。</p><p>我们来查看下系统的版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uname -a</div><div class="line"></div><div class="line">Linux 46cc818c92f0 3.10.0-514.26.2.el7.x86_64 <span class="comment">#1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></div></pre></td></tr></table></figure><p>好像看不出是 Ubuntu 系统，没关系，我们再执行下以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">cat /etc/os-release</div><div class="line"></div><div class="line">NAME=<span class="string">"Ubuntu"</span></div><div class="line">VERSION=<span class="string">"16.04.3 LTS (Xenial Xerus)"</span></div><div class="line">ID=ubuntu</div><div class="line">ID_LIKE=debian</div><div class="line">PRETTY_NAME=<span class="string">"Ubuntu 16.04.3 LTS"</span></div><div class="line">VERSION_ID=<span class="string">"16.04"</span></div><div class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></div><div class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></div><div class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></div><div class="line">VERSION_CODENAME=xenial</div><div class="line">UBUNTU_CODENAME=xenial</div></pre></td></tr></table></figure><p>好，已经确定了是在虚拟的 Ubuntu 系统中操作了！我们再来看一下容器内都有什么进程吧。</p><h4 id="552-容器内进程简析"><a class="markdownIt-Anchor" href="#552-容器内进程简析"></a> 5.5.2 容器内进程简析</h4><p>在容器内执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">USER PID %CPU %MEM VSZ  RSS TTY STAT START  TIME COMMAND</div><div class="line">root 1 0.0 0.0 18304 2072 pts/0 Ss  05:19  0:00 /bin/bash</div><div class="line">root 229 0.0 0.0 34416 1436 pts/0 R+  07:27  0:00 ps aux</div></pre></td></tr></table></figure><p>可以看到，容器中目前只存在 bash 和刚开启的 ps 这两个进程，而且 bash 的 PID 为 1 ！</p><p>这说明了容器处在与实体机不同的 namespace 中，容器看不到实体机的进程。</p><p>容器进程数目与传统虚拟机的进程数目相比大幅减少了，所以说容器的效率非常高，启动基本上是毫秒级的！</p><h4 id="553-容器外进程简析"><a class="markdownIt-Anchor" href="#553-容器外进程简析"></a> 5.5.3 容器外进程简析</h4><p>实体机可以看到容器内的进程吗？答案是可以的。</p><p>我们来看下实体机上的进程树。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">systemd─┬─ModemManager───2*[&#123;ModemManager&#125;</div><div class="line">        ├─dockerd─┬─docker-containe─┬─docker-containe─┬─bash</div><div class="line">        │         │                 │                 └─8*[&#123;docker-containe&#125;]</div><div class="line">        │         │                 └─12*[&#123;docker-containe&#125;]</div><div class="line">        │         └─11*[&#123;dockerd&#125;]</div><div class="line"><span class="comment">#无关部分已省略</span></div></pre></td></tr></table></figure><p>可以看出，bash 属于 dockerd 的子进程。</p><p>这说明了容器处在实体机的子 namespace 中，同时需要依赖实体机中的进程才可以运行。</p><p>所以，容器并不是完全的“虚拟化”。</p><h3 id="56-从容器中脱开"><a class="markdownIt-Anchor" href="#56-从容器中脱开"></a> 5.6 从容器中脱开</h3><p>前面 5.2 我们已经说过了：容器启动时会运行镜像里指定的应用程序，而这个程序运行结束后，容器也会停止。</p><p>现在这个容器启动时运行了镜像默认设定的的 /bin/bash ，所以当 /bin/bash 关闭时，容器就会跟着关闭。</p><p>如果直接按 Ctrl + D 退出容器操作的话，bash 就会退出而使整个容器停止运行，我们显然不希望这样。</p><p>正确的脱开方法是 先按 Ctrl+P 再按 Q （跟 Screen 的操作方法非常相似）。</p><p>执行完该操作之后，如果出现 read escape sequence ，就说明已经从容器中脱开了。</p><h3 id="57-停止一个容器"><a class="markdownIt-Anchor" href="#57-停止一个容器"></a> 5.7 停止一个容器</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container stop &lt;容器名&gt;</div></pre></td></tr></table></figure><p>执行完以上命令之后，实体机将向容器内所有的进程发送 SIGTERM 信号，然后给 10 秒的时间，让容器内的进程可以“优雅地”结束。</p><p>如果容器内的进程在 10 秒内没有结束，则实体机向未结束的进程发送 SIGKILL 信号来强制结束。</p><p>如果想立即强制结束容器的话把 stop 换成 kill 就行了。</p><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container stop ubuntu_test</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ubuntu_test</div></pre></td></tr></table></figure><p>返回容器名称，说明容器已经停止。</p><h3 id="58-删除一个容器"><a class="markdownIt-Anchor" href="#58-删除一个容器"></a> 5.8 删除一个容器</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container rm &lt;容器名&gt;</div></pre></td></tr></table></figure><p>请注意：运行中的容器不能被删除。</p><p>例如</p><p>我们把刚才第一个使用 hello-world 镜像的容器给删掉，容器名从上面 5.4 中得到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container rm practical_rosalind</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">practical_rosalind</div></pre></td></tr></table></figure><p>返回容器名称，说明容器已经删除。</p><h3 id="59-查看镜像信息"><a class="markdownIt-Anchor" href="#59-查看镜像信息"></a> 5.9 查看镜像信息</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images [--all]</div></pre></td></tr></table></figure><p>没有加 -all 的话将只显示顶层镜像，加了 -all 的话除了显示顶层镜像之外还会显示中间层（依赖）镜像。</p><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure><p>执行结果</p><p>这里我们顺便回顾一下，一个镜像是这样标识的： &lt;仓库名&gt;:&lt;标签名（版本号）&gt; 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line"><span class="comment">#&lt;所在仓库&gt;        &lt;标签&gt;               &lt;镜像 ID&gt;            &lt;创建时间&gt;          &lt;大小&gt;</span></div><div class="line">ubuntu              latest              ccc7a11d65b1        4 weeks ago         120MB</div><div class="line">hello-world         latest              1815c82652c0        2 months ago        1.84kB</div></pre></td></tr></table></figure><h3 id="510-删除一个镜像"><a class="markdownIt-Anchor" href="#510-删除一个镜像"></a> 5.10 删除一个镜像</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker image rm &lt;镜像名&gt;</div></pre></td></tr></table></figure><p>请注意：如果有基于要删除镜像的容器，则该镜像不能被删除。</p><p>例如</p><p>我们把刚才第一个下载的 hello-world:latest 镜像给删掉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker image rm hello-world:latest</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Untagged: hello-world:latest</div><div class="line">Untagged: hello-world@sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f</div><div class="line">Deleted: sha256:1815c82652c03bfd8644afda26fb184f2ed891d921b20a0703b46768f9755c57</div><div class="line">Deleted: sha256:45761469c965421a92a69cc50e92c01e0cfa94fe026cdd1233445ea00e96289a</div></pre></td></tr></table></figure><p>镜像已经删除。</p><h3 id="511-使用一次性容器推荐用于测试或开发环境"><a class="markdownIt-Anchor" href="#511-使用一次性容器推荐用于测试或开发环境"></a> 5.11 使用一次性容器（推荐用于测试或开发环境）</h3><p>上述步骤目的其实是为了让大家更好地理解 Docker 的结构。</p><p>我认为 Docker 有一个缺点，那就是容器一旦创建完成之后，想要修改配置就有点麻烦。而在测试或开发环境中，经常需要修改容器的配置。</p><p>好在，容器非常轻，完全可以做到“用时创建、用完即删”！</p><p>所以，我还是推荐大家使用以下命令，来做到容器创建、启动、删除三合一。</p><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container run --rm [--detach] --interactive --tty [--name=&lt;容器名&gt;] &lt;镜像名&gt; [要运行的程序和参数]</div></pre></td></tr></table></figure><blockquote><p>–rm 表示容器停止之后删除容器。</p></blockquote><blockquote><p>–detach 表示容器启动之后不进入容器内操作。</p></blockquote><ul><li>其他选项请参考 5.2。</li></ul><p>执行完该命令之后，容器会自动创建然后启动。如果没有加入 --detach 选项，容器启动完成后会直接进入到容器中操作（可随时脱开）。</p><p>而容器停止之后，容器就会马上被删除，非常方便。</p><p>下文均使用一次性容器。</p><h3 id="512-配置容器的自重启推荐用于生产环境"><a class="markdownIt-Anchor" href="#512-配置容器的自重启推荐用于生产环境"></a> 5.12 配置容器的自重启（推荐用于生产环境）</h3><p>常用格式</p><p>在 5.2 或 5.11 的 --tty 后面插入如下格式的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--restart on-failure|unless-stopped|always</div></pre></td></tr></table></figure><p>有三种自重启方式。</p><blockquote><p>on-failure 表示容器停止时，若出现错误则自动重启（进程返回值不为 0）。在 Docker 服务重启时，不能自动重启。</p></blockquote><blockquote><p>unless-stopped 表示容器停止时，若没有出现错误则自动重启（进程返回值为 0）。在 Docker 服务重启时，通常可以自动重启。</p></blockquote><blockquote><p>always 表示一旦容器停止，都将自动重启。在 Docker 服务重启时，可以自动重启。</p></blockquote><ul><li><p>请注意，如果执行了 docker container stop 或者 docker container kill 命令，容器自重启将失效。</p></li><li><p>–restart 不能和 --rm 同时使用，也就是说不适用于一次性容器。</p></li></ul><h3 id="513-查看容器的详细配置信息"><a class="markdownIt-Anchor" href="#513-查看容器的详细配置信息"></a> 5.13 查看容器的详细配置信息</h3><p>把容器所有配置参数以 json 格式显示出来，这里只做了解。</p><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container inspect &lt;容器名&gt;</div></pre></td></tr></table></figure><h3 id="514-查看镜像的详细信息"><a class="markdownIt-Anchor" href="#514-查看镜像的详细信息"></a> 5.14 查看镜像的详细信息</h3><p>把镜像所有参数以 json 格式显示出来，这里只做了解。</p><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker image inspect &lt;镜像名&gt;</div></pre></td></tr></table></figure><h3 id="515-快速删除所有容器"><a class="markdownIt-Anchor" href="#515-快速删除所有容器"></a> 5.15 快速删除所有容器</h3><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container rm $(docker container ls --all -q)</div></pre></td></tr></table></figure><p>请注意：运行中的容器不能被删除。</p><h2 id="六-保存容器中的数据"><a class="markdownIt-Anchor" href="#六-保存容器中的数据"></a> 六、保存容器中的数据</h2><p>前面我们已经说过，容器一旦停止，容器内文件的所有改动都将丢失。</p><p>所以，我们必须指定一个可以存储数据的方法，才能保存容器内的数据。</p><h3 id="61-使用数据卷"><a class="markdownIt-Anchor" href="#61-使用数据卷"></a> 6.1 使用数据卷</h3><p>简单地说，数据卷就是在容器内指定一个目录，存储在这个目录下的数据都可以持久化保存。</p><p>常用格式</p><p>在 5.2 或 5.11 的 --tty 后面插入如下格式的内容</p><blockquote><p>–volume [&lt;实体机文件或目录&gt;:]&lt;容器内文件或目录&gt; [–volume [&lt;实体机文件或目录&gt;:]&lt;容器内文件或目录&gt;] …</p></blockquote><p>为了方便容器的迁移以及维护工作，通常会指定实体机内的某个文件或目录映射到容器内的某个文件或目录中。</p><p>如果不指定实体机文件或目录，Docker 将会自动分配一个实体机目录。</p><p>可以创建多个数据卷。</p><p>例如</p><p>以 ubuntu 为镜像，建立一个名为 ubuntu_test2 的容器并启动，将实体机上的 /root/ubuntu_files1目录挂载到容器中的 /test/ubuntu_files1 目录中去（实体机上的目录已存在）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container run --rm --interactive --tty --volume /root/ubuntu_files1:/<span class="built_in">test</span>/ubuntu_files1 --name=ubuntu_test2 ubuntu:latest</div></pre></td></tr></table></figure><p>执行完该命令后，我们已经是在容器内操作了。此时我们来看看容器内是否出现了挂载的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls /<span class="built_in">test</span>/ubuntu_files1</div></pre></td></tr></table></figure><p>如果没有返回错误信息，说明挂载成功。现在我们来向里面写一点东西，看下能不能保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"File saved"</span> &gt; /<span class="built_in">test</span>/ubuntu_files1/1.txt</div></pre></td></tr></table></figure><p>然后按 Ctrl + D 关闭容器。我们就来到实体机下了，接下来我们来看看实体机有没有这个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /root/ubuntu_files1/1.txt</div></pre></td></tr></table></figure><ul><li>如果返回了  <code>File saved</code> ，说明数据已经可以保存了！</li></ul><p>您也可以再次创建容器，然后在容器内看看 <code>/test/ubuntu_files1/1.txt</code> 这个文件在不在。</p><h3 id="62-打包一个新的镜像不推荐"><a class="markdownIt-Anchor" href="#62-打包一个新的镜像不推荐"></a> 6.2 打包一个新的镜像（不推荐）</h3><p>这种方法十分简单粗暴，就是把容器内现有文件全部打包成一个新的镜像，然后新建一个使用该映像的容器即可实现文件的保存。</p><p>之所以不推荐，主要是因为这样做会把容器内运行程序的缓存等无用文件一并打包下来。如果多次执行该操作，容器会变得非常臃肿。其次也可能会造成一定的安全隐患。</p><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container commit &lt;需要保存的容器名&gt; &lt;打包之后的镜像名&gt;</div></pre></td></tr></table></figure><p>这里就不举例了。</p><h2 id="七-容器的网络连接"><a class="markdownIt-Anchor" href="#七-容器的网络连接"></a> 七、容器的网络连接</h2><h3 id="71-容器联网的基本方式"><a class="markdownIt-Anchor" href="#71-容器联网的基本方式"></a> 7.1 容器联网的基本方式</h3><p>NAT 模式是容器默认的联网模式。</p><p>在启动 Docker 服务之后，Docker 会自动往实体机内添加一个名为 docker0 的网桥，这个网桥默认可以与实体机内所有的网络接口通信。</p><p>我们通过执行 <code>brctl show</code>  这条命令来看一下 docker0 网桥的状态。</p><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bridge name  bridge id  STP enabled  interfaces</div><div class="line">docker0  8000.024229c84e5a  no</div></pre></td></tr></table></figure><p>当容器启动之后，会生成一个形如 vethXXXXXXX 的容器专用接口。这个接口也会加入到 docker0 的桥接列表中。</p><p>docker0 上面有 IP 地址，也可以自动为每个容器分配 IP 地址（非 DHCP 协议）。</p><p>我们通过执行 <code>ip addr show dev docker0</code> 还有  <code>brctl show docker0</code> 这条两命令来看一下。</p><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">6: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP </div><div class="line"> link/ether 02:42:29:c8:4e:5a brd ff:ff:ff:ff:ff:ff</div><div class="line"> inet 172.17.0.1/16 scope global docker0</div><div class="line"> valid_lft forever preferred_lft forever</div><div class="line"> inet6 fe80::42:29ff:fec8:4e5a/64 scope link</div><div class="line"> valid_lft forever preferred_lft forever</div><div class="line"></div><div class="line">bridge name  bridge id  STP enabled  interfaces</div><div class="line">docker0  8000.024229c84e5a  no  vethcd2a637</div></pre></td></tr></table></figure><p>其实 docker0 就相当于一个普通的路由器，通过 NAT 转换实现容器间的相互通信和连接外网。</p><p>我们通过执行 <code>iptables -t nat -L POSTROUTING -v -n</code> 来查看相关的 NAT 规则。</p><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Chain POSTROUTING (policy ACCEPT 373 packets, 31640 bytes)</div><div class="line"> pkts bytes target  prot opt <span class="keyword">in</span>  out  <span class="built_in">source</span>  destination         </div><div class="line"> 12  729 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0</div></pre></td></tr></table></figure><p>很显然，存在 docker0 网段的 SNAT 规则，说明容器都是通过 NAT 的方式与实体机共享网络的。</p><p>如需查看容器的 IP 地址，请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container inspect --format=<span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> &lt;容器名&gt;</div></pre></td></tr></table></figure><h3 id="72-自定义网桥-容器-ip-地址"><a class="markdownIt-Anchor" href="#72-自定义网桥-容器-ip-地址"></a> 7.2 自定义网桥 &amp; 容器 IP 地址</h3><p>使用默认网桥一般是不能自定义容器 IP 地址的，会提示以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">User specified IP address is supported only when connecting to networks with user configured subnets</div></pre></td></tr></table></figure><p>这时候，我们就需要自定义一个网桥。</p><h4 id="721-自定义网桥"><a class="markdownIt-Anchor" href="#721-自定义网桥"></a> 7.2.1 自定义网桥</h4><p>常用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network create --driver bridge --subnet &lt;网桥网段&gt; &lt;网桥名&gt;</div></pre></td></tr></table></figure><p>例如</p><p>创建一个名为 docker_br1 的网桥，网段为 192.168.10.0/24</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network create --driver bridge --subnet 192.168.10.0/24 docker_br1</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">46cc818c92f0780ccd89811c12906c4527b554d18a61e72b0b2337b663ebab5f</div></pre></td></tr></table></figure><p>这是自动生成的网桥唯一长 ID。</p><p>网桥的管理和删除命令格式和上面镜像管理的相似，这里就不再说了。</p><h4 id="722-自定义容器-ip-地址"><a class="markdownIt-Anchor" href="#722-自定义容器-ip-地址"></a> 7.2.2 自定义容器 IP 地址</h4><p>常用格式</p><p>在 5.2 或 5.11 的 --tty 后面插入如下格式的内容</p><blockquote><p>–network=&lt;网桥名&gt; --ip=&lt;IP地址&gt;</p></blockquote><p>例如</p><p>创建并运行一个使用刚才创建的 docker_br1 网桥的容器，把 IP 地址设定为 192.168.10.211 ，然后验证结果。</p><p>为了方便，这里将直接运行一个包含 ifconfig 命令的镜像的容器，然后执行 ifconfig eth0 命令来验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container run --rm --interactive --tty --network=docker_br1 --ip=192.168.10.211 --name=see_ip_addr ianneub/network-tools ifconfig eth0</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#镜像下载过程略</span></div><div class="line">eth0 Link encap:Ethernet HWaddr 02:42:c0:a8:0a:02  </div><div class="line"> inet addr:192.168.10.211 Bcast:0.0.0.0 Mask:255.255.255.0</div><div class="line"> UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</div><div class="line"> RX packets:2 errors:0 dropped:0 overruns:0 frame:0</div><div class="line"> TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</div><div class="line"> collisions:0 txqueuelen:0</div><div class="line"> RX bytes:180 (180.0 B) TX bytes:0 (0.0 B)</div></pre></td></tr></table></figure><p>显然，这里的 IP 地址已经是我们设定的 192.168.10.211 。</p><h3 id="73-端口映射"><a class="markdownIt-Anchor" href="#73-端口映射"></a> 7.3 端口映射</h3><p>如果容器需要对外提供服务，在默认情况下需要把容器内的端口映射到实体机上。</p><p>常用格式</p><p>在 5.2 或 5.11 的 --tty 后面插入如下格式的内容</p><blockquote><p>-p [&lt;实体机接口 IP 地址&gt;:]&lt;实体机端口&gt;:&lt;容器内端口&gt;[/&lt;tcp|udp&gt;] [-p [&lt;实体机接口 IP 地址&gt;:]&lt;实体机端口&gt;:&lt;容器内端口&gt;[/&lt;tcp|udp&gt;]] …</p></blockquote><p>可以创建多个端口映射。</p><p>如果不指定实体机接口 IP 地址，则容器内端口将映射到实体机的所有网络接口上。</p><p>如果不指定 TCP 或 UDP 协议，默认使用 TCP 协议。</p><p>例如</p><p>运行一个提供 HTTP 服务的镜像（这里用 nginx）的容器，然后把容器中的 80 端口映射到实体机上的 8888 端口，最后测试能否访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container run --detach --rm --interactive --tty -p 8888:80 --name=nginx_test nginx &amp;&amp; curl 127.0.0.1:8888</div></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div></pre></td></tr></table></figure><p>如果含有以上内容的界面，说明端口映射成功。</p><h3 id="74-为容器设置域名解析不建议使用"><a class="markdownIt-Anchor" href="#74-为容器设置域名解析不建议使用"></a> 7.4 为容器设置域名解析(不建议使用)</h3><p>在很多情况下，我们需要在容器之间进行网络通信。而它们的 IP 地址又是不固定的，这就需要为容器固定一个 DNS 名称。</p><p>假设现在有一个容器 A ，而新建的容器 B 需要访问容器 A 上的网络服务，在没设置域名解析的情况下容器 B 只能通过容器 A 的 IP 地址来访问容器 A 。而如果在容器 B 建立的时候设置了域名解析，容器 B 就可以通过容器 A 的名称或别名来访问容器 A 。</p><p>常用格式</p><p>在 5.2 或 5.11 的 --tty 后面插入如下格式的内容</p><blockquote><p>–link &lt;容器名称&gt;[:&lt;容器别名&gt;]<br>如果不设置容器别名，将自动使用容器名称。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&gt;&lt;h2 id=&quot;一-docker简介&quot;&gt;&lt;a class=
      
    
    </summary>
    
    
      <category term="docker" scheme="http://blog.geekfan.top/tags/docker/"/>
    
  </entry>
  
</feed>
