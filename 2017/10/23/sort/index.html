<!DOCTYPE html>
<html>
    <head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
    <title>
        
        Sort of Data Structure · Funky&#39;s Blog
        
    </title>
    <link rel="icon" href= /assests/favicon.ico>
    <!-- TODO: 在font-face加载完毕后改变字体  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.28/webfontloader.js"></script>
    <!-- 提前加载place holder  -->
    <style type="text/css">
        @font-face {
            font-family: 'Oswald-Regular';
            src: url('/font/Oswald-Regular.ttf');
        }
    </style>
    <style type="text/css">
        .site-intro-placeholder {
            position: absolute;
            z-index: -2;
            top: 0;
            left: 0px;
            width: calc(100% + 300px);
            height: 100%;
            background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
            background-position: center center;
            transform: translate3d(-226px, 0, 0);
            animation: gradient-move 2.5s ease-out 0s 1;
        }
        @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>
    <link rel="stylesheet" href = /css/style.css?v=20171020 />
    <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js" defer></script>
    
    <script src="/scripts/main.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  --><!-- hexo-inject:begin --><link rel='stylesheet' href='custom_css_source'><!-- hexo-inject:end -->
    
</head>
    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Funky&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Sort of Data Structure</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Funky's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-img" style="background-image: url(http://oumn0o088.bkt.clouddn.com/post-bg.jpg)"></div>
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Sort of Data Structure
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
        </p>
        <!-- 404 -->
        
        <!-- 文章页meta -->
        
            <!-- 文章页标签  -->
            
                <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-href = Data Structure>Data Structure</a>
    
</div>
            
            <div class="post-intro-meta">
                <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                <span class="post-intro-time">2017/10/23</span>
            </div>
        
    </div>
</div>
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <script>
            var browser = {
                    versions: function () {
                        var u = window.navigator.userAgent;
                        return {
                            userAgent: u,
                            trident: u.indexOf('Trident') > -1, //IE内核
                            presto: u.indexOf('Presto') > -1, //opera内核
                            webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                            gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                            ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                            android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                            iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
                            iPad: u.indexOf('iPad') > -1, //是否为iPad
                            webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
                            weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
                            uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
                        };
                    }()
                }

            function fontLoaded(){
                console.log('font loaded');
                if (document.getElementsByClassName('site-intro-meta')) {
                    document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
                    document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
                    var postIntroTags = document.getElementsByClassName('post-intro-tags')[0],
                        postIntroMeat = document.getElementsByClassName('post-intro-meta')[0];
                        if (postIntroTags) {
                            postIntroTags.classList.add('post-fade-in');
                        }
                        if (postIntroMeat) {
                            postIntroMeat.classList.add('post-fade-in');
                        }
                    }
                }
                
            console.log("userAgent:" + browser.versions.userAgent);
            // UC不支持跨域，所以直接显示
            if (browser.versions.uc) {
                console.log("UCBrowser");
                fontLoaded();
            } else {
                WebFont.load({
                    custom: {
                        families: ['Oswald-Regular']
                    },
                    loading: function () {  //所有字体开始加载
                        // console.log('loading');
                    },
                    active: function () {  //所有字体已渲染
                        fontLoaded();
                    },
                    inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
                        console.log('inactive: timeout');
                        fontLoaded();
                    },
                    timeout: 7000 // Set the timeout to two seconds
                });
            }
        </script>
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2>
<p>这里讨论的排序算法都是内排序算法</p>
<p>排序分为：</p>
<ul>
<li>插入排序
<ul>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>Shell排序</li>
</ul>
</li>
<li>交换排序
<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>选择排序
<ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3>
<p>插入排序是一种简单直观的排序方法,其基本思想在于每次将一个待排序的记录,按其关键字大小插入到前面已经排好序的子序列中,直到全部记录完成.</p>
<ul>
<li>由插入排序的思想可以引伸出三个重要排序算法: 直接插入排序 / 折半插入排序 / 希尔排序</li>
</ul>
<h4 id="直接插入排序"><a class="markdownIt-Anchor" href="#直接插入排序"></a> 直接插入排序</h4>
<p>在排序过程中序列的状态如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|  有序序列L[1...i-1]  |   L[i]   |    无序序列L[i+1...n]  |</div></pre></td></tr></table></figure>
<p>也就是说，每趟排序保证前面的序列是有序的。</p>
<p>排序流程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1 ) 查找出L[i]在L[1...i-1]中的位置 k</div><div class="line"></div><div class="line">2 ) 将L[k...i-1]中所有元素全部后移一个位置</div><div class="line"></div><div class="line">3 )将L[i]复制到L[k]</div></pre></td></tr></table></figure>
<p>C代码实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#不使用哨兵</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span> <span class="params">( ElemType A[ ],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j;</div><div class="line">    <span class="comment">//定义temp用于存储L[i]</span></div><div class="line">    ElemType temp;</div><div class="line">    <span class="comment">//外层循环</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</div><div class="line">        j=i;</div><div class="line">        <span class="comment">//将待排序的值赋值给temp</span></div><div class="line">        temp=A[i];</div><div class="line">        <span class="comment">//内存循环</span></div><div class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; temp &lt; A[j<span class="number">-1</span>] )&#123;</div><div class="line">            <span class="comment">//依次把待排序数和有序序列从后往前比较,如果比其小就往后移动</span></div><div class="line">            A[j]=A[j<span class="number">-1</span>];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找到所在位置，赋值</span></div><div class="line">        A[j]=temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#使用哨兵</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span> <span class="params">( ElemType A[ ],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j;</div><div class="line">    <span class="keyword">for</span>( i=<span class="number">2</span> ; i&lt;= n ; i++ )&#123;         <span class="comment">//依次将A[2]~A[n]插入到前面已排序</span></div><div class="line">        <span class="keyword">if</span>( A[i] &lt; A[i<span class="number">-1</span>] )&#123;  <span class="comment">//若A[i]小于其前驱</span></div><div class="line">            A[<span class="number">0</span>]=A[i];                <span class="comment">//复制为哨兵,A[0]不存放元素</span></div><div class="line">            <span class="keyword">for</span>( j=i<span class="number">-1</span> ; A[<span class="number">0</span>] &lt; A[j] ; --j )&#123;  <span class="comment">//从后往前查找待插入位置</span></div><div class="line">                A[j+<span class="number">1</span>] = A[j];        <span class="comment">//向后挪位</span></div><div class="line">            &#125;</div><div class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];              <span class="comment">//复制到插入位置</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>平均时间复杂度O(n²)</p>
<blockquote>
<p>最好情况下，表中元素已经有序，此时没插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)<br>
最坏情况下，表中的元素为逆序，总的比较次数就达到最大，为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi></mrow><annotation encoding="application/x-tex">\sum _{i=1}^n i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0500099999999999em;vertical-align:-0.30001em;"></span><span class="base textstyle uncramped"><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">i</span></span></span></span>， 移动次数达到最大，为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></msubsup><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum _{i=2}^n (i+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.0500099999999999em;vertical-align:-0.30001em;"></span><span class="base textstyle uncramped"><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">2</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h4 id="折半插入排序"><a class="markdownIt-Anchor" href="#折半插入排序"></a> 折半插入排序:</h4>
<p>在前面简单插入排序过程中,每趟排序都进行了2项工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.从前面的子表中查找出待插入元素应该被插入的位置</div><div class="line">2.给插入位置腾出空间</div></pre></td></tr></table></figure>
<p>折半查找原理很简单，就是把直接插入排序过程中的直接查找过程用二分查找代替，即减少比较次数。</p>
<p>C代码算法实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HalfInsertSort</span> <span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j , low , high , mid ;</div><div class="line">    <span class="keyword">for</span>( i=<span class="number">2</span> ; i &lt; n ; i++ )&#123;    <span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></div><div class="line">        A[<span class="number">0</span>] = A[i];             <span class="comment">//将A[i]暂存到A[0]</span></div><div class="line">        low = <span class="number">1</span>;                 <span class="comment">//设置折半查找的范围</span></div><div class="line">        high = i <span class="number">-1</span> ;           </div><div class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;      <span class="comment">//折半查找(默认递增有序)</span></div><div class="line">            mid = (low+high)/<span class="number">2</span>;  <span class="comment">//取中间点</span></div><div class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>])&#123; <span class="comment">//查找左半子表</span></div><div class="line">                high = mid<span class="number">-1</span>;   </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;  <span class="comment">//查找右半子表</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;high+<span class="number">1</span>;--j)&#123;  <span class="comment">//统一后移元素,空出插入位置</span></div><div class="line">            A[j+<span class="number">1</span>]=A[j];</div><div class="line">        &#125;</div><div class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];              <span class="comment">//插入操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度依旧为O(n²),折半插入排序仅仅是减少比较元素的次数,适用于n比较大时。</p>
</blockquote>
<h4 id="希尔shell排序"><a class="markdownIt-Anchor" href="#希尔shell排序"></a> 希尔(Shell)排序</h4>
<p>前面2种算法适用于基本有序或者数据量不大的排序表,基于这2点,1959年Shell提出希尔排序,又称为缩小增量排序.</p>
<p>基本思想:将排序表分成若干个形如L[i,i+d,i+2d,…,i+kd]的特殊子表,分别进行插入排序,当整个表基本有序时,再对全体记录经行一次直接插入排序</p>
<p>C代码算法实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span> <span class="params">(ElemType A[],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="comment">//对顺序表做希尔插入排序,该算法与直接插入排序相比,做了以下修改</span></div><div class="line">    <span class="comment">//1.前后记录位置增量是dk,不是1</span></div><div class="line">    <span class="comment">//2.A[0]知识暂存单元,不是哨兵,当j&lt;=0时,插入位置已到</span></div><div class="line">    <span class="keyword">int</span> dk,i,j;</div><div class="line">    <span class="keyword">for</span>(dk = n/<span class="number">2</span> ; dk &gt;= <span class="number">1</span> ; dk= dk/<span class="number">2</span> )&#123; <span class="comment">//步长变化</span></div><div class="line">        <span class="keyword">for</span>(i=dk+<span class="number">1</span>; i&lt;= n ; ++i )&#123;       </div><div class="line">            <span class="keyword">if</span>(A[i] &lt; A[i-dk] )&#123;  <span class="comment">//需将A[i]插入有序增量子表</span></div><div class="line">                A[<span class="number">0</span>]=A[i];                    <span class="comment">//暂存到A[0]</span></div><div class="line">                <span class="keyword">for</span>(j=i-dk ; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j] ; j-=dk )&#123; <span class="comment">//记录后移,查找插入位置</span></div><div class="line">                    A[j+dk]=A[j];</div><div class="line">                &#125;</div><div class="line">                A[j+dk]=A[<span class="number">0</span>];        <span class="comment">//插入</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度:O(n²)</p>
<h3 id="交换排序"><a class="markdownIt-Anchor" href="#交换排序"></a> 交换排序</h3>
<p>交换排序,就是根据序列中的两个元素关键字的比较结果来对换这两个记录在序列中的位置.基于交换的排序算法很多,考研主要要求冒泡排序和快速排序</p>
<h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h4>
<p>冒泡排序不多说,大家都懂,每趟排序都将待排序序列中最大/最小的元素找出来,这也是冒泡的由来</p>
<p>冒泡排序不同于直接插入排序，冒泡排序是两两相比，插入排序是</p>
<p>直接撸上C代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        flag=<span class="literal">false</span> ; <span class="comment">//表示每趟冒泡是否发生交换的标志</span></div><div class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123; <span class="comment">//一趟冒泡过程</span></div><div class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123; <span class="comment">//若为逆序</span></div><div class="line">                swap(A[j<span class="number">-1</span>],A[j]); <span class="comment">//交换</span></div><div class="line">                flag=<span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (flag==<span class="literal">false</span>)&#123;</div><div class="line">            <span class="keyword">return</span> ;  <span class="comment">//本趟遍历如果没有发送交换,说明表已经有序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度O(n²)</p>
<h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4>
<p>快速排序是对冒泡排序的一种改进。</p>
<p>C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">    <span class="comment">//i，j分别为扫描指针</span></div><div class="line">    <span class="comment">//i向右扫描大于等于left的元素</span></div><div class="line">    <span class="comment">//j向左扫描小于等于left的元素</span></div><div class="line">    <span class="keyword">int</span> i , j ; </div><div class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</div><div class="line">        i=left;</div><div class="line">        j=right+<span class="number">1</span>;</div><div class="line">        <span class="keyword">do</span>&#123;</div><div class="line">            <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(A[i] &lt;= A[left]);</div><div class="line">            <span class="keyword">do</span>&#123;j--;&#125;<span class="keyword">while</span>(A[j] &gt; A[left] );</div><div class="line">            <span class="comment">//大于left的数和小于left的数交换位置</span></div><div class="line">            <span class="keyword">if</span>(i&lt;j)&#123;swap(A[i],A[j]);&#125;</div><div class="line">        &#125;<span class="keyword">while</span>(i&lt;j);</div><div class="line">        <span class="comment">//当i大于等于j的时候跳出循环，此时将当前j所在位置，将left与j交换位置</span></div><div class="line">        swap(A[left],A[j]);        </div><div class="line">        <span class="comment">//从刚刚赋值的left的位置进行划分，分别进行快排</span></div><div class="line">        QuickSort(A,left,j<span class="number">-1</span>);</div><div class="line">        QuickSort(A,j+<span class="number">1</span>,right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//非递归算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i , j , left = <span class="number">0</span> , right = n<span class="number">-1</span>;</div><div class="line">    <span class="comment">//创建两个栈，分别用于存划分之后的左右部分</span></div><div class="line">    <span class="built_in">stack</span> SL,SR;</div><div class="line">    <span class="comment">//将left分别压栈</span></div><div class="line">    push(SL,left);</div><div class="line">    push(SR,left);</div><div class="line">    <span class="keyword">while</span>(!IsEmpty(SL) &amp;&amp; !IsEmpty(SR) )&#123;</div><div class="line">        left=pop(SL);</div><div class="line">        right=pop(SR);</div><div class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</div><div class="line">            i=left;</div><div class="line">            j=right+<span class="number">1</span>;</div><div class="line">            <span class="keyword">do</span>&#123;</div><div class="line">                <span class="comment">//比较方式与非递归算法相同</span></div><div class="line">                <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(A[i]&lt;A[left]);</div><div class="line">                <span class="keyword">do</span>&#123;j--;&#125;<span class="keyword">while</span>(A[j]&gt;A[left]);</div><div class="line">                <span class="comment">//大于left的数和小于left的数交换位置</span></div><div class="line">                <span class="keyword">if</span>(i&lt;j)swap(A[i],A[j]);</div><div class="line">            &#125;<span class="keyword">while</span>(i&lt;j);</div><div class="line">            <span class="comment">//当i大于等于j的时候跳出循环，此时将当前j所在位置，将left与j交换位置</span></div><div class="line">            swap(A[left],A[j]);</div><div class="line">            push(SL,j+<span class="number">1</span>);</div><div class="line">            push(SR,right);</div><div class="line">            push(SL,left);</div><div class="line">            push(SR,j<span class="number">-1</span>);</div><div class="line">            <span class="comment">//此时SL栈底是j+1(下一次i++，正好是中轴右面的元素)，栈顶是left（最左），SR栈底是right（最右），栈顶是j-1(中轴右面的元素)</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>空间效率：<br>
最好情况: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lfloor log_2 (n+1) \right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌊</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌋</span></span></span></span></span><br>
最坏情况： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>
平均情况： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>
有很多方法可以提高算法效率：</p>
<ul>
<li>
<p>[x] 当递归过程中划分得到的子序列规模较小时，不要再继续递归调用快速排序，可以直接采用直接插入排序法进行后续工作。</p>
</li>
<li>
<p>[x] 尽量取一个可以将数据中分的枢轴元素，使得最坏情况在实际排序中不会发生。</p>
</li>
</ul>
<h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3>
<p>选择排序的基本思想:<br>
每一趟(如第i趟)在后面n-i+1(i=1,2…n-1) 个待排序元素中选取关键字最小的元素,作为有序子序列的第i个元素,直到第n-1趟做完,待排序元素只剩下1个,就不用再选了.</p>
<h4 id="简单选择排序"><a class="markdownIt-Anchor" href="#简单选择排序"></a> 简单选择排序</h4>
<h5 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想：</h5>
<p>每趟都从查找的集合里找到最大小的放最前面，然后缩小查找范围，直到查找范围里面只有一个数。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;  <span class="comment">//一共经行n-1趟</span></div><div class="line">        min=i;          <span class="comment">//记录最小元素位置</span></div><div class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;  <span class="comment">//在A[i...n-1]中选择最小元素</span></div><div class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])&#123;</div><div class="line">                min=j;</div><div class="line">                &#125; <span class="comment">//更新最小元素位置</span></div><div class="line">        &#125;                        </div><div class="line">        <span class="keyword">if</span> (min!=i)&#123;swap(A[i],A[min]);&#125; <span class="comment">//与第i个位置交换</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p>
<blockquote>
<p>元素移动次数不会超过3(n-1),比较次数与序列状态无关，始终是$ n(n-1)/2 $ 次</p>
</blockquote>
<p>空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p>
<h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4>
<h5 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h5>
<p>堆就是包含N个节点的完全二叉树，数的美国节点关键字值<code>大于等于1</code>或 <code>小于等于1</code> 其双亲节点的关键字的值，这颗二叉树的根称 <code>堆顶</code> ，是整个树的 <code>最大值</code>或者<code>最小值</code>,这个数分别对应的是 <code>最大堆</code> 或者 <code>最小堆</code> 。</p>
<h5 id="堆排序步骤"><a class="markdownIt-Anchor" href="#堆排序步骤"></a> 堆排序步骤</h5>
<ul>
<li>1. 建堆  <code>最大堆</code> 或者 <code>最小堆</code> （之后以最大堆为例）</li>
<li>2. 将堆顶与堆底互换，（然后把堆底元素拔下来）</li>
<li>3. 调整堆，使其为最大堆，重复2步骤。</li>
</ul>
<blockquote>
<p>跟冒泡和选择一样，每趟排序出一个最大的或者最小的，然后缩小范围,但是剩下的数组排列不一定和前面2个排序一样。</p>
</blockquote>
<h5 id="建堆大体流程"><a class="markdownIt-Anchor" href="#建堆大体流程"></a> 建堆大体流程</h5>
<p>构造堆的扫描指针，初始指针r在（n-1)/2,也就是最后一个有孩子的节点，对其所指的子树做向下调整操作（AdjustDown），最后结果是大元素放在树顶端调整结束后，初始指针r往前移动。</p>
<p>此时堆构造完成，开始第一趟排序，将堆顶A[0]与堆底元素A[n-1]交换，使用AdjustDown函数将A[0]向下调整，使得前n-1个元素仍是堆。</p>
<p>第i趟将A[0]与A[n-i]交换，A[0]向下调整，使剩余n-i个元素仍是堆，一直到堆中只剩下一个元素</p>
<p>C语言算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(ElemType A[],<span class="keyword">int</span> r,<span class="keyword">int</span> j)</span></span>&#123; <span class="comment">//j是最后一个节点编号</span></div><div class="line">    <span class="comment">//指向r的左孩子</span></div><div class="line">    <span class="keyword">int</span> child=<span class="number">2</span>*r+<span class="number">1</span>;</div><div class="line">    <span class="comment">//保存r的值</span></div><div class="line">    ElemType temp=A[r];</div><div class="line">    <span class="keyword">while</span>(child &lt;= j)&#123;</div><div class="line">        <span class="keyword">if</span>(child&lt;j &amp;&amp; (A[child]&lt;A[child+<span class="number">1</span>]))&#123;<span class="comment">//如果child不是最后的节点或并且小于兄弟节点</span></div><div class="line">            child++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(temp&gt;=A[child])&#123;<span class="keyword">break</span>;&#125;<span class="comment">//如果r比孩子节点都大则无需调整</span></div><div class="line">        A[(child<span class="number">-1</span>)/<span class="number">2</span>]=A[child];<span class="comment">//否则将child赋值给父节点</span></div><div class="line">        child=<span class="number">2</span>*child+<span class="number">1</span>; <span class="comment">//指向当前节点的左孩子</span></div><div class="line">    &#125;</div><div class="line">    A[(child<span class="number">-1</span>)/<span class="number">2</span>]=temp; <span class="comment">//将调整节点插入到该位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=(n<span class="number">-2</span>)/<span class="number">2</span>;i&gt;<span class="number">-1</span>;i--)&#123; AdjustDown(A,i,n<span class="number">-1</span>); &#125; <span class="comment">//构造堆</span></div><div class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123; <span class="comment">//进行堆排序</span></div><div class="line">        swap(A[<span class="number">0</span>],A[i]);</div><div class="line">        AdjustDown(A,<span class="number">0</span>,i<span class="number">-1</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>空间效率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><br>
时间效率：建堆时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 平均调整时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p>
<h3 id="归并排序二合一排序2-路归并排序"><a class="markdownIt-Anchor" href="#归并排序二合一排序2-路归并排序"></a> 归并排序（二合一排序/2-路归并排序）</h3>
<h4 id="思想-2"><a class="markdownIt-Anchor" href="#思想-2"></a> 思想</h4>
<p>将N个元素的序列看出是N个长度为1的有序子序列，然后两两合并子序列，得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">\left \lceil n/2 \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span>个长度为2或为1的有序子序列，再两两合并，直到得到一个长度为N的有序序列。</p>
<p>设置两个函数，<code>Merge()</code>的功能是将前后相邻的两个有序表归并成一个有序表的算法<code>MergeSort()</code>是完整的排序算法</p>
<p>C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ElemType *B = (ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>) *<span class="keyword">sizeof</span>(ElemType));<span class="comment">//构造辅助数组B</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i ,j ,k ;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)&#123;</div><div class="line">        B[k]=A[k]; <span class="comment">//将A中所有元素复制到B中</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i,i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</div><div class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])&#123;A[k]=B[i++];&#125; <span class="comment">//比较B左右两段中的元素，将较小的赋值到A中</span></div><div class="line">        <span class="keyword">else</span>&#123;A[k]=B[j++];&#125; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;A[k++]=B[i++];&#125; <span class="comment">//若第一个表未检测完 ，复制</span></div><div class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;A[k++]=B[j++];&#125; <span class="comment">//若第二个表未检测完 ，复制</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> mid ;</div><div class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</div><div class="line">        mid = (low+high)/<span class="number">2</span>; <span class="comment">//从中间划分子序列</span></div><div class="line">        MergeSort(A,low,mid); <span class="comment">//对左侧子序列进行递归排序</span></div><div class="line">        MergeSort(A,mid+<span class="number">1</span>,high); <span class="comment">//对右侧子序列进行递归排序</span></div><div class="line">        Merge(A,low,mid,high); <span class="comment">//归并</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>空间效率： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>
时间效率： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mrow><mo fence="true">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">n \left \lceil log_2 n \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌈</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">⌉</span></span></span></span></span></p>
<h3 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h3>
<p>基数排序是一种特别的排序方法，它不是基于比较进行排序的，而是采用多关键字思想（根据各位的大小排序），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。</p>
<h4 id="两种模式"><a class="markdownIt-Anchor" href="#两种模式"></a> 两种模式</h4>
<p>分为最高位优先排序（MSD），最低位优先（LSD）排序</p>
<p>直接附上C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, a[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, b[MAX], m = a[<span class="number">0</span>], <span class="built_in">exp</span> = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</div><div class="line">      m = a[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (m / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">int</span> bucket[BASE] = &#123; <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">      bucket[(a[i] / <span class="built_in">exp</span>) % BASE]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; BASE; i++) &#123;</div><div class="line">      bucket[i] += bucket[i - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">      b[--bucket[(a[i] / <span class="built_in">exp</span>) % BASE]] = a[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">      a[i] = b[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">exp</span> *= BASE;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOWPASS</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\nPASS   : "</span>);</div><div class="line">    print(a, n);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> arr[MAX];</div><div class="line">  <span class="keyword">int</span> i, n;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Enter total elements (n &lt;= %d) : "</span>, MAX);</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">  n = n &lt; MAX ? n : MAX;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Enter %d Elements : "</span>, n);</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nARRAY  : "</span>);</div><div class="line">  print(&amp;arr[<span class="number">0</span>], n);</div><div class="line"></div><div class="line">  radixsort(&amp;arr[<span class="number">0</span>], n);</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nSORTED : "</span>);</div><div class="line">  print(&amp;arr[<span class="number">0</span>], n);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>d</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(d(n+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 其中r是队列数，d是趟数<br>
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></p>

    </article>
    <!-- 前后页  -->
    <ul class="post-pager">
        
            <li class="next">
                <a href= "/2017/10/24/struct/" title= Concept of Data Structure >
                    <span>Next Post</span>
                    <span>Concept of Data Structure</span>
                </a>
            </li>
        
        
            <li class="previous">
                <a href= "/2017/10/20/Docker-Primer/" title= Docker-Primer >
                    <span>Previous Post</span>
                    <span>Docker-Primer</span>
                </a>
            </li>
        
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!--PC版-->

    <!--PC版-->


    
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:admin@geekfan.club" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/mr-linus/" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title="rss"></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">Theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper">
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法"><span class="toc-number">1.</span> <span class="toc-text"> 排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">1.1.</span> <span class="toc-text"> 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接插入排序"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 直接插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#折半插入排序"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 折半插入排序:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#希尔shell排序"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 希尔(Shell)排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交换排序"><span class="toc-number">1.2.</span> <span class="toc-text"> 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序"><span class="toc-number">1.3.</span> <span class="toc-text"> 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单选择排序"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 简单选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#思想"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 思想：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆排序"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#堆"><span class="toc-number">1.3.2.1.</span> <span class="toc-text"> 堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#堆排序步骤"><span class="toc-number">1.3.2.2.</span> <span class="toc-text"> 堆排序步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#建堆大体流程"><span class="toc-number">1.3.2.3.</span> <span class="toc-text"> 建堆大体流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序二合一排序2-路归并排序"><span class="toc-number">1.4.</span> <span class="toc-text"> 归并排序（二合一排序/2-路归并排序）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思想-2"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基数排序"><span class="toc-number">1.5.</span> <span class="toc-text"> 基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两种模式"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 两种模式</span></a></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top">&#xe639;</div>
    <div class="sidebar">
    <div class="sidebar-header sidebar-header-show-archive">
        <div class="sidebar-category">
            <span class="sidebar-archive-link"><span class="iconfont-archer">&#xe67d;</span>Archive</span>
            <span class="sidebar-tags-link"><span class="iconfont-archer">&#xe610;</span>Tag</span>
        </div>
    </div>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-archive">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-archive"> Total : 3 </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2017/10/24/struct/" >Concept of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/23</span><a class="archive-post-title" href= "/2017/10/23/sort/" >Sort of Data Structure</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/20</span><a class="archive-post-title" href= "/2017/10/20/Docker-Primer/" >Docker-Primer</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name"><a href= "#">docker</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Data Structure</a></span>
    
    </div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #888; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: false
    tags: true</pre>
    </div> 
    <div class="sidebar-tag-list"></div>
</div>
    </div>
</div> 
    <script>
    var jsInfo = {
        root: '/'
    }
</script>
    <!-- 不蒜子  -->
    
    <!-- CNZZ统计  -->
    
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    </body>
</html>


